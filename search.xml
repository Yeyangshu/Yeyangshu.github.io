<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java NIO Channel</title>
    <url>/2020/12/24/Java-NIO-Channel/</url>
    <content><![CDATA[<h1 id="Java-NIO-Channel"><a href="#Java-NIO-Channel" class="headerlink" title="Java NIO Channel"></a>Java NIO Channel</h1><p><code>Java NIO Channels</code> 类似于流，但有一些区别：</p>
<ul>
<li>可以从通道中读取数据或写入数据到通道中。流通常是单向的（读或写）。</li>
<li>通道可以异步读写。</li>
<li>通道的数据总是被读取到缓冲区中或将缓冲区中数据写入到通道。<a id="more"></a>
如上所述，将数据从通道读取到缓冲区中，然后将数据从缓冲区写入通道中。这是一个说明：</li>
</ul>
<p><img src="http://tutorials.jenkov.com/images/java-nio/overview-channels-buffers.png" alt="Java NIO：通道和缓冲区"></p>
<h2 id="1-Channel-实现"><a href="#1-Channel-实现" class="headerlink" title="1 Channel 实现"></a>1 Channel 实现</h2><p>以下是 Java NIO 中最重要的 Channel 实现：</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p><code>FileChannel</code>从文件中读取和写入数据。</p>
<p><code>DatagramChannel</code>可以通过 UDP 读取和写入网络数据。</p>
<p><code>SocketChannel</code>可以通过 TCP 读取和写入网络数据。</p>
<p><code>ServerSocketChannel</code> 可以监听新的 TCP 连接，像 Web 服务器一样，为每个新的 TCP 连接创建一个<code>SocketChannel</code>。</p>
<h2 id="2-Channel-简单示例"><a href="#2-Channel-简单示例" class="headerlink" title="2 Channel 简单示例"></a>2 Channel 简单示例</h2><p>这是一个简单示例，该示例使用 <code>FileChannel</code> 将一些数据读取到 <code>Buffer</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RandomAccessFile accessFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;data/nio-data.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">FileChannel inChannel = accessFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">// create buffer with capacity 48 bytes.</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// read into buffer</span></span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buffer);</span><br><span class="line"><span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Read &quot;</span> + bytesRead);</span><br><span class="line">    <span class="comment">// make buffer ready for read.</span></span><br><span class="line">    buffer.flip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">        <span class="comment">// read 1 byte at a time.</span></span><br><span class="line">        System.out.println((<span class="keyword">char</span>) buffer.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make buffer ready for writing.</span></span><br><span class="line">    buffer.clear();</span><br><span class="line">    bytesRead = inChannel.read(buffer);</span><br><span class="line">&#125;</span><br><span class="line">accessFile.close();</span><br></pre></td></tr></table></figure>
<p>注意 <code>buf.flip()</code> 的调用。首先，读入数据到缓冲区，然后反转 Buffer，再从 Buffer 中读取数据。在下一节有关 <code>Buffer</code> 的文档中，将对此进行详细的说明。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java NIO 教程</title>
    <url>/2020/12/24/Java-NIO-%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Java-NIO-教程"><a href="#Java-NIO-教程" class="headerlink" title="Java NIO 教程"></a>Java NIO 教程</h1><p>本系列教程翻译自 Jakob Jenkov 的文章，原文链接：<a href="http://tutorials.jenkov.com/java-nio/index.html">http://tutorials.jenkov.com/java-nio/index.html</a></p>
<a id="more"></a>
<p>Java NIO（New IO）是 Java IO API 的替代品，意味着可以替代标准 Java IO 和 Java Networking API。 Java NIO 提供了与传统 IO API 不同的 IO 编程模型。 注意：有时 NIO 被称为是非阻塞 IO。 但是，这并不是 NIO 最初的意思。 另外，NIO API 的某些部分实际上是阻塞的，例如：文件 API，因此，“非阻塞”标签可能会引起误导。</p>
<h2 id="1-Java-NIO-Non-blocking-IO（非阻塞-IO）"><a href="#1-Java-NIO-Non-blocking-IO（非阻塞-IO）" class="headerlink" title="1 Java NIO: Non-blocking IO（非阻塞 IO）"></a>1 Java NIO: Non-blocking IO（非阻塞 IO）</h2><p>Java NIO 使您可以使用非阻塞 IO。 例如，线程可以要求通道将数据读入缓冲区，当通道将数据读入缓冲区时，线程可以执行其他操作。 一旦将数据读入缓冲区，线程就可以继续对其进行处理。 将数据写入通道时也是如此。</p>
<h2 id="2-Java-NIO-Channels-and-Buffers（通道和缓冲区）"><a href="#2-Java-NIO-Channels-and-Buffers（通道和缓冲区）" class="headerlink" title="2 Java NIO: Channels and Buffers（通道和缓冲区）"></a>2 Java NIO: Channels and Buffers（通道和缓冲区）</h2><p>标准的 IO 基于字节流和字符流进行操作的，而 NIO 是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。</p>
<h2 id="3-Java-NIO-Selectors（选择器）"><a href="#3-Java-NIO-Selectors（选择器）" class="headerlink" title="3 Java NIO: Selectors（选择器）"></a>3 Java NIO: Selectors（选择器）</h2><p>Java NIO包含“选择器”的概念。 选择器是一个对象，可以监视多个通道的事件（例如：打开连接，到达数据等）。 因此，单个线程可以监视多个通道以获取数据。</p>
<h2 id="4-Java-NIO-Concepts"><a href="#4-Java-NIO-Concepts" class="headerlink" title="4 Java NIO Concepts"></a>4 Java NIO Concepts</h2><p>与旧的 Java IO 模型相比，在 Java NIO 中需要学习几个新概念。 这些概念在下面列出：</p>
<ul>
<li><a href="http://tutorials.jenkov.com/java-nio/channels.html">Channels</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/buffers.html">Buffers</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/scatter-gather.html">Scatter - Gather</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/channel-to-channel-transfers.html">Channel to Channel Transfers</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/selectors.html">Selectors</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/file-channel.html">FileChannel</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/socketchannel.html">SocketChannel</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/server-socket-channel.html">ServerSocketChannel</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/non-blocking-server.html">Non-blocking Server Design</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/datagram-channel.html">DatagramChannel</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/pipe.html">Pipe</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/nio-vs-io.html">NIO vs. IO</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/path.html">Path</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/files.html">Files</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/asynchronousfilechannel.html">AsynchronousFileChannel</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java NIO 概述</title>
    <url>/2020/12/24/Java-NIO-%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="Java-NIO-概述"><a href="#Java-NIO-概述" class="headerlink" title="Java NIO 概述"></a>Java NIO 概述</h1><p>原文链接：<a href="http://tutorials.jenkov.com/java-nio/overview.html">http://tutorials.jenkov.com/java-nio/overview.html</a></p>
<a id="more"></a>
<p>Java NIO 由以下核心组件组成：</p>
<ul>
<li>通道</li>
<li>缓冲区</li>
<li>选择器</li>
</ul>
<p>Java NIO 拥有比这些更多的类和组件，但在我看来 <code>Channel</code>，<code>Buffer</code>  和 <code>Selector</code>构成了 API 的核心。其余组件，例如  <code>Pipe</code> 和 <code>FileLock</code> 仅仅是与三个核心组件结合使用的实用程序类。因此，在本 NIO 概述中，我将重点介绍这三个组件。其他组件在本教程的其他地方以其自己的文本进行了说明。</p>
<h2 id="1-通道（Channel）和缓冲区（Buffer）"><a href="#1-通道（Channel）和缓冲区（Buffer）" class="headerlink" title="1 通道（Channel）和缓冲区（Buffer）"></a>1 通道（Channel）和缓冲区（Buffer）</h2><p>通常，NIO 中的所有 IO 都从一个 <code>Channel</code> 开始。<code>Channel</code>有点像流。<code>Channel</code> 中的数据可以读入到一个<code>Buffer</code>。数据也可以从一个<code>Buffer</code>写入到<code>Channel</code>。如下图所示：</p>
<p><img src="http://tutorials.jenkov.com/images/java-nio/overview-channels-buffers.png" alt="Java NIO：通道和缓冲区"></p>
<p>Java NIO：通道将数据读取到缓冲区中，缓冲区将数据写入通道中</p>
<p>Java中有几种<code>Channel</code>和<code>Buffer</code>类型。这是<code>Channel</code>Java NIO中主要实现的列表：</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p>如您所见，这些通道涵盖 UDP + TCP 网络 IO 和文件 IO。</p>
<p>这些类也有一些有趣的接口，但是为了简单起见，我将它们排除在 Java NIO 概述之外。在本 Java NIO 教程的其他文本中将对它们进行解释。</p>
<p>这是 Java NIO 中 <code>Buffer</code> 的关键的实现：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>这些 <code>Buffer</code> 包括了您可以通过 IO 发送的基本数据类型：byte, short, int, long, float, double 和 char。</p>
<p>Java NIO 还有与内存映射文件结合使用的 <code>MappedByteBuffer</code> ，不过，不在 <code>Buffer</code>  概述中说明。</p>
<h2 id="2-选择器（Selectors）"><a href="#2-选择器（Selectors）" class="headerlink" title="2 选择器（Selectors）"></a>2 选择器（Selectors）</h2><p><code>Selector</code> 允许单线程处理多个 <code>Channel</code>。如果您的应用程序打开了很多个连接（通道），但每个连接的流量很少，使用 <code>Selector</code> 就会很方便。例如，在聊天服务器中。</p>
<p>这是使用一个 <code>Selector</code> 来处理 3 个 <code>Channel</code> 的示意图：</p>
<p><img src="http://tutorials.jenkov.com/images/java-nio/overview-selectors.png" alt="Java NIO：选择器"></p>
<p>要想使用 <code>Selector</code>，需要向 <code>Selector</code> 注册 <code>Channel</code>，然后，调用  <code>select()</code> 方法。该方法会一直阻塞，直到有一个已注册通道有事件准备就绪。方法返回后，线程就会处理这些事件。事件可以是传入连接，接收到的数据等。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis Hash mapping</title>
    <url>/2020/12/27/Redis-Hash-mapping/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 基于SpringBoot API的使用</title>
    <url>/2020/12/26/Redis-%E5%9F%BA%E4%BA%8ESpringBoot-API%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="基于-Spring-Boot-的-Redis-API-使用"><a href="#基于-Spring-Boot-的-Redis-API-使用" class="headerlink" title="基于 Spring Boot 的 Redis API 使用"></a>基于 Spring Boot 的 Redis API 使用</h1><a id="more"></a>

<h2 id="1-新建-Spring-Boot-项目"><a href="#1-新建-Spring-Boot-项目" class="headerlink" title="1 新建 Spring Boot 项目"></a>1 新建 Spring Boot 项目</h2><p>本次使用的工具是 <code>IDEA</code>，新建项目，点击 <code>Next</code></p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201226003848807.png" alt="image-20201226003848807"></p>
<p><code>NoSQL</code> 中选中 <code>Spring Data Redis</code>，继续点击 <code>Next</code></p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201226003954727.png" alt="image-20201226003954727"></p>
<p>选择一个合适的磁盘目录，创建新项目，一个新的项目就创建好了。</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201226004241036.png" alt="image-20201226004241036"></p>
<p>可以看到 <code>pom.xml</code> 中引用了 <code>spring-boot-starter-data-redis</code></p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201226004412233.png" alt="image-20201226004412233"></p>
<p><code>Maven</code> 依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-Redis-参数配置"><a href="#2-Redis-参数配置" class="headerlink" title="2 Redis 参数配置"></a>2 Redis 参数配置</h2><p>在 <code>application.properties</code>（也可以是 <code>application.yml</code>）添加 <code>Redis </code> 的参数：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br></pre></td></tr></table></figure>
<h2 id="3-基础-API"><a href="#3-基础-API" class="headerlink" title="3 基础 API"></a>3 基础 API</h2><h3 id="3-1-低级-API"><a href="#3-1-低级-API" class="headerlink" title="3.1 低级 API"></a>3.1 低级 API</h3><h4 id="3-1-1-RedisConnection"><a href="#3-1-1-RedisConnection" class="headerlink" title="3.1.1 RedisConnection"></a>3.1.1 RedisConnection</h4><p>虽然 <code>Redis</code> 是二进制安全的，但是 <code>RedisConnection</code> 提供了接受和返回二进制值（<code>byte</code> 数组）的低级方法，模板负责序列化和连接管理，用户无需处理此类细节。</p>
<h3 id="3-2-高级-API"><a href="#3-2-高级-API" class="headerlink" title="3.2 高级 API"></a>3.2 高级 API</h3><h4 id="3-2-1-RedisTemplate"><a href="#3-2-1-RedisTemplate" class="headerlink" title="3.2.1 RedisTemplate"></a>3.2.1 RedisTemplate</h4><p><code>RedisTemplate</code> 为 <code>Redis</code> 交互提供了高级抽象，提供了操作视图（根据Redis命令进行分组），提供了丰富的，通用的接口，用于针对某种类型或某些键（通过 <code>KeyBound</code> 接口），如下表所述：</p>
<table>
<thead>
<tr>
<th align="left">接口</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">按键类型操作</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>GeoOperations</code></td>
<td align="left">Redis 的 geospatial 操作, 例如 <code>GEOADD</code>, <code>GEORADIUS</code>,…</td>
</tr>
<tr>
<td align="left"><code>HashOperations</code></td>
<td align="left">Redis 的 hash 类型操作</td>
</tr>
<tr>
<td align="left"><code>HyperLogLogOperations</code></td>
<td align="left">Redis 的 HyperLogLog 操作, 例如 <code>PFADD</code>, <code>PFCOUNT</code>,…</td>
</tr>
<tr>
<td align="left"><code>ListOperations</code></td>
<td align="left">Redis 的 list 类型操作</td>
</tr>
<tr>
<td align="left"><code>SetOperations</code></td>
<td align="left">Redis 的 set 类型操作</td>
</tr>
<tr>
<td align="left"><code>ValueOperations</code></td>
<td align="left">Redis 的 string (或者 value) 类型操作</td>
</tr>
<tr>
<td align="left"><code>ZSetOperations</code></td>
<td align="left">Redis 的 zset (或者 sorted set) 类型操作</td>
</tr>
<tr>
<td align="left">键值绑定操作</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>BoundGeoOperations</code></td>
<td align="left">Redis 的 key 绑定 geospatial 操作</td>
</tr>
<tr>
<td align="left"><code>BoundHashOperations</code></td>
<td align="left">Redis 的 hash key 绑定操作</td>
</tr>
<tr>
<td align="left"><code>BoundKeyOperations</code></td>
<td align="left">Redis 的 key 绑定操作</td>
</tr>
<tr>
<td align="left"><code>BoundListOperations</code></td>
<td align="left">Redis 的 list key 绑定操作</td>
</tr>
<tr>
<td align="left"><code>BoundSetOperations</code></td>
<td align="left">Redis 的 set key 绑定操作</td>
</tr>
<tr>
<td align="left"><code>BoundValueOperations</code></td>
<td align="left">Redis 的 string (或者 value) key 绑定操作</td>
</tr>
<tr>
<td align="left"><code>BoundZSetOperations</code></td>
<td align="left">Redis 的 zset (或者 sorted set) key 绑定操作</td>
</tr>
</tbody></table>
<h4 id="3-2-2-StringRedisTemplate"><a href="#3-2-2-StringRedisTemplate" class="headerlink" title="3.2.2 StringRedisTemplate"></a>3.2.2 StringRedisTemplate</h4><p>由于 <code>Redis</code> 中的键和值通常是 <code>java.lang.String</code>，因此 <code>Redis</code> 提供对 <code>String</code> 类型操作更便利的 <code>StringRedisTemplate</code> 。</p>
<h2 id="4-API-操作测试案例"><a href="#4-API-操作测试案例" class="headerlink" title="4 API 操作测试案例"></a>4 API 操作测试案例</h2><p>新建测试类，本次使用的 <code>Junit5</code>，每次测试前首先清空 <code>Redis</code> 中所有数据</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201226210010782.png" alt="image-20201226210010782"></p>
<h3 id="4-1-String-类型操作案例"><a href="#4-1-String-类型操作案例" class="headerlink" title="4.1 String 类型操作案例"></a>4.1 String 类型操作案例</h3><p>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stringTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 使用低级API RedisConnection操作String</span></span><br><span class="line">        RedisConnection redisConnection = redisTemplate.getConnectionFactory().getConnection();</span><br><span class="line">        redisConnection.set(<span class="string">&quot;redisConnectionTestString&quot;</span>.getBytes(), <span class="string">&quot;redis connection test string&quot;</span>.getBytes());</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(redisConnection.get(<span class="string">&quot;redisConnectionTestString&quot;</span>.getBytes())));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 使用redisTemplate操作String</span></span><br><span class="line">        ValueOperations redisTemplateOperations = redisTemplate.opsForValue();</span><br><span class="line">        redisTemplateOperations.set(<span class="string">&quot;redisTmplOpsTestString&quot;</span>, <span class="string">&quot;redis template operations test string&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplateOperations.get(<span class="string">&quot;redisTmplOpsTestString&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 使用stringRedisTemplate操作String</span></span><br><span class="line">        ValueOperations&lt;String, String&gt; stringRedisTemplateOperations = stringRedisTemplate.opsForValue();</span><br><span class="line">        stringRedisTemplateOperations.set(<span class="string">&quot;stringRedisTmplOpsTestString&quot;</span>, <span class="string">&quot;string redis template operations test string&quot;</span>);</span><br><span class="line">        System.out.println(stringRedisTemplateOperations.get(<span class="string">&quot;stringRedisTmplOpsTestString&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 使用redisTemplate boundValueOps操作String</span></span><br><span class="line">        BoundValueOperations boundValueOps = redisTemplate.boundValueOps(<span class="string">&quot;redisTmplOpsTestString&quot;</span>);</span><br><span class="line">        System.out.println(boundValueOps.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 使用redisTemplate boundValueOps操作String</span></span><br><span class="line">        BoundValueOperations&lt;String, String&gt; stringBoundValueOperations = stringRedisTemplate.boundValueOps(<span class="string">&quot;stringRedisTmplOpsTestString&quot;</span>);</span><br><span class="line">        System.out.println(stringBoundValueOperations.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台打印：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis connection test string</span><br><span class="line">redis template operations test string</span><br><span class="line">string redis template operations test string</span><br><span class="line">redis template operations test string</span><br><span class="line">string redis template operations test string</span><br></pre></td></tr></table></figure>
<p><code>redis-cli</code> 查看：</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201226211610274.png" alt="image-20201226211610274"></p>
<p>上面 <code>keys *</code> 打印所有的 <code>key</code> 时 <code>3)</code> 显示乱码，是什么原因？</p>
<p>原因是 <code>Redis </code> 是二进制安全的，会把所有的数据变成二进制数组，有关序列化参考序列化文章。</p>
<h3 id="4-2-List-类型操作案例"><a href="#4-2-List-类型操作案例" class="headerlink" title="4.2 List 类型操作案例"></a>4.2 List 类型操作案例</h3><p>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">listTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        values.addAll(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 使用低级API RedisConnection操作List</span></span><br><span class="line">        RedisConnection redisConnection = redisTemplate.getConnectionFactory().getConnection();</span><br><span class="line">        redisConnection.lPush(<span class="string">&quot;redisConnectionTestList&quot;</span>.getBytes(), <span class="string">&quot;1&quot;</span>.getBytes(), <span class="string">&quot;2&quot;</span>.getBytes(), <span class="string">&quot;3&quot;</span>.getBytes());</span><br><span class="line">        System.out.println(redisConnection.lRange(<span class="string">&quot;redisConnectionTestList&quot;</span>.getBytes(), <span class="number">0L</span>, -<span class="number">1L</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 使用redisTemplate操作String</span></span><br><span class="line"></span><br><span class="line">        ListOperations redisTemplateOperations = redisTemplate.opsForList();</span><br><span class="line">        redisTemplateOperations.leftPushAll(<span class="string">&quot;redisTmplOpsTestList&quot;</span>, values);</span><br><span class="line">        System.out.println(redisTemplateOperations.range(<span class="string">&quot;redisTmplOpsTestList&quot;</span>, <span class="number">0L</span>, -<span class="number">1L</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 使用redisTemplate boundListOps操作List</span></span><br><span class="line">        BoundListOperations boundListOps = redisTemplate.boundListOps(<span class="string">&quot;redisTmplOpsTestList&quot;</span>);</span><br><span class="line">        System.out.println(boundListOps.range(<span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台打印：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[B@6fa0450e, [B@37468787, [B@51ec2856]</span><br><span class="line">[3, 2, 1]</span><br><span class="line">[3, 2, 1]</span><br></pre></td></tr></table></figure>
<p><code>redis-cli</code> 查看：</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201226214257532.png" alt="image-20201226214257532"></p>
<h3 id="4-3-Hash-类型操作案例"><a href="#4-3-Hash-类型操作案例" class="headerlink" title="4.3 Hash 类型操作案例"></a>4.3 Hash 类型操作案例</h3><p>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">listTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 使用低级API RedisConnection操作Hash</span></span><br><span class="line">        RedisConnection redisConnection = redisTemplate.getConnectionFactory().getConnection();</span><br><span class="line">        redisConnection.hSet(<span class="string">&quot;redisConnectionTestHash&quot;</span>.getBytes(), <span class="string">&quot;name&quot;</span>.getBytes(), <span class="string">&quot;yeyangshu&quot;</span>.getBytes());</span><br><span class="line">        redisConnection.hSet(<span class="string">&quot;redisConnectionTestHash&quot;</span>.getBytes(), <span class="string">&quot;age&quot;</span>.getBytes(), <span class="string">&quot;20&quot;</span>.getBytes());</span><br><span class="line">        System.out.println(redisConnection.hGet(<span class="string">&quot;redisConnectionTestHash&quot;</span>.getBytes(), <span class="string">&quot;name&quot;</span>.getBytes()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 使用redisTemplate操作Hash</span></span><br><span class="line">        HashOperations redisTemplateOperations = redisTemplate.opsForHash();</span><br><span class="line">        redisTemplateOperations.put(<span class="string">&quot;redisTmplOpsTestHash&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;yeyangshu&quot;</span>);</span><br><span class="line">        redisTemplateOperations.put(<span class="string">&quot;redisTmplOpsTestHash&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;20&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplateOperations.values(<span class="string">&quot;redisTmplOpsTestHash&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 使用redisTemplate boundHashOps操作Hash</span></span><br><span class="line">        BoundHashOperations boundHashOps = redisTemplate.boundHashOps(<span class="string">&quot;redisTmplOpsTestHash&quot;</span>);</span><br><span class="line">        System.out.println(boundHashOps.values());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台打印：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[B@33425811</span><br><span class="line">[yeyangshu, 20]</span><br><span class="line">[yeyangshu, 20]</span><br></pre></td></tr></table></figure>
<p><code>redis-cli</code> 查看：</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201226215806979.png" alt="image-20201226215806979"></p>
<p>使用 <code>Hash</code> 的时候更希望直接使用对象，会在后面文章讲解</p>
<h3 id="4-4-Set-类型操作案例"><a href="#4-4-Set-类型操作案例" class="headerlink" title="4.4 Set 类型操作案例"></a>4.4 Set 类型操作案例</h3><h3 id="4-5-Sorted-Sets-类型操作案例"><a href="#4-5-Sorted-Sets-类型操作案例" class="headerlink" title="4.5 Sorted Sets 类型操作案例"></a>4.5 Sorted Sets 类型操作案例</h3>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 基本数据类型 Hashes</title>
    <url>/2020/12/26/Redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-Hashes/</url>
    <content><![CDATA[<h1 id="Redis-Hashes"><a href="#Redis-Hashes" class="headerlink" title="Redis Hashes"></a>Redis Hashes</h1><h2 id="1-Hashes简介"><a href="#1-Hashes简介" class="headerlink" title="1 Hashes简介"></a>1 Hashes简介</h2><a id="more"></a>

<p>Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</p>
<p>Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）。</p>
<h2 id="2-Hashes命令"><a href="#2-Hashes命令" class="headerlink" title="2 Hashes命令"></a>2 Hashes命令</h2><h3 id="2-1-help-hash"><a href="#2-1-help-hash" class="headerlink" title="2.1 help @hash"></a>2.1 help @hash</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @hash</span><br><span class="line"></span><br><span class="line">  HDEL key field [field ...]</span><br><span class="line">  summary: Delete one or more hash fields</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HEXISTS key field</span><br><span class="line">  summary: Determine if a hash field exists</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HGET key field</span><br><span class="line">  summary: Get the value of a hash field</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HGETALL key</span><br><span class="line">  summary: Get all the fields and values in a hash</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HINCRBY key field increment</span><br><span class="line">  summary: Increment the integer value of a hash field by the given number</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HINCRBYFLOAT key field increment</span><br><span class="line">  summary: Increment the float value of a hash field by the given amount</span><br><span class="line">  since: 2.6.0</span><br><span class="line"></span><br><span class="line">  HKEYS key</span><br><span class="line">  summary: Get all the fields in a hash</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HLEN key</span><br><span class="line">  summary: Get the number of fields in a hash</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HMGET key field [field ...]</span><br><span class="line">  summary: Get the values of all the given hash fields</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HMSET key field value [field value ...]</span><br><span class="line">  summary: Set multiple hash fields to multiple values</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HSCAN key cursor [MATCH pattern] [COUNT count]</span><br><span class="line">  summary: Incrementally iterate hash fields and associated values</span><br><span class="line">  since: 2.8.0</span><br><span class="line"></span><br><span class="line">  HSET key field value</span><br><span class="line">  summary: Set the string value of a hash field</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HSETNX key field value</span><br><span class="line">  summary: Set the value of a hash field, only if the field does not exist</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HSTRLEN key field</span><br><span class="line">  summary: Get the length of the value of a hash field</span><br><span class="line">  since: 3.2.0</span><br><span class="line"></span><br><span class="line">  HVALS key</span><br><span class="line">  summary: Get all the values in a hash</span><br><span class="line">  since: 2.0.0</span><br></pre></td></tr></table></figure>
<h3 id="2-2-HSET-amp-HGET"><a href="#2-2-HSET-amp-HGET" class="headerlink" title="2.2 HSET&amp;HGET"></a>2.2 HSET&amp;HGET</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help hset</span><br><span class="line"></span><br><span class="line">  HSET key field value</span><br><span class="line">  summary: Set the string value of a hash field</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: hash</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help hget</span><br><span class="line"></span><br><span class="line">  HGET key field</span><br><span class="line">  summary: Get the value of a hash field</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: hash</span><br></pre></td></tr></table></figure>
<p>HSET：将哈希表 <code>key</code> 中的域 <code>field</code> 的值设为 <code>value</code> 。</p>
<ul>
<li><p>如果 <code>key</code> 不存在，一个新的哈希表被创建并进行 HSET 操作。</p>
</li>
<li><p>如果域 <code>field</code> 已经存在于哈希表中，旧值将被覆盖。</p>
</li>
</ul>
<p>HGET：返回哈希表 <code>key</code> 中给定域 <code>field</code> 的值。</p>
<ul>
<li>当给定域不存在或是给定 <code>key</code> 不存在时，返回 <code>nil</code> 。</li>
</ul>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将yeyangshu name赋值yeyangshu</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HSET yeyangshu name yeyangshu</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HGET yeyangshu name</span><br><span class="line"><span class="string">&quot;yeyangshu&quot;</span></span><br><span class="line"><span class="comment"># 将yeyangshu name覆盖赋值yeyang</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HSET yeyangshu name yeyang</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HGET yeyangshu name</span><br><span class="line"><span class="string">&quot;yeyang&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取不存在的域</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HGET yeyangshu age</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<h3 id="2-3-HMSET-amp-HMGET"><a href="#2-3-HMSET-amp-HMGET" class="headerlink" title="2.3 HMSET&amp;HMGET"></a>2.3 HMSET&amp;HMGET</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help hmset</span><br><span class="line"></span><br><span class="line">  HMSET key field value [field value ...]</span><br><span class="line">  summary: Set multiple hash fields to multiple values</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: hash</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help hmget</span><br><span class="line"></span><br><span class="line">  HMGET key field [field ...]</span><br><span class="line">  summary: Get the values of all the given hash fields</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: hash</span><br></pre></td></tr></table></figure>
<p>HMSET：同时将多个 <code>field-value</code> (域-值)对设置到哈希表 <code>key</code> 中。</p>
<ul>
<li>此命令会覆盖哈希表中已存在的域。</li>
</ul>
<p>HMGET：返回哈希表 <code>key</code> 中，一个或多个给定域的值。</p>
<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HMSET sean age 20 address beijing</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; HMGET sean name</span><br><span class="line">&quot;yeyangshu&quot;</span><br><span class="line">127.0.0.1:6379&gt; HMGET sean name age address</span><br><span class="line">1) &quot;yeyangshu&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">3) &quot;beijing&quot;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-HGETALL"><a href="#2-4-HGETALL" class="headerlink" title="2.4 HGETALL"></a>2.4 HGETALL</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help hgetall</span><br><span class="line"></span><br><span class="line">  HGETALL key</span><br><span class="line">  summary: Get all the fields and values in a hash</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: hash</span><br></pre></td></tr></table></figure>
<p>HGETALL：返回哈希表 <code>key</code> 中，所有的域和值。</p>
<ul>
<li>在返回值里，紧跟每个域名(field name)之后是域的值(value)，所以返回值的长度是哈希表大小的两倍。</li>
</ul>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HGETALL sean</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;yeyangshu&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;address&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-HKEYS-amp-HVALS"><a href="#2-5-HKEYS-amp-HVALS" class="headerlink" title="2.5 HKEYS&amp;HVALS"></a>2.5 HKEYS&amp;HVALS</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help hkeys</span><br><span class="line"></span><br><span class="line">  HKEYS key</span><br><span class="line">  summary: Get all the fields in a hash</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: hash</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help hvals</span><br><span class="line"></span><br><span class="line">  HVALS key</span><br><span class="line">  summary: Get all the values in a hash</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: hash</span><br></pre></td></tr></table></figure>
<p>HKEYS：返回哈希表 <code>key</code> 中的所有域。</p>
<p>HVALS：返回哈希表 <code>key</code> 中所有域的值。</p>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HKEYS sean</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;address&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HVALS sean</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;yeyangshu&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;beijing&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-6-HINCRBY-amp-HINCRBYFLOAT"><a href="#2-6-HINCRBY-amp-HINCRBYFLOAT" class="headerlink" title="2.6 HINCRBY&amp;HINCRBYFLOAT"></a>2.6 HINCRBY&amp;HINCRBYFLOAT</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help hincrby</span><br><span class="line"></span><br><span class="line">  HINCRBY key field increment</span><br><span class="line">  summary: Increment the integer value of a hash field by the given number</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: hash</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help hincrbyfloat</span><br><span class="line"></span><br><span class="line">  HINCRBYFLOAT key field increment</span><br><span class="line">  summary: Increment the float value of a hash field by the given amount</span><br><span class="line">  since: 2.6.0</span><br><span class="line">  group: hash</span><br></pre></td></tr></table></figure>
<p>HINCRBY：为哈希表 <code>key</code> 中的域 <code>field</code> 的值加上增量 <code>increment</code> 。</p>
<ul>
<li>增量也可以为负数，相当于对给定域进行减法操作。</li>
</ul>
<p>HINCRBYFLOAT：为哈希表 <code>key</code> 中的域 <code>field</code> 加上浮点数增量 <code>increment</code> 。</p>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HINCRBYFLOAT sean age <span class="number">0.5</span></span><br><span class="line"><span class="string">&quot;20.5&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HGET sean age</span><br><span class="line"><span class="string">&quot;20.5&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HINCRBYFLOAT sean age <span class="literal">-1</span></span><br><span class="line"><span class="string">&quot;19.5&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Hashes使用场景"><a href="#3-Hashes使用场景" class="headerlink" title="3 Hashes使用场景"></a>3 Hashes使用场景</h2><ol>
<li>Redis是内存的数据库，所有对值的操作都是非常快的，一般的商品详情页都会有很多字段信息，如果客户端请求这么多数据，每一个数据都需要请求一次数据库，可以使用Redis hashes，将所有的信息进行整合，数据整合，调用次数会变低。</li>
<li>数据都会变化，比如微博的个人关注、点赞或者商品详情页的浏览次数、被收藏的次数，数据不仅要被查询，还要进行计算，hash还支持数值计算。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 基本数据类型 Lists</title>
    <url>/2020/12/26/Redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-Lists/</url>
    <content><![CDATA[<h1 id="Redis-Lists"><a href="#Redis-Lists" class="headerlink" title="Redis Lists"></a>Redis Lists</h1><h2 id="1-Lists简介"><a href="#1-Lists简介" class="headerlink" title="1 Lists简介"></a>1 Lists简介</h2><a id="more"></a>

<p>官网：</p>
<p>Redis lists基于Linked Lists实现。这意味着即使在一个list中有数百万个元素，在头部或尾部添加一个元素的操作，其时间复杂度也是常数级别的。用LPUSH 命令在十个元素的list头部添加新元素，和在千万元素list头部添加新元素的速度相同。</p>
<p>那么，坏消息是什么？在数组实现的list中利用索引访问元素的速度极快，而同样的操作在linked list实现的list上没有那么快。</p>
<p>Redis Lists用linked list实现的原因是：对于数据库系统来说，至关重要的特性是：能非常快的在很大的列表上添加元素。另一个重要因素是，正如你将要看到的：Redis lists能在常数时间取得常数长度。</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200707204400692.png" alt="image-20200707204400692"></p>
<h2 id="2-List命令"><a href="#2-List命令" class="headerlink" title="2 List命令"></a>2 List命令</h2><h3 id="2-1-help-list"><a href="#2-1-help-list" class="headerlink" title="2.1 help @list"></a>2.1 help @list</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @list</span><br><span class="line"></span><br><span class="line">  BLPOP key [key ...] timeout</span><br><span class="line">  summary: Remove and get the first element in a list, or block until one is available</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  BRPOP key [key ...] timeout</span><br><span class="line">  summary: Remove and get the last element in a list, or block until one is available</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  BRPOPLPUSH source destination timeout</span><br><span class="line">  summary: Pop a value from a list, push it to another list and return it; or block until one is available</span><br><span class="line">  since: 2.2.0</span><br><span class="line"></span><br><span class="line">  LINDEX key index</span><br><span class="line">  summary: Get an element from a list by its index</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  LINSERT key BEFORE|AFTER pivot value</span><br><span class="line">  summary: Insert an element before or after another element in a list</span><br><span class="line">  since: 2.2.0</span><br><span class="line"></span><br><span class="line">  LLEN key</span><br><span class="line">  summary: Get the length of a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  LPOP key</span><br><span class="line">  summary: Remove and get the first element in a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  LPUSH key value [value ...]</span><br><span class="line">  summary: Prepend one or multiple values to a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  LPUSHX key value</span><br><span class="line">  summary: Prepend a value to a list, only if the list exists</span><br><span class="line">  since: 2.2.0</span><br><span class="line"></span><br><span class="line">  LRANGE key start stop</span><br><span class="line">  summary: Get a range of elements from a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  LREM key count value</span><br><span class="line">  summary: Remove elements from a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  LSET key index value</span><br><span class="line">  summary: Set the value of an element in a list by its index</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  LTRIM key start stop</span><br><span class="line">  summary: Trim a list to the specified range</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  RPOP key</span><br><span class="line">  summary: Remove and get the last element in a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  RPOPLPUSH source destination</span><br><span class="line">  summary: Remove the last element in a list, prepend it to another list and return it</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  RPUSH key value [value ...]</span><br><span class="line">  summary: Append one or multiple values to a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  RPUSHX key value</span><br><span class="line">  summary: Append a value to a list, only if the list exists</span><br><span class="line">  since: 2.2.0</span><br></pre></td></tr></table></figure>
<h3 id="2-2-LPUSH-amp-RPUSH-amp-LPOP-amp-RPOP"><a href="#2-2-LPUSH-amp-RPUSH-amp-LPOP-amp-RPOP" class="headerlink" title="2.2 LPUSH&amp;RPUSH&amp;LPOP&amp;RPOP"></a>2.2 LPUSH&amp;RPUSH&amp;LPOP&amp;RPOP</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help lpush</span><br><span class="line"></span><br><span class="line">  LPUSH key value [value ...]</span><br><span class="line">  summary: Prepend one or multiple values to a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: list</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help rpush</span><br><span class="line"></span><br><span class="line">  RPUSH key value [value ...]</span><br><span class="line">  summary: Append one or multiple values to a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: list</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help lpop</span><br><span class="line"></span><br><span class="line">  LPOP key</span><br><span class="line">  summary: Remove and get the first element in a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: list</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help rpop</span><br><span class="line"></span><br><span class="line">  RPOP key</span><br><span class="line">  summary: Remove and get the last element in a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: list</span><br></pre></td></tr></table></figure>
<p>LPUSH：将一个或多个值 <code>value</code> 插入到列表 <code>key</code> 的表头</p>
<ul>
<li>如果有多个 <code>value</code> 值，那么各个 <code>value</code> 值按从左到右的顺序依次插入到表头</li>
</ul>
<p>RPUSH：将一个或多个值 <code>value</code> 插入到列表 <code>key</code> 的表尾(最右边)。</p>
<ul>
<li>如果有多个 <code>value</code> 值，那么各个 <code>value</code> 值按从左到右的顺序依次插入到表尾</li>
</ul>
<p>LPOP：移除并返回列表 <code>key</code> 的头元素。</p>
<p>RPOP：移除并返回列表 <code>key</code> 的尾元素。</p>
<p><strong>可以实现两种数据结构：</strong></p>
<ul>
<li><strong>栈：同向命令实现，LPUSH+LPOP</strong></li>
<li><strong>队列：反向命令实现，LPUSH+RPOP</strong></li>
</ul>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此时链表排列顺序为 f e d c b a</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LPUSH k1 a b c d e f</span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"><span class="comment"># 此时链表排列顺序为 a b c d e f</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; RPUSH k2 a b c d e f</span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"><span class="comment"># 后进先出，栈</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LPOP k1</span><br><span class="line"><span class="string">&quot;f&quot;</span></span><br><span class="line"><span class="comment"># 先进先出，队列</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; RPOP k1</span><br><span class="line"><span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-LRANGE"><a href="#2-3-LRANGE" class="headerlink" title="2.3 LRANGE"></a>2.3 LRANGE</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help lrange</span><br><span class="line"></span><br><span class="line">  LRANGE key start stop</span><br><span class="line">  summary: Get a range of elements from a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: list</span><br></pre></td></tr></table></figure>
<p>LRANGE：返回列表 <code>key</code> 中指定区间内的元素，区间以偏移量 <code>start</code> 和 <code>stop</code> 指定。可以使用正负索引。</p>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此时链表排列顺序为 f e d c b a</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LPUSH k1 a b c d e f</span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LRANGE k1 <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;f&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;e&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时链表排列顺序为 a b c d e f</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; RPUSH k2 a b c d e f</span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LRANGE k2 <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;e&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;f&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-4-LINDEX-amp-LSET"><a href="#2-4-LINDEX-amp-LSET" class="headerlink" title="2.4 LINDEX&amp;LSET"></a>2.4 LINDEX&amp;LSET</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help lindex</span><br><span class="line"></span><br><span class="line">  LINDEX key index</span><br><span class="line">  summary: Get an element from a list by its index</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: list</span><br><span class="line">  </span><br><span class="line">127.0.0.1:6379&gt; help lset</span><br><span class="line"></span><br><span class="line">  LSET key index value</span><br><span class="line">  summary: Set the value of an element in a list by its index</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: list</span><br></pre></td></tr></table></figure>
<p>LINDEX：返回列表 <code>key</code> 中，下标为 <code>index</code> 的元素。将列表 <code>key</code> 下标为 <code>index</code> 的元素的值设置为 <code>value</code> 。</p>
<p>LSET：将列表 <code>key</code> 下标为 <code>index</code> 的元素的值设置为 <code>value</code> 。</p>
<ul>
<li>当 <code>index</code> 参数超出范围，或对一个空列表( <code>key</code> 不存在)进行 LSET 时，返回一个错误。</li>
</ul>
<p><strong>可以实现的数据结构</strong></p>
<ul>
<li><strong>数组：LINDEX+LSET，都是对下标进行操作</strong></li>
</ul>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此时链表排列顺序为 f(0) e(1) d(2) c(3) b(4) a(5)</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LPUSH k1 a b c d e f</span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"><span class="comment"># 取下标为2的元素</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LINDEX k1 <span class="number">2</span></span><br><span class="line"><span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="comment"># 取列表最后一位元素</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LINDEX k1 <span class="literal">-1</span></span><br><span class="line"><span class="string">&quot;a&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时链表排列顺序为 f(0) e(1) d(2) c(3) b(4) a(5)</span></span><br><span class="line"><span class="comment"># 设置下标为3的元素的值为X</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LSET k1 <span class="number">3</span> X</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LRANGE k1 <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;f&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;e&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;X&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-LREM-amp-LINSERT"><a href="#2-5-LREM-amp-LINSERT" class="headerlink" title="2.5 LREM&amp;LINSERT"></a>2.5 LREM&amp;LINSERT</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help lrem</span><br><span class="line"></span><br><span class="line">  LREM key count value</span><br><span class="line">  summary: Remove elements from a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: list</span><br><span class="line">  </span><br><span class="line">127.0.0.1:6379&gt; help linsert</span><br><span class="line"></span><br><span class="line">  LINSERT key BEFORE|AFTER pivot value</span><br><span class="line">  summary: Insert an element before or after another element in a list</span><br><span class="line">  since: 2.2.0</span><br><span class="line">  group: list</span><br></pre></td></tr></table></figure>
<p>LREM：根据参数 <code>count</code> 的值，移除列表中与参数 <code>value</code> 相等的元素。</p>
<p><code>count</code> 的值可以是以下几种：</p>
<ul>
<li><code>count &gt; 0</code> : 从表头开始向表尾搜索，移除与 <code>value</code> 相等的元素，数量为 <code>count</code> 。</li>
<li><code>count &lt; 0</code> : 从表尾开始向表头搜索，移除与 <code>value</code> 相等的元素，数量为 <code>count</code> 的绝对值。</li>
<li><code>count = 0</code> : 移除表中所有与 <code>value</code> 相等的值。</li>
</ul>
<p>LINSERT：将值 <code>value</code> 插入到列表 <code>key</code> 当中，位于值 <code>pivot</code> 之前或之后。</p>
<ul>
<li><p>当 <code>pivot</code> 不存在于列表 <code>key</code> 时，不执行任何操作。</p>
</li>
<li><p>当 <code>key</code> 不存在时， <code>key</code> 被视为空列表，不执行任何操作。</p>
</li>
<li><p>如果 <code>key</code> 不是列表类型，返回一个错误。</p>
</li>
</ul>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此时链表排列顺序为 7 a 6 e 5 a 4 c 3 b 2 a 1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LPUSH k3 <span class="number">1</span> a <span class="number">2</span> b <span class="number">3</span> c <span class="number">4</span> a <span class="number">5</span> e <span class="number">6</span> a <span class="number">7</span></span><br><span class="line">(integer) <span class="number">13</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LRANGE k3 <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"> <span class="number">1</span>) <span class="string">&quot;7&quot;</span></span><br><span class="line"> <span class="number">2</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"> <span class="number">3</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"> <span class="number">4</span>) <span class="string">&quot;e&quot;</span></span><br><span class="line"> <span class="number">5</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"> <span class="number">6</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"> <span class="number">7</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"> <span class="number">8</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"> <span class="number">9</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">10</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">11</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">12</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">13</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除链表元素，count&gt;0，从表头开始向表尾开始移除</span></span><br><span class="line"><span class="comment"># 此时链表排列顺序为 7 6 e 5 4 c 3 b 2 a 1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LREM k3 <span class="number">2</span> a</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LRANGE k3 <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"> <span class="number">1</span>) <span class="string">&quot;7&quot;</span></span><br><span class="line"> <span class="number">2</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"> <span class="number">3</span>) <span class="string">&quot;e&quot;</span></span><br><span class="line"> <span class="number">4</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"> <span class="number">5</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"> <span class="number">6</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"> <span class="number">7</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"> <span class="number">8</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"> <span class="number">9</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">10</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">11</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加链表元素</span></span><br><span class="line"><span class="comment"># 在元素6后面添加a，此时链表排列顺序为 7 6 a e 5 4 c 3 b 2 a 1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LINSERT k3 after <span class="number">6</span> a</span><br><span class="line">(integer) <span class="number">12</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LRANGE k3 <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"> <span class="number">1</span>) <span class="string">&quot;7&quot;</span></span><br><span class="line"> <span class="number">2</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"> <span class="number">3</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"> <span class="number">4</span>) <span class="string">&quot;e&quot;</span></span><br><span class="line"> <span class="number">5</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"> <span class="number">6</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"> <span class="number">7</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"> <span class="number">8</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"> <span class="number">9</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">10</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">11</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">12</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="comment"># 在元素3前面添加a，此时链表排列顺序为 7 6 a e 5 4 c a 3 b 2 a 1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LINSERT k3 before <span class="number">3</span> a</span><br><span class="line">(integer) <span class="number">13</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LRANGE k3 <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"> <span class="number">1</span>) <span class="string">&quot;7&quot;</span></span><br><span class="line"> <span class="number">2</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"> <span class="number">3</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"> <span class="number">4</span>) <span class="string">&quot;e&quot;</span></span><br><span class="line"> <span class="number">5</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"> <span class="number">6</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"> <span class="number">7</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"> <span class="number">8</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"> <span class="number">9</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">10</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">11</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">12</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">13</span>) <span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-6-LLEN"><a href="#2-6-LLEN" class="headerlink" title="2.6 LLEN"></a>2.6 LLEN</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help llen</span><br><span class="line"></span><br><span class="line">  LLEN key</span><br><span class="line">  summary: Get the length of a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: list</span><br></pre></td></tr></table></figure>
<p>LLEN：返回列表 <code>key</code> 的长度。</p>
<ul>
<li><p>如果 <code>key</code> 不存在，则 <code>key</code> 被解释为一个空列表，返回 <code>0</code> .</p>
</li>
<li><p>如果 <code>key</code> 不是列表类型，返回一个错误。</p>
</li>
</ul>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LRANGE k3 <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"> <span class="number">1</span>) <span class="string">&quot;7&quot;</span></span><br><span class="line"> <span class="number">2</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"> <span class="number">3</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"> <span class="number">4</span>) <span class="string">&quot;e&quot;</span></span><br><span class="line"> <span class="number">5</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"> <span class="number">6</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"> <span class="number">7</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"> <span class="number">8</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"> <span class="number">9</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">10</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">11</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">12</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">13</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="comment"># 返回k3的元素长度</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LLEN k3</span><br><span class="line">(integer) <span class="number">13</span></span><br></pre></td></tr></table></figure>
<h3 id="2-7-LTRIM"><a href="#2-7-LTRIM" class="headerlink" title="2.7 LTRIM"></a>2.7 LTRIM</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help ltrim</span><br><span class="line"></span><br><span class="line">  LTRIM key start stop</span><br><span class="line">  summary: Trim a list to the specified range</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: list</span><br></pre></td></tr></table></figure>
<p>LTRIM：对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</p>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LPUSH k1 <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></span><br><span class="line">(integer) <span class="number">9</span></span><br><span class="line"><span class="comment"># 此时链表排列顺序为 8(0) 7(1) 6(2) 5(3) 4(4) 3(5) 2(6) 1(7) 0(8)</span></span><br><span class="line"><span class="comment"># 将下标不在2-6的元素删除</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LTRIM k1 <span class="number">2</span> <span class="number">6</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LRANGE k1 <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;2&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-8-BLPOP-amp-BRPOP"><a href="#2-8-BLPOP-amp-BRPOP" class="headerlink" title="2.8 BLPOP&amp;BRPOP"></a>2.8 BLPOP&amp;BRPOP</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help blpop</span><br><span class="line"></span><br><span class="line">  BLPOP key [key ...] timeout</span><br><span class="line">  summary: Remove and get the first element in a list, or block until one is available</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: list</span><br><span class="line">  </span><br><span class="line">127.0.0.1:6379&gt; help brpop</span><br><span class="line"></span><br><span class="line">  BRPOP key [key ...] timeout</span><br><span class="line">  summary: Remove and get the last element in a list, or block until one is available</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: list</span><br></pre></td></tr></table></figure>
<p>BLPOP：列表的阻塞式(blocking)弹出原语，超时参数 <code>timeout</code> 接受一个以秒为单位的数字作为值。超时参数设为 <code>0</code> 表示阻塞时间可以无限期延长(block indefinitely) 。</p>
<ul>
<li><p>它是 LPOP 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BLPOP 命令阻塞，直到等待超时或发现可弹出元素为止。</p>
</li>
<li><p>当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的头元素。</p>
</li>
<li><p>如果所有给定 key 都不存在或包含空列表，那么 BLPOP 命令将阻塞连接，直到等待超时，或有另一个客户端对给定 key 的任意一个执行 LPUSH 或 RPUSH 命令为止。</p>
</li>
</ul>
<p>可以实现的数据结构：</p>
<ul>
<li><strong>阻塞、单播队列，FIFO：BLPOP</strong></li>
</ul>
<p>案例：</p>
<p>client1阻塞等待：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 无限期阻塞</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; BLPOP b1 <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>client2阻塞等待:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 无限期阻塞</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; BLPOP b1 <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>client3</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># client3向b1添加&quot;hello&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; RPUSH b1 hello</span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>此时client1接收到值</p>
<img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200707220037491.png"  align="left"/>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; BLPOP b1 <span class="number">0</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;b1&quot;</span>                          <span class="comment"># 这里被 push 的是 b1</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;hello&quot;</span>            			 <span class="comment"># 被弹出的值</span></span><br><span class="line">(<span class="number">26.97</span>s)                         <span class="comment"># 等待的秒数</span></span><br></pre></td></tr></table></figure>
<p>此时client2还在阻塞</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 无限期阻塞</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; BLPOP b1 <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>client3再向b1添加值</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># client3向b1添加&quot;world&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; RPUSH b1 world</span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>此时client2</p>
<img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200707220218395.png"  align="left"/>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; BLPOP b1 <span class="number">0</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;b1&quot;</span>                          <span class="comment"># 这里被 push 的是 b1</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;world&quot;</span>            			 <span class="comment"># 被弹出的值</span></span><br><span class="line">(<span class="number">35.33</span>s)                         <span class="comment"># 等待的秒数</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Lists应用场景"><a href="#3-Lists应用场景" class="headerlink" title="3 Lists应用场景"></a>3 Lists应用场景</h2><p>官网：</p>
<p>正如你可以从上面的例子中猜到的，list可被用来实现聊天系统。还可以作为不同进程间传递消息的队列。关键是，你可以每次都以原先添加的顺序访问数据。这不需要任何SQL ORDER BY 操作，将会非常快，也会很容易扩展到百万级别元素的规模。</p>
<p>例如在评级系统中，比如社会化新闻网站 reddit.com，你可以把每个新提交的链接添加到一个list，用LRANGE可简单的对结果分页。</p>
<p>在博客引擎实现中，你可为每篇日志设置一个list，在该list中推入博客评论，等等。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 基本数据类型 Sets</title>
    <url>/2020/12/26/Redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-Sets/</url>
    <content><![CDATA[<h1 id="Redis-Sets"><a href="#Redis-Sets" class="headerlink" title="Redis Sets"></a>Redis Sets</h1><h2 id="1-Sets简介"><a href="#1-Sets简介" class="headerlink" title="1 Sets简介"></a>1 Sets简介</h2><a id="more"></a>

<p>Redis Set 是 String 的无序排列。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p>
<p>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p>
<p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>
<h2 id="2-Sets命令"><a href="#2-Sets命令" class="headerlink" title="2 Sets命令"></a>2 Sets命令</h2><h3 id="2-1-help-set"><a href="#2-1-help-set" class="headerlink" title="2.1 help @set"></a>2.1 help @set</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @set</span><br><span class="line"></span><br><span class="line">  SADD key member [member ...]</span><br><span class="line">  summary: Add one or more members to a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SCARD key</span><br><span class="line">  summary: Get the number of members in a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SDIFF key [key ...]</span><br><span class="line">  summary: Subtract multiple sets</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SDIFFSTORE destination key [key ...]</span><br><span class="line">  summary: Subtract multiple sets and store the resulting set in a key</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SINTER key [key ...]</span><br><span class="line">  summary: Intersect multiple sets</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SINTERSTORE destination key [key ...]</span><br><span class="line">  summary: Intersect multiple sets and store the resulting set in a key</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SISMEMBER key member</span><br><span class="line">  summary: Determine if a given value is a member of a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SMEMBERS key</span><br><span class="line">  summary: Get all the members in a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SMOVE source destination member</span><br><span class="line">  summary: Move a member from one set to another</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SPOP key [count]</span><br><span class="line">  summary: Remove and return one or multiple random members from a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SRANDMEMBER key [count]</span><br><span class="line">  summary: Get one or multiple random members from a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SREM key member [member ...]</span><br><span class="line">  summary: Remove one or more members from a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SSCAN key cursor [MATCH pattern] [COUNT count]</span><br><span class="line">  summary: Incrementally iterate Set elements</span><br><span class="line">  since: 2.8.0</span><br><span class="line"></span><br><span class="line">  SUNION key [key ...]</span><br><span class="line">  summary: Add multiple sets</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SUNIONSTORE destination key [key ...]</span><br><span class="line">  summary: Add multiple sets and store the resulting set in a key</span><br><span class="line">  since: 1.0.0</span><br></pre></td></tr></table></figure>
<h3 id="2-2-SADD-amp-SMEMBERS"><a href="#2-2-SADD-amp-SMEMBERS" class="headerlink" title="2.2 SADD&amp;SMEMBERS"></a>2.2 SADD&amp;SMEMBERS</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help sadd</span><br><span class="line"></span><br><span class="line">  SADD key member [member ...]</span><br><span class="line">  summary: Add one or more members to a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: set</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help smembers</span><br><span class="line"></span><br><span class="line">  SMEMBERS key</span><br><span class="line">  summary: Get all the members in a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: set</span><br></pre></td></tr></table></figure>
<p>SADD：将一个或多个 <code>member</code> 元素加入到集合 <code>key</code> 当中，已经存在于集合的 <code>member</code> 元素将被忽略。</p>
<ul>
<li><p>假如 <code>key</code> 不存在，则创建一个只包含 <code>member</code> 元素作成员的集合。</p>
</li>
<li><p>当 <code>key</code> 不是集合类型时，返回一个错误。</p>
</li>
</ul>
<p>SMEMBERS：返回集合 <code>key</code> 中的所有成员。</p>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 向k1添加重复元素</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SADD k1 sean tom peter tom ooxx ooxx</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="comment"># k1取出所有元素</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SMEMBERS k1</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;ooxx&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;peter&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;tom&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;sean&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-SREM"><a href="#2-3-SREM" class="headerlink" title="2.3 SREM"></a>2.3 SREM</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help srem</span><br><span class="line"></span><br><span class="line">  SREM key member [member ...]</span><br><span class="line">  summary: Remove one or more members from a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: set</span><br></pre></td></tr></table></figure>
<p>SREM：移除集合 <code>key</code> 中的一个或多个 <code>member</code> 元素，不存在的 <code>member</code> 元素会被忽略。</p>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># k1取出所有元素</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SMEMBERS k1</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;ooxx&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;peter&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;tom&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;sean&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SREM k1 ooxx</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SMEMBERS k1</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;tom&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;sean&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;peter&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-4-SINTER-amp-SUNION-amp-SDIFF"><a href="#2-4-SINTER-amp-SUNION-amp-SDIFF" class="headerlink" title="2.4 SINTER&amp;SUNION&amp;SDIFF"></a>2.4 SINTER&amp;SUNION&amp;SDIFF</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help sinter</span><br><span class="line"></span><br><span class="line">  SINTER key [key ...]</span><br><span class="line">  summary: Intersect multiple sets</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: set</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help sinterstore</span><br><span class="line"></span><br><span class="line">  SINTERSTORE destination key [key ...]</span><br><span class="line">  summary: Intersect multiple sets and store the resulting set in a key</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: set</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help sunion</span><br><span class="line"></span><br><span class="line">  SUNION key [key ...]</span><br><span class="line">  summary: Add multiple sets</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: set</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help sdiff</span><br><span class="line"></span><br><span class="line">  SDIFF key [key ...]</span><br><span class="line">  summary: Subtract multiple sets</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: set</span><br></pre></td></tr></table></figure>
<p>SINTER：返回一个集合的全部成员，该集合是所有给定集合的交集。</p>
<p>SINTERSTORE：这个命令类似于 SINTER 命令，但它将结果保存到 <code>destination</code> 集合，而不是简单地返回结果集。</p>
<ul>
<li><p>如果 <code>destination</code> 集合已经存在，则将其覆盖。</p>
</li>
<li><p><code>destination</code> 可以是 <code>key</code> 本身。</p>
</li>
</ul>
<p>SUNION：返回一个集合的全部成员，该集合是所有给定集合的并集。</p>
<p>SUNIONSTORE：这个命令类似于 SUNION 命令，但它将结果保存到 <code>destination</code> 集合，而不是简单地返回结果集。</p>
<ul>
<li><p>如果 <code>destination</code> 已经存在，则将其覆盖。</p>
</li>
<li><p><code>-destination</code> 可以是 <code>key</code> 本身。</p>
</li>
</ul>
<p>SDIFF：返回一个集合的全部成员，该集合是所有给定集合之间的差集。</p>
<p>SDIFFSTORE：这个命令的作用和 SDIFF 类似，但它将结果保存到 <code>destination</code> 集合，而不是简单地返回结果集。</p>
<ul>
<li><p>如果 <code>destination</code> 集合已经存在，则将其覆盖。</p>
</li>
<li><p><code>destination</code> 可以是 <code>key</code> 本身。</p>
</li>
</ul>
<p>案例：</p>
<p>交集</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SADD k2 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SADD k3 <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"><span class="comment"># k3与k3交集</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SINTER k2 k3</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将交集结果存入dest</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SINTERSTORE dest k2 k3</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SMEMBERS dest</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;6&quot;</span></span><br></pre></td></tr></table></figure>
<p>并集</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SUNION k2 k3</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"><span class="number">7</span>) <span class="string">&quot;7&quot;</span></span><br><span class="line"><span class="number">8</span>) <span class="string">&quot;8&quot;</span></span><br></pre></td></tr></table></figure>
<p>差集</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SDIFF k2 k3</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SDIFF k3 k2</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;7&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;8&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-SRANDMEMBER-amp-SPOP"><a href="#2-5-SRANDMEMBER-amp-SPOP" class="headerlink" title="2.5 SRANDMEMBER&amp;SPOP"></a>2.5 SRANDMEMBER&amp;SPOP</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help srandmember</span><br><span class="line"></span><br><span class="line">  SRANDMEMBER key [count]</span><br><span class="line">  summary: Get one or multiple random members from a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: set</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help spop</span><br><span class="line"></span><br><span class="line">  SPOP key [count]</span><br><span class="line">  summary: Remove and return one or multiple random members from a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: set</span><br></pre></td></tr></table></figure>
<p>SRANDMEMBER：如果命令执行时，只提供了 <code>key</code> 参数，那么返回集合中的一个随机元素。</p>
<p>从 Redis 2.6 版本开始， SRANDMEMBER 命令接受可选的 <code>count</code> 参数：</p>
<ul>
<li>如果 <code>count</code> 为正数，且小于集合基数，那么命令返回一个包含 <code>count</code> 个元素的数组，数组中的元素<strong>各不相同</strong>。如果 <code>count</code> 大于等于集合基数，那么返回整个集合。</li>
<li>如果 <code>count</code> 为负数，那么命令返回一个数组，数组中的元素<strong>可能会重复出现多次</strong>，而数组的长度为 <code>count</code> 的绝对值。</li>
</ul>
<p>SPOP：移除并返回集合中的一个随机元素。</p>
<p>案例：</p>
<p>SRANDMEMBER</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SADD k2 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"><span class="comment"># count正数：取出一个去重的结果集（不能超过已有集）</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SRANDMEMBER k2 <span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="comment"># count负数：取出一个带重复的结果集</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SRANDMEMBER k2 <span class="literal">-3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"><span class="comment"># count为0，不返回</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SRANDMEMBER k2 <span class="number">0</span></span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SRANDMEMBER k2 <span class="number">10</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SRANDMEMBER k2 <span class="literal">-10</span></span><br><span class="line"> <span class="number">1</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"> <span class="number">2</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"> <span class="number">3</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"> <span class="number">4</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"> <span class="number">5</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"> <span class="number">6</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"> <span class="number">7</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"> <span class="number">8</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"> <span class="number">9</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">10</span>) <span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure>
<p>SPOP</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SPOP k2 <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SPOP k2 <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SPOP k2 <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SPOP k2 <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SPOP k2 <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SPOP k2 <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SPOP k2 <span class="number">1</span></span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure>
<h2 id="3-Sets使用场景"><a href="#3-Sets使用场景" class="headerlink" title="3 Sets使用场景"></a>3 Sets使用场景</h2><ol>
<li><p>随机抽奖，一次出结果</p>
<p>情景一 人多奖品少：3个奖品，10个人抽奖，抽3个并且没有重复，使用<code>SRANDMEMBER key 3</code></p>
<p>情景二 人少奖品多：10个奖品，3个人抽奖，抽10个可以有重复，使用<code>SRANDMEMBER key -10</code></p>
</li>
<li><p>随机抽奖，一次一个</p>
<p>奖品分为一、二、三等奖，每次只抽一个人，SPOP key 1</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 基本数据类型 Sorted Sets</title>
    <url>/2020/12/26/Redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-Sorted-Sets/</url>
    <content><![CDATA[<h1 id="Redis-Sorted-Sets"><a href="#Redis-Sorted-Sets" class="headerlink" title="Redis Sorted Sets"></a>Redis Sorted Sets</h1><h2 id="1-Sorted-Sets简介"><a href="#1-Sorted-Sets简介" class="headerlink" title="1 Sorted Sets简介"></a>1 Sorted Sets简介</h2><a id="more"></a>

<p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。</p>
<p>不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>有序集合的成员是唯一的,但分数(score)却可以重复。</p>
<p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>
<h2 id="2-Sorted-Sets命令"><a href="#2-Sorted-Sets命令" class="headerlink" title="2 Sorted Sets命令"></a>2 Sorted Sets命令</h2><h3 id="2-1-help-sorted-set"><a href="#2-1-help-sorted-set" class="headerlink" title="2.1 help @sorted_set"></a>2.1 help @sorted_set</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @sorted_set</span><br><span class="line"></span><br><span class="line">  ZADD key [NX|XX] [CH] [INCR] score member [score member ...]</span><br><span class="line">  summary: Add one or more members to a sorted set, or update its score if it already exists</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  ZCARD key</span><br><span class="line">  summary: Get the number of members in a sorted set</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  ZCOUNT key min max</span><br><span class="line">  summary: Count the members in a sorted set with scores within the given values</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  ZINCRBY key increment member</span><br><span class="line">  summary: Increment the score of a member in a sorted set</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]</span><br><span class="line">  summary: Intersect multiple sorted sets and store the resulting sorted set in a new key</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  ZLEXCOUNT key min max</span><br><span class="line">  summary: Count the number of members in a sorted set between a given lexicographical range</span><br><span class="line">  since: 2.8.9</span><br><span class="line"></span><br><span class="line">  ZRANGE key start stop [WITHSCORES]</span><br><span class="line">  summary: Return a range of members in a sorted set, by index</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  ZRANGEBYLEX key min max [LIMIT offset count]</span><br><span class="line">  summary: Return a range of members in a sorted set, by lexicographical range</span><br><span class="line">  since: 2.8.9</span><br><span class="line"></span><br><span class="line">  ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br><span class="line">  summary: Return a range of members in a sorted set, by score</span><br><span class="line">  since: 1.0.5</span><br><span class="line"></span><br><span class="line">  ZRANK key member</span><br><span class="line">  summary: Determine the index of a member in a sorted set</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  ZREM key member [member ...]</span><br><span class="line">  summary: Remove one or more members from a sorted set</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  ZREMRANGEBYLEX key min max</span><br><span class="line">  summary: Remove all members in a sorted set between the given lexicographical range</span><br><span class="line">  since: 2.8.9</span><br><span class="line"></span><br><span class="line">  ZREMRANGEBYRANK key start stop</span><br><span class="line">  summary: Remove all members in a sorted set within the given indexes</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  ZREMRANGEBYSCORE key min max</span><br><span class="line">  summary: Remove all members in a sorted set within the given scores</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  ZREVRANGE key start stop [WITHSCORES]</span><br><span class="line">  summary: Return a range of members in a sorted set, by index, with scores ordered from high to low</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  ZREVRANGEBYLEX key max min [LIMIT offset count]</span><br><span class="line">  summary: Return a range of members in a sorted set, by lexicographical range, ordered from higher to lower strings.</span><br><span class="line">  since: 2.8.9</span><br><span class="line"></span><br><span class="line">  ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</span><br><span class="line">  summary: Return a range of members in a sorted set, by score, with scores ordered from high to low</span><br><span class="line">  since: 2.2.0</span><br><span class="line"></span><br><span class="line">  ZREVRANK key member</span><br><span class="line">  summary: Determine the index of a member in a sorted set, with scores ordered from high to low</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  ZSCAN key cursor [MATCH pattern] [COUNT count]</span><br><span class="line">  summary: Incrementally iterate sorted sets elements and associated scores</span><br><span class="line">  since: 2.8.0</span><br><span class="line"></span><br><span class="line">  ZSCORE key member</span><br><span class="line">  summary: Get the score associated with the given member in a sorted set</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]</span><br><span class="line">  summary: Add multiple sorted sets and store the resulting sorted set in a new key</span><br><span class="line">  since: 2.0.0</span><br></pre></td></tr></table></figure>
<h3 id="2-2-ZADD"><a href="#2-2-ZADD" class="headerlink" title="2.2 ZADD"></a>2.2 ZADD</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help zadd</span><br><span class="line"></span><br><span class="line">  ZADD key [NX|XX] [CH] [INCR] score member [score member ...]</span><br><span class="line">  summary: Add one or more members to a sorted set, or update its score if it already exists</span><br><span class="line">  since: 1.2.0</span><br><span class="line">  group: sorted_set</span><br></pre></td></tr></table></figure>
<p>ZADD：将一个或多个 <code>member</code> 元素及其 <code>score</code> 值加入到有序集 <code>key</code> 当中。</p>
<ul>
<li>如果某个 <code>member</code> 已经是有序集的成员，那么更新这个 <code>member</code> 的 <code>score</code> 值，并通过重新插入这个 <code>member</code> 元素，来保证该 <code>member</code> 在正确的位置上。</li>
<li><code>score</code> 值可以是整数值或双精度浮点数。</li>
</ul>
<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># apple 8，banana 2，orange 3</span><br><span class="line">127.0.0.1:6379&gt; ZADD k1 8 apple 2 banana 3 orange</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>
<h3 id="2-3-ZRANGE-amp-ZRANGEBYSCORE-amp-ZREVRANGE"><a href="#2-3-ZRANGE-amp-ZRANGEBYSCORE-amp-ZREVRANGE" class="headerlink" title="2.3 ZRANGE&amp;ZRANGEBYSCORE&amp;ZREVRANGE"></a>2.3 ZRANGE&amp;ZRANGEBYSCORE&amp;ZREVRANGE</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help zrange</span><br><span class="line"></span><br><span class="line">  ZRANGE key start stop [WITHSCORES]</span><br><span class="line">  summary: Return a range of members in a sorted set, by index</span><br><span class="line">  since: 1.2.0</span><br><span class="line">  group: sorted_set</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help zrangebyscore</span><br><span class="line"></span><br><span class="line">  ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br><span class="line">  summary: Return a range of members in a sorted set, by score</span><br><span class="line">  since: 1.0.5</span><br><span class="line">  group: sorted_set</span><br></pre></td></tr></table></figure>
<p><strong>取值相关命令</strong></p>
<p>ZRANGE：返回有序集 <code>key</code> 中，指定区间内的成员。</p>
<ul>
<li>其中成员的位置按 <code>score</code> 值递增(从小到大)来排序。</li>
<li>具有相同 <code>score</code> 值的成员按字典序来排列。</li>
<li>可以通过使用 <code>WITHSCORES</code> 选项，来让成员和它的 <code>score</code> 值一并返回，返回列表以 <code>value1,score1, ..., valueN,scoreN</code> 的格式表示。</li>
</ul>
<p>ZRANGEBYSCORE：返回有序集 <code>key</code> 中，所有 <code>score</code> 值介于 <code>min</code> 和 <code>max</code> 之间(包括等于 <code>min</code> 或 <code>max</code> )的成员。有序集成员按 <code>score</code> 值递增(从小到大)次序排列。</p>
<ul>
<li>具有相同 <code>score</code> 值的成员按字典序来排列(该属性是有序集提供的，不需要额外的计算)。</li>
<li>可选的 <code>WITHSCORES</code> 参数决定结果集是单单返回有序集的成员，还是将有序集成员及其 <code>score</code> 值一起返回。</li>
</ul>
<p>ZREVRANGE：ZREVRANGE返回有序集 <code>key</code> 中，指定区间内的成员。</p>
<ul>
<li>其中成员的位置按 <code>score</code> 值递减(从大到小)来排列。</li>
<li>具有相同 <code>score</code> 值的成员按字典序的逆序EVRANGE 命令的其他方面和 ZRANGE 命令一样。</li>
</ul>
<p>ZREVRANGEBYSCORE：返回有序集 <code>key</code> 中， <code>score</code> 值介于 <code>max</code> 和 <code>min</code> 之间(默认包括等于 <code>max</code> 或 <code>min</code> )的所有的成员。有序集成员按 <code>score</code> 值递减(从大到小)的次序排列。</p>
<ul>
<li>具有相同 <code>score</code> 值的成员按字典序的逆序排列。</li>
<li>除了成员按 <code>score</code> 值递减的次序排列这一点外，ZREVRANGEBYSCORE 命令的其他方面和ZRANGEBYSCORE命令一样。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ZRANGE 按照 score 正序排列</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE k1 0 -1</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;orange&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line"># 使用 WITHSCORES，成员和 score 一起返回</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE k1 0 -1 withscores</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;orange&quot;</span><br><span class="line">4) &quot;3&quot;</span><br><span class="line">5) &quot;apple&quot;</span><br><span class="line">6) &quot;8&quot;</span><br><span class="line"># 使用下标</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE k1 -2 -1</span><br><span class="line">1) &quot;orange&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line"></span><br><span class="line"># 返回score 3~8区间的值</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE k1 3 8</span><br><span class="line">1) &quot;orange&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line"></span><br><span class="line"># ZRANGE 按照 score 逆序排列</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE k1 0 1</span><br><span class="line">1) &quot;apple&quot;</span><br><span class="line">2) &quot;orange&quot;</span><br><span class="line"># ZREVRANGEBYSCORE 逆序排列</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGEBYSCORE k1 8 3</span><br><span class="line">1) &quot;apple&quot;</span><br><span class="line">2) &quot;orange&quot;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-ZSCORE"><a href="#2-4-ZSCORE" class="headerlink" title="2.4 ZSCORE"></a>2.4 ZSCORE</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help zscore</span><br><span class="line"></span><br><span class="line">  ZSCORE key member</span><br><span class="line">  summary: Get the score associated with the given member in a sorted set</span><br><span class="line">  since: 1.2.0</span><br><span class="line">  group: sorted_set</span><br></pre></td></tr></table></figure>
<p>ZSCORE：返回有序集 <code>key</code> 中，成员 <code>member</code> 的 <code>score</code> 值。</p>
<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZSCORE k1 apple</span><br><span class="line">&quot;8&quot;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-ZRANK-amp-ZREVRANK"><a href="#2-5-ZRANK-amp-ZREVRANK" class="headerlink" title="2.5 ZRANK&amp;ZREVRANK"></a>2.5 ZRANK&amp;ZREVRANK</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help zrank</span><br><span class="line"></span><br><span class="line">  ZRANK key member</span><br><span class="line">  summary: Determine the index of a member in a sorted set</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: sorted_set</span><br></pre></td></tr></table></figure>
<p>ZRANK：返回有序集 <code>key</code> 中成员 <code>member</code> 的排名。其中有序集成员按 <code>score</code> 值递增(从小到大)顺序排列。</p>
<p>ZREVRANK：返回有序集 <code>key</code> 中成员 <code>member</code> 的排名。其中有序集成员按 <code>score</code> 值递减(从大到小)排序。</p>
<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZRANK k1 apple</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>
<h3 id="2-6-ZINCRBY"><a href="#2-6-ZINCRBY" class="headerlink" title="2.6 ZINCRBY"></a>2.6 ZINCRBY</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help zincrby</span><br><span class="line"></span><br><span class="line">  ZINCRBY key increment member</span><br><span class="line">  summary: Increment the score of a member in a sorted set</span><br><span class="line">  since: 1.2.0</span><br><span class="line">  group: sorted_set</span><br></pre></td></tr></table></figure>
<p>ZINCRBY：为有序集 <code>key</code> 的成员 <code>member</code> 的 <code>score</code> 值加上增量 <code>increment</code> 。</p>
<ul>
<li>可以通过传递一个负数值 <code>increment</code> ，让 <code>score</code> 减去相应的值，比如 <code>ZINCRBY key -5 member</code> ，就是让 <code>member</code> 的 <code>score</code> 值减去 <code>5</code> 。</li>
</ul>
<p>算数运算</p>
<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZINCRBY k1 2.5 banana</span><br><span class="line">&quot;4.5&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE k1 0 -1 withscores</span><br><span class="line">1) &quot;orange&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;banana&quot;</span><br><span class="line">4) &quot;4.5&quot;</span><br><span class="line">5) &quot;apple&quot;</span><br><span class="line">6) &quot;8&quot;</span><br></pre></td></tr></table></figure>
<h3 id="2-7-ZUNIONSTORE-amp-ZINTERSTORE"><a href="#2-7-ZUNIONSTORE-amp-ZINTERSTORE" class="headerlink" title="2.7 ZUNIONSTORE&amp;ZINTERSTORE"></a>2.7 ZUNIONSTORE&amp;<strong>ZINTERSTORE</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help zunionstore</span><br><span class="line"></span><br><span class="line">  ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]</span><br><span class="line">  summary: Add multiple sorted sets and store the resulting sorted set in a new key</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: sorted_set</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help zinterstore</span><br><span class="line"></span><br><span class="line">  ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]</span><br><span class="line">  summary: Intersect multiple sorted sets and store the resulting sorted set in a new key</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: sorted_set</span><br></pre></td></tr></table></figure>
<p>ZUNIONSTORE：计算给定的一个或多个有序集的并集，其中给定 <code>key</code> 的数量必须以 <code>numkeys</code> 参数指定，并将该并集(结果集)储存到 <code>destination</code> 。</p>
<ul>
<li><p>默认情况下，结果集中某个成员的 <code>score</code> 值是所有给定集下该成员 <code>score</code> 值之和 。</p>
</li>
<li><p><strong>WEIGHTS</strong></p>
<p>使用 <code>WEIGHTS</code> 选项，你可以为 <em>每个</em> 给定有序集 <em>分别</em> 指定一个乘法因子(multiplication factor)，每个给定有序集的所有成员的 <code>score</code> 值在传递给聚合函数(aggregation function)之前都要先乘以该有序集的因子。</p>
<p>如果没有指定 <code>WEIGHTS</code> 选项，乘法因子默认设置为 <code>1</code> 。</p>
</li>
<li><p><strong>AGGREGATE</strong></p>
<p>使用 <code>AGGREGATE</code> 选项，你可以指定并集的结果集的聚合方式。</p>
<p>默认使用的参数 <code>SUM</code> ，可以将所有集合中某个成员的 <code>score</code> 值之 <em>和</em> 作为结果集中该成员的 <code>score</code> 值；使用参数 <code>MIN</code> ，可以将所有集合中某个成员的 <em>最小</em> <code>score</code> 值作为结果集中该成员的 <code>score</code> 值；而参数 <code>MAX</code> 则是将所有集合中某个成员的最大 <code>score</code> 值作为结果集中该成员的 <code>score</code> 值。</p>
</li>
</ul>
<p>ZINTERSTORE ：计算给定的一个或多个有序集的交集，其中给定 <code>key</code> 的数量必须以 <code>numkeys</code> 参数指定，并将该交集(结果集)储存到 <code>destination</code> 。</p>
<ul>
<li>默认情况下，结果集中某个成员的 <code>score</code> 值是所有给定集下该成员 <code>score</code> 值之和.</li>
</ul>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设有两个学科的考试分数</span></span><br><span class="line"><span class="comment"># 第一科分数</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZADD k1 <span class="number">80</span> tom <span class="number">60</span> sean <span class="number">70</span> baby</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="comment"># 第二科分数</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZADD k2 <span class="number">60</span> tom <span class="number">100</span> sean <span class="number">40</span> peter</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="comment"># numkeys为2，k1和k2进行整合</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZUNIONSTORE unkey <span class="number">2</span> k1 k2</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="comment"># 查看整合后的分值,默认SUM相加，正序排列</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZRANGE unkey <span class="number">0</span> <span class="literal">-1</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;peter&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;40&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;baby&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;70&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;tom&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;140&quot;</span></span><br><span class="line"><span class="number">7</span>) <span class="string">&quot;sean&quot;</span></span><br><span class="line"><span class="number">8</span>) <span class="string">&quot;160&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试权重，k1权重为1，k2权重为0.5</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZUNIONSTORE unkey1 <span class="number">2</span> k1 k2 WEIGHTS <span class="number">1</span> <span class="number">0.5</span></span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="comment"># 例如sean分数：60+100*0.5=110</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZRANGE unkey1 <span class="number">0</span> <span class="literal">-1</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;peter&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;baby&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;70&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;sean&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;110&quot;</span></span><br><span class="line"><span class="number">7</span>) <span class="string">&quot;tom&quot;</span></span><br><span class="line"><span class="number">8</span>) <span class="string">&quot;110&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试聚合，使用max</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZUNIONSTORE unkey2 <span class="number">2</span> k1 k2 aggregate max</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="comment"># 返回k1、k2分数最大值</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZRANGE unkey2 <span class="number">0</span> <span class="literal">-1</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;peter&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;40&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;baby&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;70&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;tom&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;80&quot;</span></span><br><span class="line"><span class="number">7</span>) <span class="string">&quot;sean&quot;</span></span><br><span class="line"><span class="number">8</span>) <span class="string">&quot;100&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 并集测试，不存在的值直接删掉</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZINTERSTORE interkey <span class="number">2</span> k1 k2</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZRANGE interkey <span class="number">0</span> <span class="literal">-1</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;tom&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;140&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;sean&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;160&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Sorted-Sets使用场景"><a href="#3-Sorted-Sets使用场景" class="headerlink" title="3 Sorted Sets使用场景"></a>3 Sorted Sets使用场景</h2><p>歌曲排行榜前十名</p>
<p>歌曲排行榜，第一天上线，所有的歌曲得分值都是0，排行榜按什么排名？可能是播放量、下载数、点播量其中一个，是正序还是倒序的？</p>
<p>可以使用Redis的ZINCYBY，某一首歌播放了一次，就加1，也可以非常快的使用ZRANGE&amp;ZREVRANGE正序或倒序排序。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 序列化器</title>
    <url>/2020/12/26/Redis-%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/</url>
    <content><![CDATA[<h1 id="Redis-序列化器"><a href="#Redis-序列化器" class="headerlink" title="Redis 序列化器"></a>Redis 序列化器</h1><a id="more"></a>

<p>从框架的角度来看，Redis 中存储的数据仅为字节。尽管 Redis 本身支持各种类型，但在大多数情况下，它们是指数据的存储方式，而不是其表示的内容。是否将信息转换为字符串或其他对象由用户自己决定。</p>
<p>Spring Data 中，Redis 可以通过<code>org.springframework.data.redis.serializer</code> 包处理用户（自定义）类型和原始数据之间的转换（反之亦然）。</p>
<p>该软件包包含两种类型的序列化器，顾名思义，它们负责序列化过程：</p>
<ul>
<li>基于的两路串行器的<code>RedisSerializer</code>。</li>
<li>使用 <code>RedisElementReader</code> 和 <code>RedisElementWriter</code> 的元素读取器和元素写入器。</li>
</ul>
<p>两者之间的主要区别在于，<code>RedisSerializer</code> 序列化为 <code>byte[]</code>，而 readers 和 writers 序列化为<code>ByteBuffer</code>。</p>
<p>接口的截图：</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201226225711767.png" alt="image-20201226225711767"></p>
<p>Spring Data Redis 的序列化器提供了多种实现方式：</p>
<ul>
<li>GenericToStringSerializer：使用 Spring 转换服务进行序列化。</li>
<li>GenericJackson2JsonRedisSerializer：将对象序列化为 Json</li>
<li>Jackson2JsonRedisSerializer：使用 Jackson2，将对象序列化为 Json。</li>
<li>JdkSerializationRedisSerializer：使用 Java 序列化，<code>RedisCache</code> 和 <code>RedisTemplate</code> 默认使用此方式。</li>
<li>OxmSerializer：使用 Spring O/X 映射的编排器和解排器实现序列化，用于 XML 序列化。</li>
<li>StringRedisSerializer：序列化 String 类型的 key 和 value。</li>
</ul>
<p>存储格式不仅限于 values，也可以无限制地用于 keys, values 或者 hashes。</p>
<h2 id="1-默认序列化器"><a href="#1-默认序列化器" class="headerlink" title="1 默认序列化器"></a>1 默认序列化器</h2><p> <code>RedisTemplate</code> 默认使用 <code>JdkSerializationRedisSerializer</code>，<code>StringRedisTemplate </code> 默认使用 <code>StringRedisSerializer</code></p>
<h2 id="2-自定义序列化器"><a href="#2-自定义序列化器" class="headerlink" title="2 自定义序列化器"></a>2 自定义序列化器</h2><p>如果在实际项目中上述序列化器中没有符合需求的序列化器，或者不使用默认的序列化器，那么可以自定义序列化器。</p>
<p>例如，使用  <code>RedisTemplate</code>  时，希望 key 是 String 类型，而 value 是 自定义的 Person 类且序列化为 JSON，就可以自定义 key 和 value 的序列化器。</p>
<p>配置代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Person&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory cf)</span></span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Person&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(cf);</span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        redisTemplate.setValueSerializer(<span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(Person.class));</span><br><span class="line">        <span class="keyword">return</span>  redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot 线程池（一）：使用同步线程池</title>
    <url>/2020/12/21/SpringBoot-%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%90%8C%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="SpringBoot-线程池（一）：使用同步线程池"><a href="#SpringBoot-线程池（一）：使用同步线程池" class="headerlink" title="SpringBoot 线程池（一）：使用同步线程池"></a>SpringBoot 线程池（一）：使用同步线程池</h1><a id="more"></a>
<h2 id="1-创建任务"><a href="#1-创建任务" class="headerlink" title="1 创建任务"></a>1 创建任务</h2><h3 id="1-1-创建同步任务类-SyncTask"><a href="#1-1-创建同步任务类-SyncTask" class="headerlink" title="1.1 创建同步任务类 SyncTask"></a>1.1 创建同步任务类 SyncTask</h3><p>创建同步任务类 <code>SyncTask</code>，添加 <code>@Component</code> 注释</p>
<h3 id="1-2-创建需要执行的任务"><a href="#1-2-创建需要执行的任务" class="headerlink" title="1.2 创建需要执行的任务"></a>1.2 创建需要执行的任务</h3><p>为了测试方便，只打印一行信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：sync execute task...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-创建线程池、任务执行调用方法"><a href="#1-3-创建线程池、任务执行调用方法" class="headerlink" title="1.3 创建线程池、任务执行调用方法"></a>1.3 创建线程池、任务执行调用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 同步任务线程池 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">20</span>, <span class="number">60L</span>,</span><br><span class="line">	TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">50</span>),</span><br><span class="line">	<span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">&quot;sync-task-thread-pool-%d&quot;</span>).build());</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提交任务给线程池</span></span><br><span class="line">    executorService.submit(<span class="keyword">this</span>::sync);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-SyncTask-类完整代码"><a href="#1-4-SyncTask-类完整代码" class="headerlink" title="1.4 SyncTask 类完整代码"></a>1.4 SyncTask 类完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 同步任务线程池 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">20</span>, <span class="number">60L</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">50</span>),</span><br><span class="line">            <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">&quot;sync-task-thread-pool-%d&quot;</span>).build());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：sync execute task...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 提交任务给线程池</span></span><br><span class="line">        executorService.submit(<span class="keyword">this</span>::sync);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-创建单元测试进行测试"><a href="#2-创建单元测试进行测试" class="headerlink" title="2 创建单元测试进行测试"></a>2 创建单元测试进行测试</h2><p>本次使用 <code>JUnit5</code> 进行测试，完整代码如下：</p>
<h3 id="2-1-不使用线程池"><a href="#2-1-不使用线程池" class="headerlink" title="2.1 不使用线程池"></a>2.1 不使用线程池</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudyApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	SyncTask syncTask;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncWithoutThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;start execute task...&quot;</span>);</span><br><span class="line">		<span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">			syncTask.sync();</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;total time：&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印日志结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start execute task...</span><br><span class="line">main：sync execute task...</span><br><span class="line">main：sync execute task...</span><br><span class="line">main：sync execute task...</span><br><span class="line">main：sync execute task...</span><br><span class="line">main：sync execute task...</span><br><span class="line">main：sync execute task...</span><br><span class="line">main：sync execute task...</span><br><span class="line">main：sync execute task...</span><br><span class="line">main：sync execute task...</span><br><span class="line">main：sync execute task...</span><br><span class="line">total time：10117</span><br></pre></td></tr></table></figure>
<h3 id="2-2-使用线程池"><a href="#2-2-使用线程池" class="headerlink" title="2.2 使用线程池"></a>2.2 使用线程池</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudyApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	SyncTask syncTask;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncWithThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;start execute task...&quot;</span>);</span><br><span class="line">		<span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">			syncTask.execute();</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;total time：&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印日志结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start execute task...</span><br><span class="line">sync-task-thread-pool-0：sync execute task...</span><br><span class="line">sync-task-thread-pool-1：sync execute task...</span><br><span class="line">sync-task-thread-pool-2：sync execute task...</span><br><span class="line">sync-task-thread-pool-3：sync execute task...</span><br><span class="line">sync-task-thread-pool-4：sync execute task...</span><br><span class="line">sync-task-thread-pool-5：sync execute task...</span><br><span class="line">sync-task-thread-pool-6：sync execute task...</span><br><span class="line">sync-task-thread-pool-7：sync execute task...</span><br><span class="line">sync-task-thread-pool-8：sync execute task...</span><br><span class="line">total time：2</span><br><span class="line">sync-task-thread-pool-9：sync execute task...</span><br></pre></td></tr></table></figure>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>由上述结果可见：使用线程池执行批量任务速度要快。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot 线程池（二）：使用异步线程池</title>
    <url>/2020/12/21/SpringBoot-%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="SpringBoot-线程池（二）：使用异步线程池"><a href="#SpringBoot-线程池（二）：使用异步线程池" class="headerlink" title="SpringBoot 线程池（二）：使用异步线程池"></a>SpringBoot 线程池（二）：使用异步线程池</h1><a id="more"></a>
<h2 id="1-创建异步线程池配置"><a href="#1-创建异步线程池配置" class="headerlink" title="1 创建异步线程池配置"></a>1 创建异步线程池配置</h2><h3 id="1-1-配置线程池属性"><a href="#1-1-配置线程池属性" class="headerlink" title="1.1 配置线程池属性"></a>1.1 配置线程池属性</h3><p>在 <code>application.properties</code> 配置文件中添加异步线程池的相关属性</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 异步线程池相关属性</span></span><br><span class="line"><span class="meta">asyncThreadPool.corePoolSize</span> = <span class="string">10</span></span><br><span class="line"><span class="meta">asyncThreadPool.maxPoolSize</span> = <span class="string">20</span></span><br><span class="line"><span class="meta">asyncThreadPool.queueCapacity</span> = <span class="string">50</span></span><br><span class="line"><span class="meta">asyncThreadPool.keepAliveSeconds</span> = <span class="string">60</span></span><br><span class="line"><span class="meta">asyncThreadPool.threadNamePrefix</span> = <span class="string">async-task-thread-pool-%d</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-创建线程池配置类"><a href="#1-2-创建线程池配置类" class="headerlink" title="1.2 创建线程池配置类"></a>1.2 创建线程池配置类</h3><p>创建 <code>AsyncConfig</code> 类并添加 <code>@Configuration</code> 注释，完整配置如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步线程池配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;asyncThreadPool.corePoolSize&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;asyncThreadPool.maxPoolSize&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxPoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;asyncThreadPool.queueCapacity&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;asyncThreadPool.keepAliveSeconds&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> keepAliveSeconds;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;asyncThreadPool.threadNamePrefix&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String threadNamePrefix;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">asyncExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor threadPoolTaskExecutor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        threadPoolTaskExecutor.setCorePoolSize(corePoolSize);</span><br><span class="line">        threadPoolTaskExecutor.setMaxPoolSize(maxPoolSize);</span><br><span class="line">        threadPoolTaskExecutor.setQueueCapacity(queueCapacity);</span><br><span class="line">        threadPoolTaskExecutor.setKeepAliveSeconds(keepAliveSeconds);</span><br><span class="line">        threadPoolTaskExecutor.setThreadNamePrefix(threadNamePrefix);</span><br><span class="line">        threadPoolTaskExecutor.initialize();</span><br><span class="line">        <span class="keyword">return</span> threadPoolTaskExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-创建任务"><a href="#2-创建任务" class="headerlink" title="2 创建任务"></a>2 创建任务</h2><h3 id="2-1-创建异步任务类-SyncTask"><a href="#2-1-创建异步任务类-SyncTask" class="headerlink" title="2.1 创建异步任务类 SyncTask"></a>2.1 创建异步任务类 SyncTask</h3><p>创建同步任务类 <code>AsyncTask</code>，添加 <code>@Component</code> 注释</p>
<h3 id="2-2-创建需要执行的任务"><a href="#2-2-创建需要执行的任务" class="headerlink" title="2.2 创建需要执行的任务"></a>2.2 创建需要执行的任务</h3><p>为了测试方便，只打印一行信息，异步任务需要添加 <code>@Async</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Async(&quot;asyncExecutor&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：async execute task...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-SyncTask-类完整代码"><a href="#2-3-SyncTask-类完整代码" class="headerlink" title="2.3  SyncTask 类完整代码"></a>2.3  SyncTask 类完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async(&quot;asyncExecutor&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：async execute task...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-创建单元测试进行测试"><a href="#2-创建单元测试进行测试" class="headerlink" title="2 创建单元测试进行测试"></a>2 创建单元测试进行测试</h2><p>本次使用 <code>JUnit5</code> 进行测试，完整代码如下：</p>
<h3 id="2-1-无返回值"><a href="#2-1-无返回值" class="headerlink" title="2.1 无返回值"></a>2.1 无返回值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudyApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	AsyncTask asyncTask;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncWithThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;start execute task...&quot;</span>);</span><br><span class="line">		<span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 无返回值</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">			asyncTask.execute();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;total time：&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印日志结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start execute task...</span><br><span class="line">total time：5</span><br><span class="line">async-task-thread-pool-1：async execute task...</span><br><span class="line">async-task-thread-pool-10：async execute task...</span><br><span class="line">async-task-thread-pool-8：async execute task...</span><br><span class="line">async-task-thread-pool-6：async execute task...</span><br><span class="line">async-task-thread-pool-5：async execute task...</span><br><span class="line">async-task-thread-pool-7：async execute task...</span><br><span class="line">async-task-thread-pool-4：async execute task...</span><br><span class="line">async-task-thread-pool-9：async execute task...</span><br><span class="line">async-task-thread-pool-3：async execute task...</span><br><span class="line">async-task-thread-pool-2：async execute task...</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>使用ThreadLocal创建线程上下文</title>
    <url>/2020/12/26/%E4%BD%BF%E7%94%A8ThreadLocal%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<h1 id="使用ThreadLocal创建线程上下文"><a href="#使用ThreadLocal创建线程上下文" class="headerlink" title="使用ThreadLocal创建线程上下文"></a>使用ThreadLocal创建线程上下文</h1><a id="more"></a>

<h2 id="1-定义上下文接口"><a href="#1-定义上下文接口" class="headerlink" title="1 定义上下文接口"></a>1 定义上下文接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加属性</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(String key, Object object)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得属性</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">get</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-定义上下文实现类"><a href="#2-定义上下文实现类" class="headerlink" title="2 定义上下文实现类"></a>2 定义上下文实现类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskThreadContext</span> <span class="keyword">implements</span> <span class="title">ThreadContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 订单id */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> orderId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 任务开始执行时间 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> startTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** task context map */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; taskContextMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String key, Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == taskContextMap) &#123;</span><br><span class="line">            taskContextMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        taskContextMap.put(key, object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == taskContextMap) &#123;</span><br><span class="line">            taskContextMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> taskContextMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrderId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderId</span><span class="params">(<span class="keyword">int</span> orderId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderId = orderId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getStartTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStartTime</span><span class="params">(<span class="keyword">long</span> startTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.startTime = startTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-定义ThreadContext持有类"><a href="#3-定义ThreadContext持有类" class="headerlink" title="3 定义ThreadContext持有类"></a>3 定义ThreadContext持有类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskContextHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** task context threadLocal */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ThreadContext&gt; TASK_CONTEXT = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadContext <span class="title">getTaskContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (TASK_CONTEXT.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            TASK_CONTEXT.set(<span class="keyword">new</span> TaskThreadContext());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> TASK_CONTEXT.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setTaskContext</span><span class="params">(ThreadContext taskContext)</span> </span>&#123;</span><br><span class="line">        TASK_CONTEXT.set(taskContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String key, Object param)</span> </span>&#123;</span><br><span class="line">        getTaskContext().add(key, param);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getTaskContext().get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4 测试"></a>4 测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程t1</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 添加上下文</span></span><br><span class="line">            TaskThreadContext context = <span class="keyword">new</span> TaskThreadContext();</span><br><span class="line">            context.setOrderId(<span class="number">1</span>);</span><br><span class="line">            TaskContextHolder.setTaskContext(context);</span><br><span class="line">            <span class="comment">// 添加普通属性</span></span><br><span class="line">            TaskContextHolder.add(<span class="string">&quot;t1&quot;</span>, <span class="string">&quot;Hello t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">            TaskThreadContext taskContext = (TaskThreadContext) TaskContextHolder.getTaskContext();</span><br><span class="line">            System.out.println(<span class="string">&quot;t1 order id：&quot;</span> + taskContext.getOrderId());</span><br><span class="line">            System.out.println(<span class="string">&quot;t1：&quot;</span> + TaskContextHolder.get(<span class="string">&quot;t1&quot;</span>));</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程t2</span></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 添加上下文</span></span><br><span class="line">            TaskThreadContext context = <span class="keyword">new</span> TaskThreadContext();</span><br><span class="line">            context.setOrderId(<span class="number">2</span>);</span><br><span class="line">            TaskContextHolder.setTaskContext(context);</span><br><span class="line">            <span class="comment">// 添加普通属性</span></span><br><span class="line">            TaskContextHolder.add(<span class="string">&quot;t2&quot;</span>, <span class="string">&quot;Hello t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">            TaskThreadContext taskContext = (TaskThreadContext) TaskContextHolder.getTaskContext();</span><br><span class="line">            System.out.println(<span class="string">&quot;t2 order id：&quot;</span> + taskContext.getOrderId());</span><br><span class="line">            System.out.println(<span class="string">&quot;t2：&quot;</span> + TaskContextHolder.get(<span class="string">&quot;t2&quot;</span>));</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t1 order id：1</span><br><span class="line">t1：Hello t1</span><br><span class="line">t2 order id：2</span><br><span class="line">t2：Hello t2</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>ThreadLocal</tag>
        <tag>上下文</tag>
      </tags>
  </entry>
  <entry>
    <title>项目启动加载配置类型数据至内存</title>
    <url>/2020/12/25/%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E8%87%B3%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h1 id="项目启动加载配置类型数据至内存"><a href="#项目启动加载配置类型数据至内存" class="headerlink" title="项目启动加载配置类型数据至内存"></a>项目启动加载配置类型数据至内存</h1><a id="more"></a>

<p>一般数据分类</p>
<ul>
<li>流水型数据</li>
<li>状态型数据</li>
<li>配置型数据。</li>
</ul>
<p>对于配置型数据而言，改动不是很频繁，可以在项目启动的时候直接加载到内存，避免需要数据时去查询数据库，造成不必要的IO消耗。<br>配置类型的数据可以在数据库中存储，也可以托管至github。<br>下图是启动时加载数据的原理图：<br><img src="https://img2020.cnblogs.com/blog/2029601/202012/2029601-20201219215901828-1492959658.png"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Redis 基本数据类型 String</title>
    <url>/2020/12/26/Redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-String/</url>
    <content><![CDATA[<h1 id="Redis-Strings"><a href="#Redis-Strings" class="headerlink" title="Redis Strings"></a>Redis Strings</h1><h2 id="1-Strings-简介"><a href="#1-Strings-简介" class="headerlink" title="1 Strings 简介"></a>1 Strings 简介</h2><p>官网：</p>
<p>这是最简单Redis类型。如果你只用这种类型，Redis就像一个可以持久化的memcached服务器</p>
<a id="more"></a>

<h2 id="2-String-命令"><a href="#2-String-命令" class="headerlink" title="2 String 命令"></a>2 String 命令</h2><h3 id="2-1-help-string"><a href="#2-1-help-string" class="headerlink" title="2.1 help @string"></a>2.1 help @string</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @string</span><br><span class="line"></span><br><span class="line">  APPEND key value</span><br><span class="line">  summary: Append a value to a key</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  BITCOUNT key [start end]</span><br><span class="line">  summary: Count set bits in a string</span><br><span class="line">  since: 2.6.0</span><br><span class="line"></span><br><span class="line">  BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]</span><br><span class="line">  summary: Perform arbitrary bitfield integer operations on strings</span><br><span class="line">  since: 3.2.0</span><br><span class="line"></span><br><span class="line">  BITOP operation destkey key [key ...]</span><br><span class="line">  summary: Perform bitwise operations between strings</span><br><span class="line">  since: 2.6.0</span><br><span class="line"></span><br><span class="line">  BITPOS key bit [start] [end]</span><br><span class="line">  summary: Find first bit set or clear in a string</span><br><span class="line">  since: 2.8.7</span><br><span class="line"></span><br><span class="line">  DECR key</span><br><span class="line">  summary: Decrement the integer value of a key by one</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  DECRBY key decrement</span><br><span class="line">  summary: Decrement the integer value of a key by the given number</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  GET key</span><br><span class="line">  summary: Get the value of a key</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  GETBIT key offset</span><br><span class="line">  summary: Returns the bit value at offset in the string value stored at key</span><br><span class="line">  since: 2.2.0</span><br><span class="line"></span><br><span class="line">  GETRANGE key start end</span><br><span class="line">  summary: Get a substring of the string stored at a key</span><br><span class="line">  since: 2.4.0</span><br><span class="line"></span><br><span class="line">  GETSET key value</span><br><span class="line">  summary: Set the string value of a key and return its old value</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  INCR key</span><br><span class="line">  summary: Increment the integer value of a key by one</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  INCRBY key increment</span><br><span class="line">  summary: Increment the integer value of a key by the given amount</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  INCRBYFLOAT key increment</span><br><span class="line">  summary: Increment the float value of a key by the given amount</span><br><span class="line">  since: 2.6.0</span><br><span class="line"></span><br><span class="line">  MGET key [key ...]</span><br><span class="line">  summary: Get the values of all the given keys</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  MSET key value [key value ...]</span><br><span class="line">  summary: Set multiple keys to multiple values</span><br><span class="line">  since: 1.0.1</span><br><span class="line"></span><br><span class="line">  MSETNX key value [key value ...]</span><br><span class="line">  summary: Set multiple keys to multiple values, only if none of the keys exist</span><br><span class="line">  since: 1.0.1</span><br><span class="line"></span><br><span class="line">  PSETEX key milliseconds value</span><br><span class="line">  summary: Set the value and expiration in milliseconds of a key</span><br><span class="line">  since: 2.6.0</span><br><span class="line"></span><br><span class="line">  SET key value [expiration EX seconds|PX milliseconds] [NX|XX]</span><br><span class="line">  summary: Set the string value of a key</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SETBIT key offset value</span><br><span class="line">  summary: Sets or clears the bit at offset in the string value stored at key</span><br><span class="line">  since: 2.2.0</span><br><span class="line"></span><br><span class="line">  SETEX key seconds value</span><br><span class="line">  summary: Set the value and expiration of a key</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  SETNX key value</span><br><span class="line">  summary: Set the value of a key, only if the key does not exist</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SETRANGE key offset value</span><br><span class="line">  summary: Overwrite part of a string at key starting at the specified offset</span><br><span class="line">  since: 2.2.0</span><br><span class="line"></span><br><span class="line">  STRLEN key</span><br><span class="line">  summary: Get the length of the value stored in a key</span><br><span class="line">  since: 2.2.0</span><br></pre></td></tr></table></figure>
<h3 id="2-2-Strings字符串操作命令详解"><a href="#2-2-Strings字符串操作命令详解" class="headerlink" title="2.2 Strings字符串操作命令详解"></a>2.2 Strings字符串操作命令详解</h3><h4 id="2-2-1-SET-amp-GET"><a href="#2-2-1-SET-amp-GET" class="headerlink" title="2.2.1 SET&amp;GET"></a>2.2.1 SET&amp;GET</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help set</span><br><span class="line"></span><br><span class="line">  SET key value [EX seconds] [PX milliseconds] [NX|XX]</span><br><span class="line">  summary: Set the string value of a key</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: string</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help get</span><br><span class="line"></span><br><span class="line">  GET key</span><br><span class="line">  summary: Get the value of a key</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>通常用SET command 和 GET command来设置和获取字符串值，值可以是任何种类的字符串（包括二进制数据）</p>
<ul>
<li><p>EX：过期时间</p>
</li>
<li><p>PX：时间单位</p>
</li>
<li><p>NX ：key未创建时则创建，已经创建时不创建。</p>
<p>用处：分布式锁，一堆人都想删一个文件，很多链接对单线程redis操作，谁成功就拿到锁，其余人失败</p>
</li>
<li><p>XX：只能更新，key存在时更新，key不存在时不能更新</p>
</li>
</ul>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span>测试</span></span><br><span class="line">127.0.0.1:6379&gt; set k1 hello</span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash"> get测试</span></span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;hello&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> nx测试</span></span><br><span class="line">127.0.0.1:6379&gt; set k1 ooxx nx</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;hello&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> xx测试</span></span><br><span class="line">127.0.0.1:6379&gt; set k2 hello xx</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<h4 id="2-2-2-MSET-amp-MGET"><a href="#2-2-2-MSET-amp-MGET" class="headerlink" title="2.2.2 MSET&amp;MGET"></a>2.2.2 MSET&amp;MGET</h4><p>同时设置一个或多个 key-value 对。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help mset</span><br><span class="line"></span><br><span class="line">  MSET key value [key value ...]</span><br><span class="line">  summary: Set multiple keys to multiple values</span><br><span class="line">  since: 1.0.1</span><br><span class="line">  group: string</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help mget</span><br><span class="line"></span><br><span class="line">  MGET key [key ...]</span><br><span class="line">  summary: Get the values of all the given keys</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置[k3,a]，[k4,b]</span></span><br><span class="line">127.0.0.1:6379&gt; mset k3 a k4 b</span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取k3，k4的value</span></span><br><span class="line">127.0.0.1:6379&gt; mget k3 k4</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-3-APPEND"><a href="#2-2-3-APPEND" class="headerlink" title="2.2.3 APPEND"></a>2.2.3 APPEND</h4><p>如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help append</span><br><span class="line"></span><br><span class="line">  APPEND key value</span><br><span class="line">  summary: Append a value to a key</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; append k1 &quot; world&quot;</span><br><span class="line">(integer) 11</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;hello world&quot;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-4-GETRANGE-amp-SETRANGE"><a href="#2-2-4-GETRANGE-amp-SETRANGE" class="headerlink" title="2.2.4 GETRANGE&amp;SETRANGE"></a>2.2.4 GETRANGE&amp;SETRANGE</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help getrange</span><br><span class="line"></span><br><span class="line">  GETRANGE key start end</span><br><span class="line">  summary: Get a substring of the string stored at a key</span><br><span class="line">  since: 2.4.0</span><br><span class="line">  group: string</span><br><span class="line">  </span><br><span class="line">127.0.0.1:6379&gt; help setrange</span><br><span class="line"></span><br><span class="line">  SETRANGE key offset value</span><br><span class="line">  summary: Overwrite part of a string at key starting at the specified offset</span><br><span class="line">  since: 2.2.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>GETRANGE：获取存储在指定 key 中字符串的子字符串。字符串的截取范围由 start 和 end 两个偏移量决定(包括 start 和 end 在内)。</p>
<p>SETRANGE：用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 此时k1 value=<span class="string">&quot;hello world&quot;</span></span></span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;hello world&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取子字符串<span class="string">&quot;world&quot;</span></span></span><br><span class="line">127.0.0.1:6379&gt; GETRANGE k1 6 10</span><br><span class="line">&quot;world&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 逆向索引取值</span></span><br><span class="line">127.0.0.1:6379&gt; GETRANGE k1 6 -1</span><br><span class="line">&quot;world&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 正向索引取值</span></span><br><span class="line">127.0.0.1:6379&gt; GETRANGE k1 0 -1</span><br><span class="line">&quot;hello world&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> SETRANGE</span></span><br><span class="line">127.0.0.1:6379&gt; SETRANGE k1 6 yeyangshu</span><br><span class="line">(integer) 15</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;hello yeyangshu&quot;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-5-STRLEN"><a href="#2-2-5-STRLEN" class="headerlink" title="2.2.5 STRLEN"></a>2.2.5 STRLEN</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help strlen</span><br><span class="line"></span><br><span class="line">  STRLEN key</span><br><span class="line">  summary: Get the length of the value stored in a key</span><br><span class="line">  since: 2.2.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>获取指定 key 所储存的字符串值的长度。当 key 储存的不是字符串值时，返回一个错误。</p>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;hello yeyangshu&quot;</span><br><span class="line">127.0.0.1:6379&gt; STRLEN k1</span><br><span class="line">(integer) 15</span><br></pre></td></tr></table></figure>
<h4 id="2-2-6-GETSET"><a href="#2-2-6-GETSET" class="headerlink" title="2.2.6 GETSET"></a>2.2.6 GETSET</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help getset</span><br><span class="line"></span><br><span class="line">  GETSET key value</span><br><span class="line">  summary: Set the string value of a key and return its old value</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>设置指定 key 的值，并返回 key 的旧值。</p>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GET k1</span><br><span class="line">&quot;100&quot;</span><br><span class="line">127.0.0.1:6379&gt; GETSET k1 200</span><br><span class="line">&quot;100&quot;</span><br><span class="line">127.0.0.1:6379&gt; GET k1</span><br><span class="line">&quot;200&quot;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-7-MSETNX"><a href="#2-2-7-MSETNX" class="headerlink" title="2.2.7 MSETNX"></a>2.2.7 MSETNX</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help MSETNX</span><br><span class="line"></span><br><span class="line">  MSETNX key value [key value ...]</span><br><span class="line">  summary: Set multiple keys to multiple values, only if none of the keys exist</span><br><span class="line">  since: 1.0.1</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都<strong>不存在</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置k1、k2的值</span></span><br><span class="line">127.0.0.1:6379&gt; MSETNX k1 a k2 b</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; MGET k1 k2</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置k2、k3的值，k2已经存在整体返回失败</span></span><br><span class="line">127.0.0.1:6379&gt; MSETNX k2 c k3 d</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>
<h3 id="2-3-Strings数值操作命令详解"><a href="#2-3-Strings数值操作命令详解" class="headerlink" title="2.3 Strings数值操作命令详解"></a>2.3 Strings数值操作命令详解</h3><h4 id="2-3-1-INCR-amp-DECR"><a href="#2-3-1-INCR-amp-DECR" class="headerlink" title="2.3.1 INCR&amp;DECR"></a>2.3.1 INCR&amp;DECR</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help incr</span><br><span class="line"></span><br><span class="line">  INCR key</span><br><span class="line">  summary: Increment the integer value of a key by one</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: string</span><br><span class="line">  </span><br><span class="line">127.0.0.1:6379&gt; help decr</span><br><span class="line"></span><br><span class="line">  DECR key</span><br><span class="line">  summary: Decrement the integer value of a key by one</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>INCR：将 key 中储存的数字值增一。</p>
<ul>
<li>如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作。</li>
<li>如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</li>
</ul>
<p>DECR：将 key 中储存的数字值减一。</p>
<ul>
<li><p>如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECR 操作。</p>
</li>
<li><p>如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</p>
</li>
</ul>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> k1原值99</span></span><br><span class="line">127.0.0.1:6379&gt; INCR k1</span><br><span class="line">(integer) 100</span><br><span class="line">127.0.0.1:6379&gt; GET k1</span><br><span class="line">&quot;100&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 不存在k6这个key</span></span><br><span class="line">127.0.0.1:6379&gt; incr k6</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get k6</span><br><span class="line">&quot;1&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> k1原值100</span></span><br><span class="line">127.0.0.1:6379&gt; DECR k1</span><br><span class="line">(integer) 99</span><br><span class="line"><span class="meta">#</span><span class="bash"> 不存在k7这个key</span></span><br><span class="line">127.0.0.1:6379&gt; DECR k7</span><br><span class="line">(integer) -1</span><br></pre></td></tr></table></figure>
<h4 id="2-3-2-INCRBY-amp-DECRBY"><a href="#2-3-2-INCRBY-amp-DECRBY" class="headerlink" title="2.3.2 INCRBY&amp;DECRBY"></a>2.3.2 INCRBY&amp;DECRBY</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help incrby</span><br><span class="line"></span><br><span class="line">  INCRBY key increment</span><br><span class="line">  summary: Increment the integer value of a key by the given amount</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: string</span><br><span class="line">  </span><br><span class="line">127.0.0.1:6379&gt; help decrby</span><br><span class="line"></span><br><span class="line">  DECRBY key decrement</span><br><span class="line">  summary: Decrement the integer value of a key by the given number</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>INCRBY：将 key 中储存的数字加上指定的增量值。</p>
<ul>
<li><p>如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCRBY 命令。</p>
</li>
<li><p>如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</p>
</li>
</ul>
<p>DECRBY：将 key 所储存的值减去指定的减量值。</p>
<ul>
<li><p>如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECRBY 操作。</p>
</li>
<li><p>如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</p>
</li>
</ul>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GET k1</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; INCRBY k1 <span class="number">10</span></span><br><span class="line">(integer) <span class="number">11</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GET k1</span><br><span class="line"><span class="string">&quot;11&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; DECRBY k1 <span class="number">10</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GET k1</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-3-3-INCRBYFLOAT"><a href="#2-3-3-INCRBYFLOAT" class="headerlink" title="2.3.3 INCRBYFLOAT"></a>2.3.3 INCRBYFLOAT</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help incrbyfloat</span><br><span class="line"></span><br><span class="line">  INCRBYFLOAT key increment</span><br><span class="line">  summary: Increment the float value of a key by the given amount</span><br><span class="line">  since: 2.6.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>INCRBYFLOAT：为 key 中所储存的值加上指定的浮点数增量值。</p>
<ul>
<li>如果 key 不存在，那么 INCRBYFLOAT 会先将 key 的值设为 0 ，再执行加法操作</li>
</ul>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GET k1</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; INCRBYFLOAT k1 1.1</span><br><span class="line">&quot;2.1&quot;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-Strings位图操作命令详解"><a href="#2-4-Strings位图操作命令详解" class="headerlink" title="2.4 Strings位图操作命令详解"></a>2.4 Strings位图操作命令详解</h3><h4 id="2-4-1-SETBIT"><a href="#2-4-1-SETBIT" class="headerlink" title="2.4.1 SETBIT"></a>2.4.1 SETBIT</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help setbit</span><br><span class="line"></span><br><span class="line">  SETBIT key offset value</span><br><span class="line">  summary: Sets or clears the bit at offset in the string value stored at key</span><br><span class="line">  since: 2.2.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</p>
<p><strong>注意：是二进制位上的偏移，非字节数组</strong></p>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 一个字节有八个二进制位，二进制的值只有0和1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将k1二进制位的第2位变为1，00000000 -&gt; 01000000</span></span><br><span class="line">127.0.0.1:6379&gt; SETBIT k1 1 1</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> k1长度为一个字节</span></span><br><span class="line">127.0.0.1:6379&gt; STRLEN k1</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 01000000在ASCII码中代表<span class="string">&#x27;@&#x27;</span></span></span><br><span class="line">127.0.0.1:6379&gt; GET k1</span><br><span class="line">&quot;@&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将k1二进制位的第8位变为1，01000000 -&gt; 01000001</span></span><br><span class="line">127.0.0.1:6379&gt; SETBIT k1 7 1</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时还没有超过8位，k1长度为1个字节</span></span><br><span class="line">127.0.0.1:6379&gt; STRLEN k1</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 01000001在ASCII码中代表<span class="string">&#x27;@&#x27;</span></span></span><br><span class="line">127.0.0.1:6379&gt; GET k1</span><br><span class="line">&quot;A&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将k1二进制位的第10位变为1，01000001 -&gt; 01000001 01000000</span></span><br><span class="line">127.0.0.1:6379&gt; SETBIT k1 9 1</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时已经超过8位，k1长度为2个字节</span></span><br><span class="line">127.0.0.1:6379&gt; STRLEN k1</span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 01000001 01000000在ASCII码中代表<span class="string">&#x27;A@&#x27;</span></span></span><br><span class="line">127.0.0.1:6379&gt; GET k1</span><br><span class="line">&quot;A@&quot;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-2-BITPOS"><a href="#2-4-2-BITPOS" class="headerlink" title="2.4.2 BITPOS"></a>2.4.2 BITPOS</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help bitpos</span><br><span class="line"></span><br><span class="line">  BITPOS key bit [start] [end]</span><br><span class="line">  summary: Find first bit set or clear in a string</span><br><span class="line">  since: 2.8.7</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>二进制位<code>1</code>在第几个字节和第几个字节之间最开始的位置</p>
<p><strong>注意：是字节，不是二进制位</strong></p>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 01000001 01000000</span></span><br><span class="line">127.0.0.1:6379&gt; GET k1</span><br><span class="line">&quot;A@&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在第一个字节中寻找二进制位为1的第一个位置，结果：下标为1的位置</span></span><br><span class="line">127.0.0.1:6379&gt; BITPOS k1 1 0 0</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在第二个字节中寻找二进制位为1的第一个位置，结果：下标为9的位置</span></span><br><span class="line">127.0.0.1:6379&gt; BITPOS k1 1 1 1</span><br><span class="line">(integer) 9</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在第一、二个字节中寻找二进制位为1的第一个位置，结果：下标为1的位置</span></span><br><span class="line">127.0.0.1:6379&gt; BITPOS k1 1 0 1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<h4 id="2-4-3-BITCOUNT"><a href="#2-4-3-BITCOUNT" class="headerlink" title="2.4.3 BITCOUNT"></a>2.4.3 BITCOUNT</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help bitcount</span><br><span class="line"></span><br><span class="line">  BITCOUNT key [start end]</span><br><span class="line">  summary: Count set bits in a string</span><br><span class="line">  since: 2.6.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>计算给定字符串中，被设置为 <code>1</code> 的比特位的数量。</p>
<ul>
<li><p>一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 <code>start</code> 或 <code>end</code> 参数，可以让计数只在特定的位上进行。</p>
</li>
<li><p>不存在的 <code>key</code> 被当成是空字符串来处理，因此对一个不存在的 <code>key</code> 进行 <code>BITCOUNT</code> 操作，结果为 <code>0</code> 。</p>
</li>
</ul>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 01000001 01000000</span></span><br><span class="line">127.0.0.1:6379&gt; GET k1</span><br><span class="line">&quot;A@&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在第一个字节中计算二进制位为1的数量，结果：2</span></span><br><span class="line">127.0.0.1:6379&gt; BITCOUNT k1 0 0</span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在第二个字节中计算二进制位为1的数量，结果：1</span></span><br><span class="line">127.0.0.1:6379&gt; BITCOUNT k1 1 1 </span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在第一、二个字节中计算二进制位为1的数量，结果：3</span></span><br><span class="line">127.0.0.1:6379&gt; BITCOUNT k1 0 1 </span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>
<h4 id="2-4-4-BITOP"><a href="#2-4-4-BITOP" class="headerlink" title="2.4.4 BITOP"></a>2.4.4 BITOP</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help bitop</span><br><span class="line"></span><br><span class="line">  BITOP operation destkey key [key ...]</span><br><span class="line">  summary: Perform bitwise operations between strings</span><br><span class="line">  since: 2.6.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>对一个或多个保存二进制位的字符串 <code>key</code> 进行位元操作，并将结果保存到 <code>destkey</code> 上。</p>
<p><code>operation</code> 可以是 <code>AND</code> 、 <code>OR</code> 、 <code>NOT</code> 、 <code>XOR</code> 这四种操作中的任意一种：</p>
<ul>
<li><code>BITOP AND destkey key [key ...]</code> ，对一个或多个 <code>key</code> 求逻辑并，并将结果保存到 <code>destkey</code> 。</li>
<li><code>BITOP OR destkey key [key ...]</code> ，对一个或多个 <code>key</code> 求逻辑或，并将结果保存到 <code>destkey</code> 。</li>
<li><code>BITOP XOR destkey key [key ...]</code> ，对一个或多个 <code>key</code> 求逻辑异或，并将结果保存到 <code>destkey</code> 。</li>
<li><code>BITOP NOT destkey key</code> ，对给定 <code>key</code> 求逻辑非，并将结果保存到 <code>destkey</code> 。</li>
</ul>
<p>除了 <code>NOT</code> 操作之外，其他操作都可以接受一个或多个 <code>key</code> 作为输入。</p>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SETBIT k1 1 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT k1 7 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;A&quot;</span><br><span class="line">127.0.0.1:6379&gt; SETBIT k2 1 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT k2 6 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">&quot;B&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 按位与计算k1、k2</span></span><br><span class="line">127.0.0.1:6379&gt; bitop and andkey k1 k2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get andkey</span><br><span class="line">&quot;@&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 按位或计算k1、k2</span></span><br><span class="line">127.0.0.1:6379&gt; bitop or orkey k1 k2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get orkey</span><br><span class="line">&quot;C&quot;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-String应用场景"><a href="#2-3-String应用场景" class="headerlink" title="2.3 String应用场景"></a>2.3 String应用场景</h2><h3 id="2-3-1-字符串"><a href="#2-3-1-字符串" class="headerlink" title="2.3.1 字符串"></a>2.3.1 字符串</h3><h3 id="2-3-2-数值"><a href="#2-3-2-数值" class="headerlink" title="2.3.2 数值"></a>2.3.2 数值</h3><h3 id="2-3-3-bitmap"><a href="#2-3-3-bitmap" class="headerlink" title="2.3.3 bitmap"></a>2.3.3 bitmap</h3><h4 id="2-3-3-1-用户系统，统计用户登陆天数，且窗口随机"><a href="#2-3-3-1-用户系统，统计用户登陆天数，且窗口随机" class="headerlink" title="2.3.3.1 用户系统，统计用户登陆天数，且窗口随机"></a>2.3.3.1 用户系统，统计用户登陆天数，且窗口随机</h4><p>公司的用户系统，统计未来用户的登陆天数，且窗口随机。比如说在电商的公司当中，统计双十一前一周和后一周用户的登陆天数。</p>
<ol>
<li><p>解决方案一：MySQL数据库</p>
<p>使用MySQL数据库，创建一张用户登录表，用户每次登录可以产生一行记录，登记登陆时间。</p>
<p>问题：</p>
<ul>
<li>关系型数据库表与表之间会有主外键或者关联，关联的 <code>id</code> 可能3、4个字节</li>
<li>成本复杂度，每张表每行需要存储一个日期，登陆时间，日期也需要至少4个字节</li>
</ul>
<p>一个用户的一笔登录就需要消耗8个字节，电商可能有几十万人，每人一年至少登陆200天，这张表的数据量可能非常大；随机窗口进行查询的时候，需要遍历所有的数据，成本非常高！</p>
</li>
<li><p>解决方案二：Redis数据库</p>
<p>成本计算，两个固定的数值，第一个固定的数值就是一年的天数，365或者366，假设一年400天，如果每一天从左向右对应一个二进制位，第一个二进制位代表第一天，第二个二进制位代表第二天，一共400个二进制位，400(位)/ 8=50(字节)，使用50个字节可以记录一个用户全年365天的登录状态。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yeyangshu第2天登录</span></span><br><span class="line">127.0.0.1:6379&gt; SETBIT yeyangshu 1 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> yeyangshu第8天登录</span></span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT yeyangshu 7 1</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> yeyangshu第365天登录</span></span><br><span class="line">127.0.0.1:6379&gt; SETBIT yeyangshu 364 1</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 计算总共占用的空间</span></span><br><span class="line">127.0.0.1:6379&gt; STRLEN yeyangshu</span><br><span class="line">(integer) 46</span><br></pre></td></tr></table></figure>
<p>统计最后两周用户登录的天数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 统计最后两周yeyangshu登陆天数</span></span><br><span class="line">127.0.0.1:6379&gt; BITCOUNT yeyangshu -2 -1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<p>优点：CPU对二进制位的计算速度是最快的，关系型数据库需要从磁盘读取文件，第一个会产生IO，第二个读取磁盘之后，需要将数据解码再参与计算，而且不是二进制位的计算</p>
</li>
</ol>
<h4 id="2-3-3-2-电商做活动，该准备多少礼物"><a href="#2-3-3-2-电商做活动，该准备多少礼物" class="headerlink" title="2.3.3.2 电商做活动，该准备多少礼物"></a>2.3.3.2 电商做活动，该准备多少礼物</h4><p>电商做活动，当天登陆就送礼物，准备多少礼物？假设电商有2亿用户，活动当天登录送礼物，每个人只能送一件，请问库存需要准备多少礼物？</p>
<p>电商里面有一个基本常识，用户分为僵尸用户、冷热用户（忠诚用户）。</p>
<p>过往一年中或同比去年的时间范围内或上一个月窗口内，网站有1亿活跃用户或100万活跃用户经常登录，其实根本不是2亿用户，所以最终的目标是活跃用户。</p>
<p>这也是需要经常做的一个统计：活跃用户统计。活跃用户统计的本质是什么？比如说1号到3号，1号里面有多少人，2号里面有多少人并且还需要去重，如何去设计？</p>
<p>需求综上：活跃用户统计，随机窗口，连续登录并且去重。</p>
<p>Redis做法</p>
<p>日期作为key，20200101，用户id映射到二进制位上。假设小明的id是10，小李的id是1000，二进制位1代表登录，二进制位0代表未登录，假设第一天只有小明登录了，<code>setbit 20200101 10 1</code>，第二天小明和小李都登陆了，<code>setbit 20200102 1000 1</code>，计算1号和2号的活跃用户。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> SETBIT date OFFSET id</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1号小明登录</span></span><br><span class="line">127.0.0.1:6379&gt; SETBIT 20200101 10 1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2号小明登录</span></span><br><span class="line">127.0.0.1:6379&gt; SETBIT 20200102 10 1</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2号小李登录</span></span><br><span class="line">127.0.0.1:6379&gt; SETBIT 20200102 1000 1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或运算，参加运算的两个对象，一个为1，其值为1，目的是统计这两天的登录人数</span></span><br><span class="line">127.0.0.1:6379&gt; BITOP or destkey 20200101 20200102</span><br><span class="line">(integer) 126</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> BITCOUNT计算出活跃人数</span></span><br><span class="line">127.0.0.1:6379&gt; BITCOUNT destkey 0 -1</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
</search>
