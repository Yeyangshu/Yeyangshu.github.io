<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JVM class文件结构</title>
    <url>/2020/12/28/JVM-class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="class-文件结构"><a href="#class-文件结构" class="headerlink" title="class 文件结构"></a>class 文件结构</h1><a id="more"></a>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 类加载过程</title>
    <url>/2020/12/28/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><a id="more"></a>

<p>一个java文件从编码到最终运行，一般主要包括两个过程：</p>
<ul>
<li>编译：将写好的 .java 文件，通过 javac 命令编译成字节码，也就是 .class（二进制字节流） 文件。</li>
<li>运行：JVM 把编译生成好的 .class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型的过程叫做虚拟机的类加载机制。</li>
</ul>
<p>与其他语言不同，Java 类型的加载、连接和初始化是在程序运行期间完成的。</p>
<p>类加载的过程主要分为三个部分：</p>
<ul>
<li><p>加载</p>
</li>
<li><p>链接</p>
<p>而链接又可以细分为三个小部分：</p>
<ul>
<li>验证</li>
<li>准备</li>
<li>解析</li>
</ul>
</li>
<li><p>初始化</p>
</li>
</ul>
<h2 id="1-加载"><a href="#1-加载" class="headerlink" title="1 加载"></a>1 加载</h2><p>简单来说，加载指的是把 class 文件从各个来源通过类加载器加载到内存中。</p>
<p>在加载阶段，Java 虚拟机需要完成下面三件事情：</p>
<ol>
<li><p>通过一个类的全限定名来获取定义此类的二进制字节流。</p>
<ul>
<li>可以从ZIP</li>
<li>网络</li>
<li>数据库</li>
<li>其他文件生成</li>
<li>加密文件中获取</li>
</ul>
<p>Java 虚拟机并没有规定二进制字节流必须从 Class 文件中获取。</p>
</li>
<li><p>将这个字节流所代表的的静态存储结构转化为方法区的运行时数结构。</p>
</li>
<li><p>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</p>
<blockquote>
<p>什么是 Class 类？在 Java 中每个类都有一个相对应的 Class 类的对象，用于表示这个类的类型信息。</p>
</blockquote>
</li>
<li></li>
</ol>
<h2 id="2-连接"><a href="#2-连接" class="headerlink" title="2 连接"></a>2 连接</h2><h3 id="2-1-验证"><a href="#2-1-验证" class="headerlink" title="2.1 验证"></a>2.1 验证</h3><p>这一步的目的是确保 Class 文件的字节流中包含的信息是否符合《Java虚拟机规范》的全部元数要求，保证这些信息被当做运行代码不会危害虚拟机自身的安全。</p>
<ol>
<li><p>文件格式验证</p>
<ul>
<li><p>行为：验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理。</p>
</li>
<li><p>目的：该阶段的主要目的是保证输入的字节流能正确的解析并存储于方法区之内，后面的 3 个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。</p>
</li>
</ul>
</li>
<li><p>元数据验证</p>
<ul>
<li>行为：对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求。</li>
<li>目的：对类的元数据信息进行语义校验，保证不存在不符合 Java 语言规范的元数据信息。</li>
</ul>
</li>
<li><p>字节码验证</p>
<ul>
<li>目的：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。对类的方法体进行校验分析，保证被校验类在运行时不会做出危害虚拟机安全的事件。</li>
</ul>
</li>
<li><p>符号引用验证</p>
<ul>
<li>行为：符合引用可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。</li>
<li>目的：确保解析动作能正常执行。</li>
</ul>
</li>
</ol>
<h3 id="2-2-准备"><a href="#2-2-准备" class="headerlink" title="2.2 准备"></a>2.2 准备</h3><p>正式为<strong>类中定义的变量</strong>分配内存并设置类变量的<strong>初始值</strong>的阶段，这些变量所使用的内存都将在方法区中进行分配。</p>
<p>注意：</p>
<ol>
<li><p>这个时候进行内存分配的仅包括类变量（被 static 修饰的变量），并不包括实例变量。</p>
</li>
<li><p>初始值“通常情况”下是数据类型的零值。</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">零值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">oL</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">(short)0</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">‘\u0000’</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">(byte)0</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">0.0f</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">0.0d</td>
</tr>
<tr>
<td align="center">refrence</td>
<td align="center">null</td>
</tr>
</tbody></table>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>value 在准备期间就赋值为 0。</p>
<p>如果是常量的话，直接赋值为常量指定的值。</p>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>value 在准备期间就赋值为 123。</p>
</li>
</ol>
<h3 id="2-3-解析"><a href="#2-3-解析" class="headerlink" title="2.3 解析"></a>2.3 解析</h3><p>Java 虚拟机将常量池内的符号引用替换为直接引用的过程</p>
<h2 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3 初始化"></a>3 初始化</h2><p>调用类的初始化代码，给成员变量赋初始值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类初始化和静态变量初始化测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T_ClassLoadingProduce</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(T.count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 情景一</span></span><br><span class="line"><span class="comment">     * public static int count = 2;</span></span><br><span class="line"><span class="comment">     * public static T t = new T();</span></span><br><span class="line"><span class="comment">     * 结果：3</span></span><br><span class="line"><span class="comment">     * 分析：</span></span><br><span class="line"><span class="comment">     * 当调用T时，先把T Class load内存进行校验，然后进行preparation赋默认值，此时T是空值，</span></span><br><span class="line"><span class="comment">     * 然后Resolution，在进行initializing初始化赋初始值，这个时候是2，然后count++，输出3</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 情景二</span></span><br><span class="line"><span class="comment">     * public static T t = new T();</span></span><br><span class="line"><span class="comment">     * public static int count = 2;</span></span><br><span class="line"><span class="comment">     * 结果：2</span></span><br><span class="line"><span class="comment">     * 分析：</span></span><br><span class="line"><span class="comment">     * 当调用T时，先把T Class load内存进行校验，然后进行preparation赋默认值，此时T是空值，</span></span><br><span class="line"><span class="comment">     * 然后Resolution，在进行initializing初始化赋初始值，先调用new T这个时候是0，然后count++变成一，然后赋值输出结果为2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始值null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T t = <span class="keyword">new</span> T();</span><br><span class="line">    <span class="comment">// 初始值0</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">T</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 虚拟机基础概念</title>
    <url>/2020/12/28/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="虚拟机基础概念"><a href="#虚拟机基础概念" class="headerlink" title="虚拟机基础概念"></a>虚拟机基础概念</h1><a id="more"></a>

<h2 id="1-什么是虚拟机"><a href="#1-什么是虚拟机" class="headerlink" title="1 什么是虚拟机"></a>1 什么是虚拟机</h2><p>百度百科：虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java 虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java 虚拟机屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在 Java 虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</p>
<h2 id="2-流行的-Java-虚拟机"><a href="#2-流行的-Java-虚拟机" class="headerlink" title="2 流行的 Java 虚拟机"></a>2 流行的 Java 虚拟机</h2><ul>
<li><p>Hotspot</p>
<p>Oracle 官方虚拟机</p>
</li>
<li><p>JRockit</p>
</li>
<li><p> J9</p>
</li>
<li><p>Microsoft VM</p>
</li>
<li><p>Liquid VM</p>
</li>
<li><p>Taobao VM</p>
</li>
</ul>
<h2 id="3-JDK、JRE、JVM"><a href="#3-JDK、JRE、JVM" class="headerlink" title="3 JDK、JRE、JVM"></a>3 JDK、JRE、JVM</h2><ul>
<li>JVM：</li>
<li>JRE = JVM + core libraries</li>
<li>JDK = JRE + Development Kit</li>
</ul>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201228215823470.png" alt="image-20201228215823470"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java NIO Channel</title>
    <url>/2020/12/24/Java-NIO-Channel/</url>
    <content><![CDATA[<h1 id="Java-NIO-Channel"><a href="#Java-NIO-Channel" class="headerlink" title="Java NIO Channel"></a>Java NIO Channel</h1><p><code>Java NIO Channels</code> 类似于流，但有一些区别：</p>
<ul>
<li>可以从通道中读取数据或写入数据到通道中。流通常是单向的（读或写）。</li>
<li>通道可以异步读写。</li>
<li>通道的数据总是被读取到缓冲区中或将缓冲区中数据写入到通道。<a id="more"></a>
如上所述，将数据从通道读取到缓冲区中，然后将数据从缓冲区写入通道中。这是一个说明：</li>
</ul>
<p><img src="http://tutorials.jenkov.com/images/java-nio/overview-channels-buffers.png" alt="Java NIO：通道和缓冲区"></p>
<h2 id="1-Channel-实现"><a href="#1-Channel-实现" class="headerlink" title="1 Channel 实现"></a>1 Channel 实现</h2><p>以下是 Java NIO 中最重要的 Channel 实现：</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p><code>FileChannel</code>从文件中读取和写入数据。</p>
<p><code>DatagramChannel</code>可以通过 UDP 读取和写入网络数据。</p>
<p><code>SocketChannel</code>可以通过 TCP 读取和写入网络数据。</p>
<p><code>ServerSocketChannel</code> 可以监听新的 TCP 连接，像 Web 服务器一样，为每个新的 TCP 连接创建一个<code>SocketChannel</code>。</p>
<h2 id="2-Channel-简单示例"><a href="#2-Channel-简单示例" class="headerlink" title="2 Channel 简单示例"></a>2 Channel 简单示例</h2><p>这是一个简单示例，该示例使用 <code>FileChannel</code> 将一些数据读取到 <code>Buffer</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RandomAccessFile accessFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;data/nio-data.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">FileChannel inChannel = accessFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">// create buffer with capacity 48 bytes.</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// read into buffer</span></span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buffer);</span><br><span class="line"><span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Read &quot;</span> + bytesRead);</span><br><span class="line">    <span class="comment">// make buffer ready for read.</span></span><br><span class="line">    buffer.flip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">        <span class="comment">// read 1 byte at a time.</span></span><br><span class="line">        System.out.println((<span class="keyword">char</span>) buffer.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make buffer ready for writing.</span></span><br><span class="line">    buffer.clear();</span><br><span class="line">    bytesRead = inChannel.read(buffer);</span><br><span class="line">&#125;</span><br><span class="line">accessFile.close();</span><br></pre></td></tr></table></figure>
<p>注意 <code>buf.flip()</code> 的调用。首先，读入数据到缓冲区，然后反转 Buffer，再从 Buffer 中读取数据。在下一节有关 <code>Buffer</code> 的文档中，将对此进行详细的说明。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java NIO 教程</title>
    <url>/2020/12/24/Java-NIO-%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Java-NIO-教程"><a href="#Java-NIO-教程" class="headerlink" title="Java NIO 教程"></a>Java NIO 教程</h1><p>本系列教程翻译自 Jakob Jenkov 的文章，原文链接：<a href="http://tutorials.jenkov.com/java-nio/index.html">http://tutorials.jenkov.com/java-nio/index.html</a></p>
<a id="more"></a>
<p>Java NIO（New IO）是 Java IO API 的替代品，意味着可以替代标准 Java IO 和 Java Networking API。 Java NIO 提供了与传统 IO API 不同的 IO 编程模型。 注意：有时 NIO 被称为是非阻塞 IO。 但是，这并不是 NIO 最初的意思。 另外，NIO API 的某些部分实际上是阻塞的，例如：文件 API，因此，“非阻塞”标签可能会引起误导。</p>
<h2 id="1-Java-NIO-Non-blocking-IO（非阻塞-IO）"><a href="#1-Java-NIO-Non-blocking-IO（非阻塞-IO）" class="headerlink" title="1 Java NIO: Non-blocking IO（非阻塞 IO）"></a>1 Java NIO: Non-blocking IO（非阻塞 IO）</h2><p>Java NIO 使您可以使用非阻塞 IO。 例如，线程可以要求通道将数据读入缓冲区，当通道将数据读入缓冲区时，线程可以执行其他操作。 一旦将数据读入缓冲区，线程就可以继续对其进行处理。 将数据写入通道时也是如此。</p>
<h2 id="2-Java-NIO-Channels-and-Buffers（通道和缓冲区）"><a href="#2-Java-NIO-Channels-and-Buffers（通道和缓冲区）" class="headerlink" title="2 Java NIO: Channels and Buffers（通道和缓冲区）"></a>2 Java NIO: Channels and Buffers（通道和缓冲区）</h2><p>标准的 IO 基于字节流和字符流进行操作的，而 NIO 是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。</p>
<h2 id="3-Java-NIO-Selectors（选择器）"><a href="#3-Java-NIO-Selectors（选择器）" class="headerlink" title="3 Java NIO: Selectors（选择器）"></a>3 Java NIO: Selectors（选择器）</h2><p>Java NIO包含“选择器”的概念。 选择器是一个对象，可以监视多个通道的事件（例如：打开连接，到达数据等）。 因此，单个线程可以监视多个通道以获取数据。</p>
<h2 id="4-Java-NIO-Concepts"><a href="#4-Java-NIO-Concepts" class="headerlink" title="4 Java NIO Concepts"></a>4 Java NIO Concepts</h2><p>与旧的 Java IO 模型相比，在 Java NIO 中需要学习几个新概念。 这些概念在下面列出：</p>
<ul>
<li><a href="http://tutorials.jenkov.com/java-nio/channels.html">Channels</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/buffers.html">Buffers</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/scatter-gather.html">Scatter - Gather</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/channel-to-channel-transfers.html">Channel to Channel Transfers</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/selectors.html">Selectors</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/file-channel.html">FileChannel</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/socketchannel.html">SocketChannel</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/server-socket-channel.html">ServerSocketChannel</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/non-blocking-server.html">Non-blocking Server Design</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/datagram-channel.html">DatagramChannel</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/pipe.html">Pipe</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/nio-vs-io.html">NIO vs. IO</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/path.html">Path</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/files.html">Files</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/asynchronousfilechannel.html">AsynchronousFileChannel</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java NIO 概述</title>
    <url>/2020/12/24/Java-NIO-%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="Java-NIO-概述"><a href="#Java-NIO-概述" class="headerlink" title="Java NIO 概述"></a>Java NIO 概述</h1><p>原文链接：<a href="http://tutorials.jenkov.com/java-nio/overview.html">http://tutorials.jenkov.com/java-nio/overview.html</a></p>
<a id="more"></a>
<p>Java NIO 由以下核心组件组成：</p>
<ul>
<li>通道</li>
<li>缓冲区</li>
<li>选择器</li>
</ul>
<p>Java NIO 拥有比这些更多的类和组件，但在我看来 <code>Channel</code>，<code>Buffer</code>  和 <code>Selector</code>构成了 API 的核心。其余组件，例如  <code>Pipe</code> 和 <code>FileLock</code> 仅仅是与三个核心组件结合使用的实用程序类。因此，在本 NIO 概述中，我将重点介绍这三个组件。其他组件在本教程的其他地方以其自己的文本进行了说明。</p>
<h2 id="1-通道（Channel）和缓冲区（Buffer）"><a href="#1-通道（Channel）和缓冲区（Buffer）" class="headerlink" title="1 通道（Channel）和缓冲区（Buffer）"></a>1 通道（Channel）和缓冲区（Buffer）</h2><p>通常，NIO 中的所有 IO 都从一个 <code>Channel</code> 开始。<code>Channel</code>有点像流。<code>Channel</code> 中的数据可以读入到一个<code>Buffer</code>。数据也可以从一个<code>Buffer</code>写入到<code>Channel</code>。如下图所示：</p>
<p><img src="http://tutorials.jenkov.com/images/java-nio/overview-channels-buffers.png" alt="Java NIO：通道和缓冲区"></p>
<p>Java NIO：通道将数据读取到缓冲区中，缓冲区将数据写入通道中</p>
<p>Java中有几种<code>Channel</code>和<code>Buffer</code>类型。这是<code>Channel</code>Java NIO中主要实现的列表：</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p>如您所见，这些通道涵盖 UDP + TCP 网络 IO 和文件 IO。</p>
<p>这些类也有一些有趣的接口，但是为了简单起见，我将它们排除在 Java NIO 概述之外。在本 Java NIO 教程的其他文本中将对它们进行解释。</p>
<p>这是 Java NIO 中 <code>Buffer</code> 的关键的实现：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>这些 <code>Buffer</code> 包括了您可以通过 IO 发送的基本数据类型：byte, short, int, long, float, double 和 char。</p>
<p>Java NIO 还有与内存映射文件结合使用的 <code>MappedByteBuffer</code> ，不过，不在 <code>Buffer</code>  概述中说明。</p>
<h2 id="2-选择器（Selectors）"><a href="#2-选择器（Selectors）" class="headerlink" title="2 选择器（Selectors）"></a>2 选择器（Selectors）</h2><p><code>Selector</code> 允许单线程处理多个 <code>Channel</code>。如果您的应用程序打开了很多个连接（通道），但每个连接的流量很少，使用 <code>Selector</code> 就会很方便。例如，在聊天服务器中。</p>
<p>这是使用一个 <code>Selector</code> 来处理 3 个 <code>Channel</code> 的示意图：</p>
<p><img src="http://tutorials.jenkov.com/images/java-nio/overview-selectors.png" alt="Java NIO：选择器"></p>
<p>要想使用 <code>Selector</code>，需要向 <code>Selector</code> 注册 <code>Channel</code>，然后，调用  <code>select()</code> 方法。该方法会一直阻塞，直到有一个已注册通道有事件准备就绪。方法返回后，线程就会处理这些事件。事件可以是传入连接，接收到的数据等。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis Hash mapping</title>
    <url>/2020/12/27/Redis-Hash-mapping/</url>
    <content><![CDATA[<h1 id="Redis-Hash-映射"><a href="#Redis-Hash-映射" class="headerlink" title="Redis Hash 映射"></a>Redis Hash 映射</h1><a id="more"></a>

<p>Redis 序列化器文章中讲到对象可以序列化为 Json 格式，也可以将对象转换为 Hash 键值对的形式。</p>
<p>Spring Data Redis提供了各种将数据映射到 Hash 的策略：</p>
<ul>
<li>使用<code>HashOperations</code>和 serializer 直接映射</li>
<li>使用 Redis Repositories</li>
<li>使用 <code>HashMapper</code> 和 <code>HashOperations</code></li>
</ul>
<h2 id="1-Hash-Mappers"><a href="#1-Hash-Mappers" class="headerlink" title="1 Hash Mappers"></a>1 Hash Mappers</h2><p>Hash Mappers 是将对象映射到 <code>Map&lt;K, V&gt;</code> 的转换器。<code>HashMapper </code> 适用于 Redis Hashes 类型。</p>
<p>Hash Mappers 有多种实现：</p>
<ul>
<li>BeanUtilsHashMapper ：使用 Spring 的 <a href="https://docs.spring.io/spring/docs/5.3.2/javadoc-api/org/springframework/beans/BeanUtils.html">BeanUtils</a>。</li>
<li>ObjectHashMapper：使用 <a href="https://docs.spring.io/spring-data/redis/docs/2.4.2/reference/html/#redis.repositories.mapping">Object-to-Hash Mapping</a>。</li>
<li>Jackson2HashMapper：使用 <a href="https://github.com/FasterXML/jackson">FasterXML Jackson</a>。</li>
</ul>
<h2 id="2-Jackson2HashMapper-案例"><a href="#2-Jackson2HashMapper-案例" class="headerlink" title="2 Jackson2HashMapper 案例"></a>2 Jackson2HashMapper 案例</h2><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jackson2HashMapperTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Person yeyangshu = <span class="keyword">new</span> Person();</span><br><span class="line">        yeyangshu.setName(<span class="string">&quot;yeyangshu&quot;</span>);</span><br><span class="line">        yeyangshu.setAge(<span class="number">20</span>);</span><br><span class="line">        Address address = <span class="keyword">new</span> Address();</span><br><span class="line">        address.setCountry(<span class="string">&quot;china&quot;</span>);</span><br><span class="line">        address.setCity(<span class="string">&quot;Shanghai&quot;</span>);</span><br><span class="line">        yeyangshu.setAddress(address);</span><br><span class="line">        </span><br><span class="line">        stringRedisTemplate.setHashValueSerializer(<span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(Object.class));</span><br><span class="line">        HashOperations hashOperations = stringRedisTemplate.opsForHash();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1 将对象转换为键值对</span></span><br><span class="line">        Jackson2HashMapper jackson2HashMapper = <span class="keyword">new</span> Jackson2HashMapper(objectMapper, <span class="keyword">false</span>);</span><br><span class="line">        Map&lt;String, Object&gt; objectToHash = jackson2HashMapper.toHash(yeyangshu);</span><br><span class="line">        hashOperations.putAll(<span class="string">&quot;yeyangshu&quot;</span>, objectToHash);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2 将键值对转换为对象</span></span><br><span class="line">        Map map = hashOperations.entries(<span class="string">&quot;yeyangshu&quot;</span>);</span><br><span class="line">        Person person = objectMapper.convertValue(map, Person.class);</span><br><span class="line">        System.out.println(person.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 value 是对象，为了能正常显示，还涉及到序列化的问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stringRedisTemplate.setHashValueSerializer(<span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(Object.class));</span><br></pre></td></tr></table></figure>
<p>RedisTemplate 提供的序列化的方法：</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201227095630172.png" alt="image-20201227095630172"></p>
<p>控制台打印：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Person&#123;name=&#x27;yeyangshu&#x27;, age=20, address=Address&#123;city=&#x27;Shanghai&#x27;, country=&#x27;china&#x27;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p><code>redis-cli</code> 查看：</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201227103958851.png" alt="image-20201227103958851"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 主从复制</title>
    <url>/2020/12/27/Redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h1 id="Redis-主从复制"><a href="#Redis-主从复制" class="headerlink" title="Redis 主从复制"></a>Redis 主从复制</h1><a id="more"></a>

<h2 id="1-主从复制配置和演示"><a href="#1-主从复制配置和演示" class="headerlink" title="1 主从复制配置和演示"></a>1 主从复制配置和演示</h2><h3 id="1-1-手动演示"><a href="#1-1-手动演示" class="headerlink" title="1.1 手动演示"></a>1.1 手动演示</h3><h4 id="1-1-1-准备工作"><a href="#1-1-1-准备工作" class="headerlink" title="1.1.1 准备工作"></a>1.1.1 准备工作</h4><p>一台机器开三个实例，更改配置文件关闭后台运行</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主机和从机都设置一下日志</span></span><br><span class="line"><span class="comment"># 关闭后台运行</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">no</span></span><br><span class="line"><span class="comment"># 关闭日志文件，实时打印日志</span></span><br><span class="line"><span class="comment">#logfile /var/log/redis_6379.log</span></span><br><span class="line"><span class="comment"># 关掉AOF日志</span></span><br><span class="line"><span class="attr">appendonly</span> <span class="string">no</span></span><br><span class="line"><span class="comment"># 效果：Redis实例前台阻塞运行，没有AOF日志</span></span><br></pre></td></tr></table></figure>
<p>进入test文件夹，启动redis</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-server .&#x2F;6379.conf</span><br><span class="line">redis-server .&#x2F;6380.conf</span><br><span class="line">redis-server .&#x2F;6381.conf</span><br></pre></td></tr></table></figure>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200721224518202.png" alt="image-20200721224518202"></p>
<p>现在已经有了三台实例，此时希望 6379 作为主机</p>
<h4 id="1-1-2-手动复制"><a href="#1-1-2-手动复制" class="headerlink" title="1.1.2 手动复制"></a>1.1.2 手动复制</h4><p>从机复制命令</p>
<ul>
<li>5.0 以前：SLAVEOF</li>
<li>5.0 以后：REPLICAIF</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">help</span> <span class="string">SLAVEOF</span></span><br></pre></td></tr></table></figure>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200721225251413.png" alt="image-20200721225251413"></p>
<p>6380 机器连接 6379</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slaveof 192.168.1.1 6379</span><br></pre></td></tr></table></figure>
<p>6379 机器日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6629:M 13 Jul 2020 15:37:10.256 * Replica 127.0.0.1:6380 asks for synchronization</span><br><span class="line">6629:M 13 Jul 2020 15:37:10.256 * Partial resynchronization not accepted: Replication ID mismatch (Replica asked for &#39;753f1f7659bb7ff017cc7c9e1c1ef0bb23eee769&#39;, my replication IDs are &#39;ce4485f2cc7f71534865b54ca649a7833b7c71a5&#39; and &#39;0000000000000000000000000000000000000000&#39;)</span><br><span class="line">6629:M 13 Jul 2020 15:37:10.256 * Starting BGSAVE for SYNC with target: disk</span><br><span class="line">6629:M 13 Jul 2020 15:37:10.292 * Background saving started by pid 6748</span><br><span class="line">6748:C 13 Jul 2020 15:37:10.302 * DB saved on disk</span><br><span class="line">6748:C 13 Jul 2020 15:37:10.303 * RDB: 4 MB of memory used by copy-on-write</span><br><span class="line">6629:M 13 Jul 2020 15:37:10.355 * Background saving terminated with success</span><br><span class="line">6629:M 13 Jul 2020 15:37:10.355 * Synchronization with replica 127.0.0.1:6380 succeeded</span><br></pre></td></tr></table></figure>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200721231737542.png" alt="image-20200721231737542"></p>
<p>6380 机器日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6669:S 13 Jul 2020 15:37:09.547 * Before turning into a replica, using my master parameters to synthesize a cached master: I may be able to synchronize with the new master with just a partial transfer.</span><br><span class="line">6669:S 13 Jul 2020 15:37:09.547 * REPLICAOF 127.0.0.1:6379 enabled (user request from &#39;id&#x3D;3 addr&#x3D;127.0.0.1:52883 fd&#x3D;7 name&#x3D; age&#x3D;1580 idle&#x3D;0 flags&#x3D;N db&#x3D;0 sub&#x3D;0 psub&#x3D;0 multi&#x3D;-1 qbuf&#x3D;44 qbuf-free&#x3D;32724 obl&#x3D;0 oll&#x3D;0 omem&#x3D;0 events&#x3D;r cmd&#x3D;replicaof&#39;)</span><br><span class="line">6669:S 13 Jul 2020 15:37:10.254 * Connecting to MASTER 127.0.0.1:6379</span><br><span class="line">6669:S 13 Jul 2020 15:37:10.256 * MASTER &lt;-&gt; REPLICA sync started</span><br><span class="line">6669:S 13 Jul 2020 15:37:10.256 * Non blocking connect for SYNC fired the event.</span><br><span class="line">6669:S 13 Jul 2020 15:37:10.256 * Master replied to PING, replication can continue...</span><br><span class="line">6669:S 13 Jul 2020 15:37:10.256 * Trying a partial resynchronization (request 753f1f7659bb7ff017cc7c9e1c1ef0bb23eee769:1).</span><br><span class="line">6669:S 13 Jul 2020 15:37:10.317 * Full resync from master: 6f76be684c7924f28999c4a24b6f212002285eff:0</span><br><span class="line">6669:S 13 Jul 2020 15:37:10.317 * Discarding previously cached master state.</span><br><span class="line">6669:S 13 Jul 2020 15:37:10.355 * MASTER &lt;-&gt; REPLICA sync: receiving 175 bytes from master</span><br><span class="line">&#x2F;&#x2F; 清除老数据</span><br><span class="line">6669:S 13 Jul 2020 15:37:10.355 * MASTER &lt;-&gt; REPLICA sync: Flushing old data</span><br><span class="line">6669:S 13 Jul 2020 15:37:10.355 * MASTER &lt;-&gt; REPLICA sync: Loading DB in memory</span><br><span class="line">6669:S 13 Jul 2020 15:37:10.355 * MASTER &lt;-&gt; REPLICA sync: Finished with success</span><br></pre></td></tr></table></figure>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200721231941240.png" alt="image-20200721231941240"></p>
<p>6379 插入数据 k1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set k1 123</span><br></pre></td></tr></table></figure>
<p>6380 可以查询此数据，但是 6380 不可以新增</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6380&gt; get k1</span><br><span class="line">&quot;123&quot;</span><br><span class="line">127.0.0.1:6380&gt; set k2 123</span><br><span class="line">(error) READONLY You can&#39;t write against a read only replica.</span><br></pre></td></tr></table></figure>
<p>如果slave不想追随主机</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REPLICAOF no one</span><br></pre></td></tr></table></figure>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200721233951199.png" alt="image-20200721233951199"></p>
<h3 id="1-2-配置文件"><a href="#1-2-配置文件" class="headerlink" title="1.2 配置文件"></a>1.2 配置文件</h3><p>查看 6379.conf</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200721235844532.png" alt="image-20200721235844532"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 机器</span><br><span class="line">replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line">&#x2F;&#x2F; 密码</span><br><span class="line">masterauth &lt;master-password&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置成yes，主从复制中，从服务器可以响应客户端请求;设置成no，主从复制中，从服务器将阻塞所有请求，有客户端请求时返回“SYNC with master in progress”</span><br><span class="line">replica-serve-stale-data yes</span><br><span class="line"></span><br><span class="line">replica-read-only yes</span><br><span class="line">repl-diskless-sync no</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 事务</title>
    <url>/2020/12/27/Redis-%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h1><p>将一组命令放在同一个事务中进行处理</p>
<a id="more"></a>

<h2 id="1-事务简介"><a href="#1-事务简介" class="headerlink" title="1 事务简介"></a>1 事务简介</h2><p>MULTI、EXEC、DISCARD和WATCH是Redis食物相关的命令。事务可以一次执行多个命令，并且带有以下两个重要保证：</p>
<ul>
<li><p>事务是一个单独的隔离操作</p>
<p>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
</li>
<li><p>事务是一个原子操作</p>
<p>事务中的所有命令要么全部被执行，要么全部都不执行。</p>
</li>
</ul>
<p>EXEC 命令负责触发并执行事务中的所有的命令</p>
<ul>
<li>如果客户端在使用 MULTI 开启了一个事物，却因为断线而没有成功执行 EXEC，那么事务中的所有命令都不会被执行。</li>
<li>如果客户端成功在开启事务之后执行 EXEC，那么事务中的所有命令都会被执行。</li>
</ul>
<h2 id="2-事务使用"><a href="#2-事务使用" class="headerlink" title="2 事务使用"></a>2 事务使用</h2><h3 id="2-1-help-transactions"><a href="#2-1-help-transactions" class="headerlink" title="2.1 help @transactions"></a>2.1 help @transactions</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @transactions</span><br><span class="line"></span><br><span class="line">  DISCARD -</span><br><span class="line">  summary: Discard all commands issued after MULTI</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  EXEC -</span><br><span class="line">  summary: Execute all commands issued after MULTI</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  MULTI -</span><br><span class="line">  summary: Mark the start of a transaction block</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  UNWATCH -</span><br><span class="line">  summary: Forget about all watched keys</span><br><span class="line">  since: 2.2.0</span><br><span class="line"></span><br><span class="line">  WATCH key [key ...]</span><br><span class="line">  summary: Watch the given keys to determine execution of the MULTI&#x2F;EXEC block</span><br><span class="line">  since: 2.2.0</span><br></pre></td></tr></table></figure>
<p>MULTI：标记一个事务块的开始。 随后的指令将在执行 EXEC 时作为一个原子执行。</p>
<ul>
<li>返回值：始终为OK</li>
</ul>
<p>EXEC：执行事务中所有在排队等待的指令并将链接状态恢复到正常，当使用 WATCH 时，只有当被监视的键没有被修改，且允许检查设定机制时，EXEC会被执行。</p>
<ul>
<li>返回值：每个元素与原子事务中的指令一一对应 当使用 WATCH 时，如果被终止，EXEC 则返回一个空的应答集合</li>
</ul>
<p>DISCARD：刷新一个事务中所有在排队等待的指令，并且将连接状态恢复到正常。如果已使用WATCH，DISCARD将释放所有被 WATCH 的 key。</p>
<ul>
<li>返回值：所有返回都是 OK</li>
</ul>
<p>WATCH：标记所有指定的 key 被监视起来，在事务中有条件的执行（乐观锁）。</p>
<ul>
<li>返回值：始终为 OK</li>
</ul>
<h3 id="2-2-事务用法"><a href="#2-2-事务用法" class="headerlink" title="2.2 事务用法"></a>2.2 事务用法</h3><h4 id="2-2-1-开启并执行事务"><a href="#2-2-1-开启并执行事务" class="headerlink" title="2.2.1 开启并执行事务"></a>2.2.1 开启并执行事务</h4><p>MULTI 用于开启一个事务，它总是返回 <code>OK</code>，MULTI 执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即执行，而是被放在一个队列中，当 EXEC 命令被调用时，所有队列中的命令才会被执行。</p>
<p>一个事务</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; MULTI </span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; <span class="built_in">SET</span> k1 aaa</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> k2 bbb</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; EXEC</span><br><span class="line"><span class="number">1</span>) OK</span><br><span class="line"><span class="number">2</span>) OK</span><br></pre></td></tr></table></figure>
<p>两个客户端两个事物不同顺序</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># client1:</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get k1</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="comment"># client2:</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; <span class="built_in">DEL</span> k1</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; EXEC</span><br><span class="line"><span class="number">1</span>) (integer) <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># client1:</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; EXEC</span><br><span class="line"><span class="number">1</span>) (nil)</span><br></pre></td></tr></table></figure>
<h4 id="2-2-2-放弃事务"><a href="#2-2-2-放弃事务" class="headerlink" title="2.2.2 放弃事务"></a>2.2.2 放弃事务</h4><p>当执行 DISCARD 命令时， 事务会被放弃， 事务队列会被清空， 并且客户端会从事务状态中退出</p>
<h4 id="2-2-3-WATCH，使用-check-and-set-操作实现乐观锁"><a href="#2-2-3-WATCH，使用-check-and-set-操作实现乐观锁" class="headerlink" title="2.2.3 WATCH，使用 check-and-set 操作实现乐观锁"></a>2.2.3 WATCH，使用 check-and-set 操作实现乐观锁</h4><p>WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。</p>
<p>被 WATCH  的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回 nil 来表示事务已经失败。</p>
<p>测试：</p>
<p>同时开启两个Redis客户端，client1和client2，数据库中存在k1:abc，client1 WATCH k1，先开始事务后执行，client2后开启事务先执行</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># client1开启事务不执行</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; KEYS *</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;k1&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; WATCH k1</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GET k1</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; KEYS *</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="comment"># client2开启事务并执行，此时k1值被更改</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; KEYS *</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; <span class="built_in">SET</span> k1 def</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; EXEC</span><br><span class="line"><span class="number">1</span>) <span class="number">1</span>) <span class="string">&quot;k1&quot;</span></span><br><span class="line"><span class="number">2</span>) OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GET k1</span><br><span class="line"><span class="string">&quot;def&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># client1执行事务返回nil，证明k1事务执行失败</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; EXEC</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Transactions</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 使用LRU算法做缓存使用</title>
    <url>/2020/12/27/Redis-%E4%BD%BF%E7%94%A8LRU%E7%AE%97%E6%B3%95%E5%81%9A%E7%BC%93%E5%AD%98%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Redis-作为缓存使用"><a href="#Redis-作为缓存使用" class="headerlink" title="Redis 作为缓存使用"></a>Redis 作为缓存使用</h1><a id="more"></a>

<p>使用 Redis 做缓存，当你新增数据时，让 Redis 自动地回收旧数据是件很方便的事情。</p>
<p>Redis 回收数据分为两种情况：</p>
<ul>
<li>内存回收</li>
<li>key 过期删除</li>
</ul>
<h2 id="1-内存回收"><a href="#1-内存回收" class="headerlink" title="1 内存回收"></a>1 内存回收</h2><p>当 Redis 存储数据使用的内存超过 Redis 设置的内存限制就会触发内存回收。当达到指定的内存限制大小时，需要选择回收策略进行内存回收。</p>
<h3 id="1-1-内存设置"><a href="#1-1-内存设置" class="headerlink" title="1.1 内存设置"></a>1.1 内存设置</h3><p><code>maxmemory </code> 配置指令用于配置 Redis 存储数据时指定限制的内存大小</p>
<p>通过配置文件 <code>redis.conf</code> 可以设置该指令，或者在运行时使用 <code>CONFIG SET</code> 命令来进行配置。</p>
<p>配置文件内存设置案例：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">maxmemory</span> <span class="string">100mb</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-回收策略"><a href="#1-2-回收策略" class="headerlink" title="1.2 回收策略"></a>1.2 回收策略</h3><p><code>maxmemory-policy</code> 配置指令用于 Redis 的回收策略。</p>
<p>回收策略：</p>
<ul>
<li>volatile-lru：采用最近使用最少的淘汰策略，Redis 将回收那些超时的（仅仅是超时的）键值对，也就是它只淘汰那些超时的键值对。</li>
<li>allkeys-lru：采用最近最少使用的淘汰策略，Redis 将对所有（不仅仅是超时的）的键值对采用最近最少使用的淘汰策略。</li>
<li>volatile-lfu：采用最近最不常用的淘汰策略，所谓最近最不常用，也就是一定时期内被访问次数最少的。Redis将回收超时的键值对。</li>
<li>allkeys-lfu：采用最近最不常用的淘汰策略，Redis 将对所有的键值对采用最近最不常用的淘汰策略。</li>
<li>volatile-random：采用随机淘汰策略删除超时的键值对。</li>
<li>allkeys-random：采用随机淘汰策略删除所有的键值对，这个策略不常用。</li>
<li>volatile-ttl：采用删除存活时间最短的键值对策略。</li>
<li>noeviction：不淘汰任何键值对，当内存满时，如果进行读操作，例如get命令，它将正常工作，而做写操作，它将返回错误，也就是说，当Redis采用这个策略内存达到最大的时候，它就只能读不能写了。</li>
</ul>
<h3 id="2-key-过期删除"><a href="#2-key-过期删除" class="headerlink" title="2 key 过期删除"></a>2 key 过期删除</h3><p>Redis keys 过期有两种方式：</p>
<ul>
<li>被动方式</li>
<li>主动方式</li>
</ul>
<h3 id="2-1-被动方式"><a href="#2-1-被动方式" class="headerlink" title="2.1 被动方式"></a>2.1 被动方式</h3><p>放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。</p>
<h3 id="2-2-主动方式"><a href="#2-2-主动方式" class="headerlink" title="2.2 主动方式"></a>2.2 主动方式</h3><p>被动方式的删除是不够的，因为有些过期的 keys，永远不会访问他们，但是这些 keys 应该过期，所以定时随机测试设置 keys 的过期时间，将这些过期的 keys 从 key 空间删除。</p>
<p>Redis会每秒10 次去做以下的事情：</p>
<ol>
<li>测试随机的 20 个 keys 进行相关过期检测。</li>
<li>删除所有已经过期的 keys。</li>
<li>如果有多于 25% 的 keys 过期，重复步骤 1。</li>
</ol>
<p>Redis 会不断重复过期检测，直到过期的 keys 的低于 25%，这意味着在任意时刻，最多会清除 1/4 过期的 keys。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>LRU</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 分区</title>
    <url>/2020/12/27/Redis-%E5%88%86%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="Redis-分区"><a href="#Redis-分区" class="headerlink" title="Redis 分区"></a>Redis 分区</h1><a id="more"></a>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 发布订阅</title>
    <url>/2020/12/27/Redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/</url>
    <content><![CDATA[<h1 id="Redis-发布订阅"><a href="#Redis-发布订阅" class="headerlink" title="Redis 发布订阅"></a>Redis 发布订阅</h1><a id="more"></a>

<p>发布、订阅和取消订阅实现了发布/订阅消息范式，发送者（发布者）不是计划发送消息给特定的接收者（订阅者）。而是发布的消息分到不同的频道，不需要知道什么样的订阅者订阅。订阅者对一个或多个频道感兴趣，只需接收感兴趣的消息，不需要知道什么样的发布者发布的。这种发布者和订阅者的解耦合可以带来更大的扩展性和更加动态的网络拓扑。</p>
<h2 id="1-Pub-Sub的基本知识"><a href="#1-Pub-Sub的基本知识" class="headerlink" title="1 Pub/Sub的基本知识"></a>1 Pub/Sub的基本知识</h2><p>Redis 是一个快速、稳定的发布/订阅的信息系统。</p>
<h2 id="2-Pub-Sub使用"><a href="#2-Pub-Sub使用" class="headerlink" title="2 Pub/Sub使用"></a>2 Pub/Sub使用</h2><h3 id="2-1-help-pubsub"><a href="#2-1-help-pubsub" class="headerlink" title="2.1 help @pubsub"></a>2.1 help @pubsub</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @pubsub</span><br><span class="line"></span><br><span class="line">  PSUBSCRIBE pattern [pattern ...]</span><br><span class="line">  summary: Listen for messages published to channels matching the given patterns</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  PUBLISH channel message</span><br><span class="line">  summary: Post a message to a channel</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  PUBSUB subcommand [argument [argument ...]]</span><br><span class="line">  summary: Inspect the state of the Pub&#x2F;Sub subsystem</span><br><span class="line">  since: 2.8.0</span><br><span class="line"></span><br><span class="line">  PUNSUBSCRIBE [pattern [pattern ...]]</span><br><span class="line">  summary: Stop listening for messages posted to channels matching the given patterns</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  SUBSCRIBE channel [channel ...]</span><br><span class="line">  summary: Listen for messages published to the given channels</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  UNSUBSCRIBE [channel [channel ...]]</span><br><span class="line">  summary: Stop listening for messages posted to the given channels</span><br><span class="line">  since: 2.0.0</span><br></pre></td></tr></table></figure>
<h3 id="2-2-发布订阅"><a href="#2-2-发布订阅" class="headerlink" title="2.2 发布订阅"></a>2.2 发布订阅</h3><h4 id="2-2-1-推送消息的格式"><a href="#2-2-1-推送消息的格式" class="headerlink" title="2.2.1 推送消息的格式"></a>2.2.1 推送消息的格式</h4><p>消息是一个有三个元素的多块响应，有三种情况:</p>
<ul>
<li>第一个元素消息类型是 subscribe：表示我们成功订阅到响应的第二个元素提供的频道，第三个参数代表我们现在订阅频道的数量。</li>
<li>第一个元素消息类型是 unsubscribe：表示我们成功取消订阅响应的第二个元素提供的频道，第三个参数代表我们目前订阅的频道的数量。当最后一个参数是 0 的时候，我们不再订阅到任何频道。当我们在 Pub/Sub 以外状态，客户端可以发出任何 redis 命令。</li>
<li>第一个元素消息类型是 message：这是另外一个客户端发出的发布命令的结果。第二个元素是来源频道的名称，第三个参数是实际消息的内容。</li>
</ul>
<h4 id="2-2-2-发布-订阅"><a href="#2-2-2-发布-订阅" class="headerlink" title="2.2.2 发布/订阅"></a>2.2.2 发布/订阅</h4><p>订阅 foo 和 bar，客户端发出一个订阅的频道名称</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># client1 订阅渠道foo和bar</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SUBSCRIBE foo bar</span><br><span class="line">Reading messages... (press Ctrl<span class="literal">-C</span> to quit)</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;foo&quot;</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;bar&quot;</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>其他客户端发到这些频道的消息将会被推送到所有订阅的客户端。</p>
<p>foo 和 bar 发布消息</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># client2 渠道发布</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PUBLISH foo Hello</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PUBLISH bar World</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># client1 接收消息</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SUBSCRIBE foo bar</span><br><span class="line">Reading messages... (press Ctrl<span class="literal">-C</span> to quit)</span><br><span class="line"><span class="comment"># 消息类型message</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;message&quot;</span></span><br><span class="line"><span class="comment"># 消息来源频道</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;foo&quot;</span></span><br><span class="line"><span class="comment"># 实际消息内容</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;message&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;bar&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;World&quot;</span></span><br></pre></td></tr></table></figure>
<p>取消订阅</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; UNSUBSCRIBE foo</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;unsubscribe&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;foo&quot;</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">0</span>	</span><br></pre></td></tr></table></figure>
<h4 id="2-2-3-模式匹配订阅（正则匹配）"><a href="#2-2-3-模式匹配订阅（正则匹配）" class="headerlink" title="2.2.3 模式匹配订阅（正则匹配）"></a>2.2.3 模式匹配订阅（正则匹配）</h4><p>Redis 的 Pub/Sub 实现支持模式匹配。客户端可以订阅全风格的模式以便接收所有来自能匹配到给定模式的频道的消息。</p>
<p>订阅</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># client1订阅消息</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PSUBSCRIBE news.*</span><br><span class="line">Reading messages... (press Ctrl<span class="literal">-C</span> to quit)</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;psubscribe&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;news.*&quot;</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>发布</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># client2消息发布</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PUBLISH news.foo Hello</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># client1消息接收</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PSUBSCRIBE news.*</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;pmessage&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;news.*&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;news.foo&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>
<p>取消订阅</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PUNSUBSCRIBE news.*</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;punsubscribe&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;news.*&quot;</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-4-同时匹配模式和频道订阅的消息"><a href="#2-2-4-同时匹配模式和频道订阅的消息" class="headerlink" title="2.2.4 同时匹配模式和频道订阅的消息"></a>2.2.4 同时匹配模式和频道订阅的消息</h4><p>订阅</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">SUBSCRIBE foo</span><br><span class="line">PSUBSCRIBE f*</span><br></pre></td></tr></table></figure>
<p>上面的例子中，如果一个消息被发送到 foo，客户端会接收到两条消息：一条 message 类型，一条 pmessage 类型。</p>
<h2 id="3-发布订阅使用场景：聊天系统"><a href="#3-发布订阅使用场景：聊天系统" class="headerlink" title="3 发布订阅使用场景：聊天系统"></a>3 发布订阅使用场景：聊天系统</h2><p>Peter Noordhuis 提供了一个使用EventMachine 和Redis创建多用户高性能网路聊天的很棒的例子，链接：<a href="https://gist.github.com/pietern/348262">https://gist.github.com/pietern/348262</a></p>
<h2 id="4-SpringBoot-中使用发布订阅实现简单的聊天室"><a href="#4-SpringBoot-中使用发布订阅实现简单的聊天室" class="headerlink" title="4 SpringBoot 中使用发布订阅实现简单的聊天室"></a>4 SpringBoot 中使用发布订阅实现简单的聊天室</h2><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pubSubTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RedisConnection connection = stringRedisTemplate.getConnectionFactory().getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 订阅</span></span><br><span class="line">        connection.subscribe(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">            <span class="comment">// 处理消息</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">byte</span>[] body = message.getBody();</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;chat&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            stringRedisTemplate.convertAndSend(<span class="string">&quot;chat&quot;</span>, <span class="string">&quot;Hello World&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>redis-cli</code> 显示：</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201227110414063.png" alt="image-20201227110414063"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 哨兵模式高可用解决方案</title>
    <url>/2020/12/27/Redis-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E9%AB%98%E5%8F%AF%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="Redis-哨兵模式高可用解决方案"><a href="#Redis-哨兵模式高可用解决方案" class="headerlink" title="Redis 哨兵模式高可用解决方案"></a>Redis 哨兵模式高可用解决方案</h1><a id="more"></a>

<h2 id="1-Redis哨兵简介"><a href="#1-Redis哨兵简介" class="headerlink" title="1 Redis哨兵简介"></a>1 Redis哨兵简介</h2><p>Redis的哨兵系统用于管理多个Redis服务器，该系统执行以下三个任务：</p>
<ul>
<li>监控</li>
<li>提醒</li>
<li>自动故障转移</li>
</ul>
<h2 id="2-Redis哨兵使用"><a href="#2-Redis哨兵使用" class="headerlink" title="2 Redis哨兵使用"></a>2 Redis哨兵使用</h2><h3 id="2-1-配置-Sentinel"><a href="#2-1-配置-Sentinel" class="headerlink" title="2.1 配置 Sentinel"></a>2.1 配置 Sentinel</h3><p>新建三个 sentinel 配置文件，例 26379.conf、26380.conf、26381.conf 监听主机，内容为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">port 26379&#x2F;26380&#x2F;26381</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br></pre></td></tr></table></figure>
<p>运行主机</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-server .&#x2F;6379.conf</span><br></pre></td></tr></table></figure>
<p>运行两个 slave</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-server .&#x2F;6380.conf --replicaof 127.0.0.1 6379</span><br><span class="line">redis-server .&#x2F;6381.conf --replicaof 127.0.0.1 6379</span><br></pre></td></tr></table></figure>
<p>启动哨兵</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-server .&#x2F;26379.conf --sentinel</span><br><span class="line">redis-server .&#x2F;26380.conf --sentinel</span><br><span class="line">redis-server .&#x2F;26381.conf --sentinel</span><br></pre></td></tr></table></figure>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200722211540287.png" alt="image-20200722211540287"></p>
<h3 id="2-2-测试哨兵"><a href="#2-2-测试哨兵" class="headerlink" title="2.2 测试哨兵"></a>2.2 测试哨兵</h3><p>此时断开 6379，经过一段时间，会投票选出新的主机，本次测试 2 票选出 6381</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6909:X 13 Jul 2020 17:06:41.887 # +sdown master mymaster 127.0.0.1 6379</span><br><span class="line">6909:X 13 Jul 2020 17:06:41.946 # +odown master mymaster 127.0.0.1 6379 #quorum 3&#x2F;2</span><br><span class="line">6909:X 13 Jul 2020 17:06:41.946 # +new-epoch 1</span><br><span class="line">6909:X 13 Jul 2020 17:06:41.946 # +try-failover master mymaster 127.0.0.1 6379</span><br><span class="line">6909:X 13 Jul 2020 17:06:41.964 # +vote-for-leader f0d0f7c12cc881a04d88ad7831100d0eea82cec4 1</span><br><span class="line">6909:X 13 Jul 2020 17:06:41.969 # 3dd3212a440f415e989718634222ae89fc2fd219 voted for 3dd3212a440f415e989718634222ae89fc2fd219 1</span><br><span class="line">6909:X 13 Jul 2020 17:06:41.989 # 44c8a525d5b8390571e2621fa3dfa416eafa8c0b voted for f0d0f7c12cc881a04d88ad7831100d0eea82cec4 1</span><br><span class="line">6909:X 13 Jul 2020 17:06:42.027 # +elected-leader master mymaster 127.0.0.1 6379</span><br><span class="line">6909:X 13 Jul 2020 17:06:42.027 # +failover-state-select-slave master mymaster 127.0.0.1 6379</span><br><span class="line">6909:X 13 Jul 2020 17:06:42.100 # +selected-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379</span><br><span class="line">6909:X 13 Jul 2020 17:06:42.100 * +failover-state-send-slaveof-noone slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379</span><br><span class="line">6909:X 13 Jul 2020 17:06:42.159 * +failover-state-wait-promotion slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379</span><br><span class="line">6909:X 13 Jul 2020 17:06:42.445 # +promoted-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379</span><br><span class="line">6909:X 13 Jul 2020 17:06:42.445 # +failover-state-reconf-slaves master mymaster 127.0.0.1 6379</span><br><span class="line">6909:X 13 Jul 2020 17:06:42.528 * +slave-reconf-sent slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379</span><br><span class="line">6909:X 13 Jul 2020 17:06:43.113 # -odown master mymaster 127.0.0.1 6379</span><br><span class="line">6909:X 13 Jul 2020 17:06:43.482 * +slave-reconf-inprog slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379</span><br><span class="line">6909:X 13 Jul 2020 17:06:43.482 * +slave-reconf-done slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379</span><br><span class="line">6909:X 13 Jul 2020 17:06:43.554 # +failover-end master mymaster 127.0.0.1 6379</span><br><span class="line">6909:X 13 Jul 2020 17:06:43.554 # +switch-master mymaster 127.0.0.1 6379 127.0.0.1 6381</span><br><span class="line">6909:X 13 Jul 2020 17:06:43.554 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381</span><br><span class="line">6909:X 13 Jul 2020 17:06:43.554 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381</span><br><span class="line">6909:X 13 Jul 2020 17:07:13.568 # +sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381</span><br></pre></td></tr></table></figure>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200722212104628.png" alt="image-20200722212104628"></p>
<p>哨兵会自动更改配置文件</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200722212459813.png" alt="image-20200722212459813"></p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200722212525730.png" alt="image-20200722212525730"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>HA</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 基于SpringBoot API的使用</title>
    <url>/2020/12/26/Redis-%E5%9F%BA%E4%BA%8ESpringBoot-API%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="基于-Spring-Boot-的-Redis-API-使用"><a href="#基于-Spring-Boot-的-Redis-API-使用" class="headerlink" title="基于 Spring Boot 的 Redis API 使用"></a>基于 Spring Boot 的 Redis API 使用</h1><a id="more"></a>

<h2 id="1-新建-Spring-Boot-项目"><a href="#1-新建-Spring-Boot-项目" class="headerlink" title="1 新建 Spring Boot 项目"></a>1 新建 Spring Boot 项目</h2><p>本次使用的工具是 <code>IDEA</code>，新建项目，点击 <code>Next</code></p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201226003848807.png" alt="image-20201226003848807"></p>
<p><code>NoSQL</code> 中选中 <code>Spring Data Redis</code>，继续点击 <code>Next</code></p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201226003954727.png" alt="image-20201226003954727"></p>
<p>选择一个合适的磁盘目录，创建新项目，一个新的项目就创建好了。</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201226004241036.png" alt="image-20201226004241036"></p>
<p>可以看到 <code>pom.xml</code> 中引用了 <code>spring-boot-starter-data-redis</code></p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201226004412233.png" alt="image-20201226004412233"></p>
<p><code>Maven</code> 依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-Redis-参数配置"><a href="#2-Redis-参数配置" class="headerlink" title="2 Redis 参数配置"></a>2 Redis 参数配置</h2><p>在 <code>application.properties</code>（也可以是 <code>application.yml</code>）添加 <code>Redis </code> 的参数：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br></pre></td></tr></table></figure>
<h2 id="3-基础-API"><a href="#3-基础-API" class="headerlink" title="3 基础 API"></a>3 基础 API</h2><h3 id="3-1-低级-API"><a href="#3-1-低级-API" class="headerlink" title="3.1 低级 API"></a>3.1 低级 API</h3><h4 id="3-1-1-RedisConnection"><a href="#3-1-1-RedisConnection" class="headerlink" title="3.1.1 RedisConnection"></a>3.1.1 RedisConnection</h4><p>虽然 <code>Redis</code> 是二进制安全的，但是 <code>RedisConnection</code> 提供了接受和返回二进制值（<code>byte</code> 数组）的低级方法，模板负责序列化和连接管理，用户无需处理此类细节。</p>
<h3 id="3-2-高级-API"><a href="#3-2-高级-API" class="headerlink" title="3.2 高级 API"></a>3.2 高级 API</h3><h4 id="3-2-1-RedisTemplate"><a href="#3-2-1-RedisTemplate" class="headerlink" title="3.2.1 RedisTemplate"></a>3.2.1 RedisTemplate</h4><p><code>RedisTemplate</code> 为 <code>Redis</code> 交互提供了高级抽象，提供了操作视图（根据Redis命令进行分组），提供了丰富的，通用的接口，用于针对某种类型或某些键（通过 <code>KeyBound</code> 接口），如下表所述：</p>
<table>
<thead>
<tr>
<th align="left">接口</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">按键类型操作</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>GeoOperations</code></td>
<td align="left">Redis 的 geospatial 操作, 例如 <code>GEOADD</code>, <code>GEORADIUS</code>,…</td>
</tr>
<tr>
<td align="left"><code>HashOperations</code></td>
<td align="left">Redis 的 hash 类型操作</td>
</tr>
<tr>
<td align="left"><code>HyperLogLogOperations</code></td>
<td align="left">Redis 的 HyperLogLog 操作, 例如 <code>PFADD</code>, <code>PFCOUNT</code>,…</td>
</tr>
<tr>
<td align="left"><code>ListOperations</code></td>
<td align="left">Redis 的 list 类型操作</td>
</tr>
<tr>
<td align="left"><code>SetOperations</code></td>
<td align="left">Redis 的 set 类型操作</td>
</tr>
<tr>
<td align="left"><code>ValueOperations</code></td>
<td align="left">Redis 的 string (或者 value) 类型操作</td>
</tr>
<tr>
<td align="left"><code>ZSetOperations</code></td>
<td align="left">Redis 的 zset (或者 sorted set) 类型操作</td>
</tr>
<tr>
<td align="left">键值绑定操作</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>BoundGeoOperations</code></td>
<td align="left">Redis 的 key 绑定 geospatial 操作</td>
</tr>
<tr>
<td align="left"><code>BoundHashOperations</code></td>
<td align="left">Redis 的 hash key 绑定操作</td>
</tr>
<tr>
<td align="left"><code>BoundKeyOperations</code></td>
<td align="left">Redis 的 key 绑定操作</td>
</tr>
<tr>
<td align="left"><code>BoundListOperations</code></td>
<td align="left">Redis 的 list key 绑定操作</td>
</tr>
<tr>
<td align="left"><code>BoundSetOperations</code></td>
<td align="left">Redis 的 set key 绑定操作</td>
</tr>
<tr>
<td align="left"><code>BoundValueOperations</code></td>
<td align="left">Redis 的 string (或者 value) key 绑定操作</td>
</tr>
<tr>
<td align="left"><code>BoundZSetOperations</code></td>
<td align="left">Redis 的 zset (或者 sorted set) key 绑定操作</td>
</tr>
</tbody></table>
<h4 id="3-2-2-StringRedisTemplate"><a href="#3-2-2-StringRedisTemplate" class="headerlink" title="3.2.2 StringRedisTemplate"></a>3.2.2 StringRedisTemplate</h4><p>由于 <code>Redis</code> 中的键和值通常是 <code>java.lang.String</code>，因此 <code>Redis</code> 提供对 <code>String</code> 类型操作更便利的 <code>StringRedisTemplate</code> 。</p>
<h2 id="4-API-操作测试案例"><a href="#4-API-操作测试案例" class="headerlink" title="4 API 操作测试案例"></a>4 API 操作测试案例</h2><p>新建测试类，本次使用的 <code>Junit5</code>，每次测试前首先清空 <code>Redis</code> 中所有数据</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201226210010782.png" alt="image-20201226210010782"></p>
<h3 id="4-1-String-类型操作案例"><a href="#4-1-String-类型操作案例" class="headerlink" title="4.1 String 类型操作案例"></a>4.1 String 类型操作案例</h3><p>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stringTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 使用低级API RedisConnection操作String</span></span><br><span class="line">        RedisConnection redisConnection = redisTemplate.getConnectionFactory().getConnection();</span><br><span class="line">        redisConnection.set(<span class="string">&quot;redisConnectionTestString&quot;</span>.getBytes(), <span class="string">&quot;redis connection test string&quot;</span>.getBytes());</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(redisConnection.get(<span class="string">&quot;redisConnectionTestString&quot;</span>.getBytes())));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 使用redisTemplate操作String</span></span><br><span class="line">        ValueOperations redisTemplateOperations = redisTemplate.opsForValue();</span><br><span class="line">        redisTemplateOperations.set(<span class="string">&quot;redisTmplOpsTestString&quot;</span>, <span class="string">&quot;redis template operations test string&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplateOperations.get(<span class="string">&quot;redisTmplOpsTestString&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 使用stringRedisTemplate操作String</span></span><br><span class="line">        ValueOperations&lt;String, String&gt; stringRedisTemplateOperations = stringRedisTemplate.opsForValue();</span><br><span class="line">        stringRedisTemplateOperations.set(<span class="string">&quot;stringRedisTmplOpsTestString&quot;</span>, <span class="string">&quot;string redis template operations test string&quot;</span>);</span><br><span class="line">        System.out.println(stringRedisTemplateOperations.get(<span class="string">&quot;stringRedisTmplOpsTestString&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 使用redisTemplate boundValueOps操作String</span></span><br><span class="line">        BoundValueOperations boundValueOps = redisTemplate.boundValueOps(<span class="string">&quot;redisTmplOpsTestString&quot;</span>);</span><br><span class="line">        System.out.println(boundValueOps.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 使用redisTemplate boundValueOps操作String</span></span><br><span class="line">        BoundValueOperations&lt;String, String&gt; stringBoundValueOperations = stringRedisTemplate.boundValueOps(<span class="string">&quot;stringRedisTmplOpsTestString&quot;</span>);</span><br><span class="line">        System.out.println(stringBoundValueOperations.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台打印：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis connection test string</span><br><span class="line">redis template operations test string</span><br><span class="line">string redis template operations test string</span><br><span class="line">redis template operations test string</span><br><span class="line">string redis template operations test string</span><br></pre></td></tr></table></figure>
<p><code>redis-cli</code> 查看：</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201226211610274.png" alt="image-20201226211610274"></p>
<p>上面 <code>keys *</code> 打印所有的 <code>key</code> 时 <code>3)</code> 显示乱码，是什么原因？</p>
<p>原因是 <code>Redis </code> 是二进制安全的，会把所有的数据变成二进制数组，有关序列化参考序列化文章。</p>
<h3 id="4-2-List-类型操作案例"><a href="#4-2-List-类型操作案例" class="headerlink" title="4.2 List 类型操作案例"></a>4.2 List 类型操作案例</h3><p>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">listTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        values.addAll(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 使用低级API RedisConnection操作List</span></span><br><span class="line">        RedisConnection redisConnection = redisTemplate.getConnectionFactory().getConnection();</span><br><span class="line">        redisConnection.lPush(<span class="string">&quot;redisConnectionTestList&quot;</span>.getBytes(), <span class="string">&quot;1&quot;</span>.getBytes(), <span class="string">&quot;2&quot;</span>.getBytes(), <span class="string">&quot;3&quot;</span>.getBytes());</span><br><span class="line">        System.out.println(redisConnection.lRange(<span class="string">&quot;redisConnectionTestList&quot;</span>.getBytes(), <span class="number">0L</span>, -<span class="number">1L</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 使用redisTemplate操作String</span></span><br><span class="line"></span><br><span class="line">        ListOperations redisTemplateOperations = redisTemplate.opsForList();</span><br><span class="line">        redisTemplateOperations.leftPushAll(<span class="string">&quot;redisTmplOpsTestList&quot;</span>, values);</span><br><span class="line">        System.out.println(redisTemplateOperations.range(<span class="string">&quot;redisTmplOpsTestList&quot;</span>, <span class="number">0L</span>, -<span class="number">1L</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 使用redisTemplate boundListOps操作List</span></span><br><span class="line">        BoundListOperations boundListOps = redisTemplate.boundListOps(<span class="string">&quot;redisTmplOpsTestList&quot;</span>);</span><br><span class="line">        System.out.println(boundListOps.range(<span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台打印：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[B@6fa0450e, [B@37468787, [B@51ec2856]</span><br><span class="line">[3, 2, 1]</span><br><span class="line">[3, 2, 1]</span><br></pre></td></tr></table></figure>
<p><code>redis-cli</code> 查看：</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201226214257532.png" alt="image-20201226214257532"></p>
<h3 id="4-3-Hash-类型操作案例"><a href="#4-3-Hash-类型操作案例" class="headerlink" title="4.3 Hash 类型操作案例"></a>4.3 Hash 类型操作案例</h3><p>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">listTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 使用低级API RedisConnection操作Hash</span></span><br><span class="line">        RedisConnection redisConnection = redisTemplate.getConnectionFactory().getConnection();</span><br><span class="line">        redisConnection.hSet(<span class="string">&quot;redisConnectionTestHash&quot;</span>.getBytes(), <span class="string">&quot;name&quot;</span>.getBytes(), <span class="string">&quot;yeyangshu&quot;</span>.getBytes());</span><br><span class="line">        redisConnection.hSet(<span class="string">&quot;redisConnectionTestHash&quot;</span>.getBytes(), <span class="string">&quot;age&quot;</span>.getBytes(), <span class="string">&quot;20&quot;</span>.getBytes());</span><br><span class="line">        System.out.println(redisConnection.hGet(<span class="string">&quot;redisConnectionTestHash&quot;</span>.getBytes(), <span class="string">&quot;name&quot;</span>.getBytes()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 使用redisTemplate操作Hash</span></span><br><span class="line">        HashOperations redisTemplateOperations = redisTemplate.opsForHash();</span><br><span class="line">        redisTemplateOperations.put(<span class="string">&quot;redisTmplOpsTestHash&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;yeyangshu&quot;</span>);</span><br><span class="line">        redisTemplateOperations.put(<span class="string">&quot;redisTmplOpsTestHash&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;20&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplateOperations.values(<span class="string">&quot;redisTmplOpsTestHash&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 使用redisTemplate boundHashOps操作Hash</span></span><br><span class="line">        BoundHashOperations boundHashOps = redisTemplate.boundHashOps(<span class="string">&quot;redisTmplOpsTestHash&quot;</span>);</span><br><span class="line">        System.out.println(boundHashOps.values());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台打印：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[B@33425811</span><br><span class="line">[yeyangshu, 20]</span><br><span class="line">[yeyangshu, 20]</span><br></pre></td></tr></table></figure>
<p><code>redis-cli</code> 查看：</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201226215806979.png" alt="image-20201226215806979"></p>
<p>使用 <code>Hash</code> 的时候更希望直接使用对象，会在后面文章讲解</p>
<h3 id="4-4-Set-类型操作案例"><a href="#4-4-Set-类型操作案例" class="headerlink" title="4.4 Set 类型操作案例"></a>4.4 Set 类型操作案例</h3><h3 id="4-5-Sorted-Sets-类型操作案例"><a href="#4-5-Sorted-Sets-类型操作案例" class="headerlink" title="4.5 Sorted Sets 类型操作案例"></a>4.5 Sorted Sets 类型操作案例</h3>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 基本数据类型 Hashes</title>
    <url>/2020/12/26/Redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-Hashes/</url>
    <content><![CDATA[<h1 id="Redis-Hashes"><a href="#Redis-Hashes" class="headerlink" title="Redis Hashes"></a>Redis Hashes</h1><h2 id="1-Hashes简介"><a href="#1-Hashes简介" class="headerlink" title="1 Hashes简介"></a>1 Hashes简介</h2><a id="more"></a>

<p>Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</p>
<p>Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）。</p>
<h2 id="2-Hashes命令"><a href="#2-Hashes命令" class="headerlink" title="2 Hashes命令"></a>2 Hashes命令</h2><h3 id="2-1-help-hash"><a href="#2-1-help-hash" class="headerlink" title="2.1 help @hash"></a>2.1 help @hash</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @hash</span><br><span class="line"></span><br><span class="line">  HDEL key field [field ...]</span><br><span class="line">  summary: Delete one or more hash fields</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HEXISTS key field</span><br><span class="line">  summary: Determine if a hash field exists</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HGET key field</span><br><span class="line">  summary: Get the value of a hash field</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HGETALL key</span><br><span class="line">  summary: Get all the fields and values in a hash</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HINCRBY key field increment</span><br><span class="line">  summary: Increment the integer value of a hash field by the given number</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HINCRBYFLOAT key field increment</span><br><span class="line">  summary: Increment the float value of a hash field by the given amount</span><br><span class="line">  since: 2.6.0</span><br><span class="line"></span><br><span class="line">  HKEYS key</span><br><span class="line">  summary: Get all the fields in a hash</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HLEN key</span><br><span class="line">  summary: Get the number of fields in a hash</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HMGET key field [field ...]</span><br><span class="line">  summary: Get the values of all the given hash fields</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HMSET key field value [field value ...]</span><br><span class="line">  summary: Set multiple hash fields to multiple values</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HSCAN key cursor [MATCH pattern] [COUNT count]</span><br><span class="line">  summary: Incrementally iterate hash fields and associated values</span><br><span class="line">  since: 2.8.0</span><br><span class="line"></span><br><span class="line">  HSET key field value</span><br><span class="line">  summary: Set the string value of a hash field</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HSETNX key field value</span><br><span class="line">  summary: Set the value of a hash field, only if the field does not exist</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HSTRLEN key field</span><br><span class="line">  summary: Get the length of the value of a hash field</span><br><span class="line">  since: 3.2.0</span><br><span class="line"></span><br><span class="line">  HVALS key</span><br><span class="line">  summary: Get all the values in a hash</span><br><span class="line">  since: 2.0.0</span><br></pre></td></tr></table></figure>
<h3 id="2-2-HSET-amp-HGET"><a href="#2-2-HSET-amp-HGET" class="headerlink" title="2.2 HSET&amp;HGET"></a>2.2 HSET&amp;HGET</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help hset</span><br><span class="line"></span><br><span class="line">  HSET key field value</span><br><span class="line">  summary: Set the string value of a hash field</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: hash</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help hget</span><br><span class="line"></span><br><span class="line">  HGET key field</span><br><span class="line">  summary: Get the value of a hash field</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: hash</span><br></pre></td></tr></table></figure>
<p>HSET：将哈希表 <code>key</code> 中的域 <code>field</code> 的值设为 <code>value</code> 。</p>
<ul>
<li><p>如果 <code>key</code> 不存在，一个新的哈希表被创建并进行 HSET 操作。</p>
</li>
<li><p>如果域 <code>field</code> 已经存在于哈希表中，旧值将被覆盖。</p>
</li>
</ul>
<p>HGET：返回哈希表 <code>key</code> 中给定域 <code>field</code> 的值。</p>
<ul>
<li>当给定域不存在或是给定 <code>key</code> 不存在时，返回 <code>nil</code> 。</li>
</ul>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将yeyangshu name赋值yeyangshu</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HSET yeyangshu name yeyangshu</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HGET yeyangshu name</span><br><span class="line"><span class="string">&quot;yeyangshu&quot;</span></span><br><span class="line"><span class="comment"># 将yeyangshu name覆盖赋值yeyang</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HSET yeyangshu name yeyang</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HGET yeyangshu name</span><br><span class="line"><span class="string">&quot;yeyang&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取不存在的域</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HGET yeyangshu age</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<h3 id="2-3-HMSET-amp-HMGET"><a href="#2-3-HMSET-amp-HMGET" class="headerlink" title="2.3 HMSET&amp;HMGET"></a>2.3 HMSET&amp;HMGET</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help hmset</span><br><span class="line"></span><br><span class="line">  HMSET key field value [field value ...]</span><br><span class="line">  summary: Set multiple hash fields to multiple values</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: hash</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help hmget</span><br><span class="line"></span><br><span class="line">  HMGET key field [field ...]</span><br><span class="line">  summary: Get the values of all the given hash fields</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: hash</span><br></pre></td></tr></table></figure>
<p>HMSET：同时将多个 <code>field-value</code> (域-值)对设置到哈希表 <code>key</code> 中。</p>
<ul>
<li>此命令会覆盖哈希表中已存在的域。</li>
</ul>
<p>HMGET：返回哈希表 <code>key</code> 中，一个或多个给定域的值。</p>
<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HMSET sean age 20 address beijing</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; HMGET sean name</span><br><span class="line">&quot;yeyangshu&quot;</span><br><span class="line">127.0.0.1:6379&gt; HMGET sean name age address</span><br><span class="line">1) &quot;yeyangshu&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">3) &quot;beijing&quot;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-HGETALL"><a href="#2-4-HGETALL" class="headerlink" title="2.4 HGETALL"></a>2.4 HGETALL</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help hgetall</span><br><span class="line"></span><br><span class="line">  HGETALL key</span><br><span class="line">  summary: Get all the fields and values in a hash</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: hash</span><br></pre></td></tr></table></figure>
<p>HGETALL：返回哈希表 <code>key</code> 中，所有的域和值。</p>
<ul>
<li>在返回值里，紧跟每个域名(field name)之后是域的值(value)，所以返回值的长度是哈希表大小的两倍。</li>
</ul>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HGETALL sean</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;yeyangshu&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;address&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-HKEYS-amp-HVALS"><a href="#2-5-HKEYS-amp-HVALS" class="headerlink" title="2.5 HKEYS&amp;HVALS"></a>2.5 HKEYS&amp;HVALS</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help hkeys</span><br><span class="line"></span><br><span class="line">  HKEYS key</span><br><span class="line">  summary: Get all the fields in a hash</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: hash</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help hvals</span><br><span class="line"></span><br><span class="line">  HVALS key</span><br><span class="line">  summary: Get all the values in a hash</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: hash</span><br></pre></td></tr></table></figure>
<p>HKEYS：返回哈希表 <code>key</code> 中的所有域。</p>
<p>HVALS：返回哈希表 <code>key</code> 中所有域的值。</p>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HKEYS sean</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;address&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HVALS sean</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;yeyangshu&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;beijing&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-6-HINCRBY-amp-HINCRBYFLOAT"><a href="#2-6-HINCRBY-amp-HINCRBYFLOAT" class="headerlink" title="2.6 HINCRBY&amp;HINCRBYFLOAT"></a>2.6 HINCRBY&amp;HINCRBYFLOAT</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help hincrby</span><br><span class="line"></span><br><span class="line">  HINCRBY key field increment</span><br><span class="line">  summary: Increment the integer value of a hash field by the given number</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: hash</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help hincrbyfloat</span><br><span class="line"></span><br><span class="line">  HINCRBYFLOAT key field increment</span><br><span class="line">  summary: Increment the float value of a hash field by the given amount</span><br><span class="line">  since: 2.6.0</span><br><span class="line">  group: hash</span><br></pre></td></tr></table></figure>
<p>HINCRBY：为哈希表 <code>key</code> 中的域 <code>field</code> 的值加上增量 <code>increment</code> 。</p>
<ul>
<li>增量也可以为负数，相当于对给定域进行减法操作。</li>
</ul>
<p>HINCRBYFLOAT：为哈希表 <code>key</code> 中的域 <code>field</code> 加上浮点数增量 <code>increment</code> 。</p>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HINCRBYFLOAT sean age <span class="number">0.5</span></span><br><span class="line"><span class="string">&quot;20.5&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HGET sean age</span><br><span class="line"><span class="string">&quot;20.5&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HINCRBYFLOAT sean age <span class="literal">-1</span></span><br><span class="line"><span class="string">&quot;19.5&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Hashes使用场景"><a href="#3-Hashes使用场景" class="headerlink" title="3 Hashes使用场景"></a>3 Hashes使用场景</h2><ol>
<li>Redis是内存的数据库，所有对值的操作都是非常快的，一般的商品详情页都会有很多字段信息，如果客户端请求这么多数据，每一个数据都需要请求一次数据库，可以使用Redis hashes，将所有的信息进行整合，数据整合，调用次数会变低。</li>
<li>数据都会变化，比如微博的个人关注、点赞或者商品详情页的浏览次数、被收藏的次数，数据不仅要被查询，还要进行计算，hash还支持数值计算。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 基本数据类型 Lists</title>
    <url>/2020/12/26/Redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-Lists/</url>
    <content><![CDATA[<h1 id="Redis-Lists"><a href="#Redis-Lists" class="headerlink" title="Redis Lists"></a>Redis Lists</h1><h2 id="1-Lists简介"><a href="#1-Lists简介" class="headerlink" title="1 Lists简介"></a>1 Lists简介</h2><a id="more"></a>

<p>官网：</p>
<p>Redis lists基于Linked Lists实现。这意味着即使在一个list中有数百万个元素，在头部或尾部添加一个元素的操作，其时间复杂度也是常数级别的。用LPUSH 命令在十个元素的list头部添加新元素，和在千万元素list头部添加新元素的速度相同。</p>
<p>那么，坏消息是什么？在数组实现的list中利用索引访问元素的速度极快，而同样的操作在linked list实现的list上没有那么快。</p>
<p>Redis Lists用linked list实现的原因是：对于数据库系统来说，至关重要的特性是：能非常快的在很大的列表上添加元素。另一个重要因素是，正如你将要看到的：Redis lists能在常数时间取得常数长度。</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200707204400692.png" alt="image-20200707204400692"></p>
<h2 id="2-List命令"><a href="#2-List命令" class="headerlink" title="2 List命令"></a>2 List命令</h2><h3 id="2-1-help-list"><a href="#2-1-help-list" class="headerlink" title="2.1 help @list"></a>2.1 help @list</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @list</span><br><span class="line"></span><br><span class="line">  BLPOP key [key ...] timeout</span><br><span class="line">  summary: Remove and get the first element in a list, or block until one is available</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  BRPOP key [key ...] timeout</span><br><span class="line">  summary: Remove and get the last element in a list, or block until one is available</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  BRPOPLPUSH source destination timeout</span><br><span class="line">  summary: Pop a value from a list, push it to another list and return it; or block until one is available</span><br><span class="line">  since: 2.2.0</span><br><span class="line"></span><br><span class="line">  LINDEX key index</span><br><span class="line">  summary: Get an element from a list by its index</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  LINSERT key BEFORE|AFTER pivot value</span><br><span class="line">  summary: Insert an element before or after another element in a list</span><br><span class="line">  since: 2.2.0</span><br><span class="line"></span><br><span class="line">  LLEN key</span><br><span class="line">  summary: Get the length of a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  LPOP key</span><br><span class="line">  summary: Remove and get the first element in a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  LPUSH key value [value ...]</span><br><span class="line">  summary: Prepend one or multiple values to a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  LPUSHX key value</span><br><span class="line">  summary: Prepend a value to a list, only if the list exists</span><br><span class="line">  since: 2.2.0</span><br><span class="line"></span><br><span class="line">  LRANGE key start stop</span><br><span class="line">  summary: Get a range of elements from a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  LREM key count value</span><br><span class="line">  summary: Remove elements from a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  LSET key index value</span><br><span class="line">  summary: Set the value of an element in a list by its index</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  LTRIM key start stop</span><br><span class="line">  summary: Trim a list to the specified range</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  RPOP key</span><br><span class="line">  summary: Remove and get the last element in a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  RPOPLPUSH source destination</span><br><span class="line">  summary: Remove the last element in a list, prepend it to another list and return it</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  RPUSH key value [value ...]</span><br><span class="line">  summary: Append one or multiple values to a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  RPUSHX key value</span><br><span class="line">  summary: Append a value to a list, only if the list exists</span><br><span class="line">  since: 2.2.0</span><br></pre></td></tr></table></figure>
<h3 id="2-2-LPUSH-amp-RPUSH-amp-LPOP-amp-RPOP"><a href="#2-2-LPUSH-amp-RPUSH-amp-LPOP-amp-RPOP" class="headerlink" title="2.2 LPUSH&amp;RPUSH&amp;LPOP&amp;RPOP"></a>2.2 LPUSH&amp;RPUSH&amp;LPOP&amp;RPOP</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help lpush</span><br><span class="line"></span><br><span class="line">  LPUSH key value [value ...]</span><br><span class="line">  summary: Prepend one or multiple values to a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: list</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help rpush</span><br><span class="line"></span><br><span class="line">  RPUSH key value [value ...]</span><br><span class="line">  summary: Append one or multiple values to a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: list</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help lpop</span><br><span class="line"></span><br><span class="line">  LPOP key</span><br><span class="line">  summary: Remove and get the first element in a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: list</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help rpop</span><br><span class="line"></span><br><span class="line">  RPOP key</span><br><span class="line">  summary: Remove and get the last element in a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: list</span><br></pre></td></tr></table></figure>
<p>LPUSH：将一个或多个值 <code>value</code> 插入到列表 <code>key</code> 的表头</p>
<ul>
<li>如果有多个 <code>value</code> 值，那么各个 <code>value</code> 值按从左到右的顺序依次插入到表头</li>
</ul>
<p>RPUSH：将一个或多个值 <code>value</code> 插入到列表 <code>key</code> 的表尾(最右边)。</p>
<ul>
<li>如果有多个 <code>value</code> 值，那么各个 <code>value</code> 值按从左到右的顺序依次插入到表尾</li>
</ul>
<p>LPOP：移除并返回列表 <code>key</code> 的头元素。</p>
<p>RPOP：移除并返回列表 <code>key</code> 的尾元素。</p>
<p><strong>可以实现两种数据结构：</strong></p>
<ul>
<li><strong>栈：同向命令实现，LPUSH+LPOP</strong></li>
<li><strong>队列：反向命令实现，LPUSH+RPOP</strong></li>
</ul>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此时链表排列顺序为 f e d c b a</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LPUSH k1 a b c d e f</span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"><span class="comment"># 此时链表排列顺序为 a b c d e f</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; RPUSH k2 a b c d e f</span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"><span class="comment"># 后进先出，栈</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LPOP k1</span><br><span class="line"><span class="string">&quot;f&quot;</span></span><br><span class="line"><span class="comment"># 先进先出，队列</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; RPOP k1</span><br><span class="line"><span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-LRANGE"><a href="#2-3-LRANGE" class="headerlink" title="2.3 LRANGE"></a>2.3 LRANGE</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help lrange</span><br><span class="line"></span><br><span class="line">  LRANGE key start stop</span><br><span class="line">  summary: Get a range of elements from a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: list</span><br></pre></td></tr></table></figure>
<p>LRANGE：返回列表 <code>key</code> 中指定区间内的元素，区间以偏移量 <code>start</code> 和 <code>stop</code> 指定。可以使用正负索引。</p>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此时链表排列顺序为 f e d c b a</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LPUSH k1 a b c d e f</span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LRANGE k1 <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;f&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;e&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时链表排列顺序为 a b c d e f</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; RPUSH k2 a b c d e f</span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LRANGE k2 <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;e&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;f&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-4-LINDEX-amp-LSET"><a href="#2-4-LINDEX-amp-LSET" class="headerlink" title="2.4 LINDEX&amp;LSET"></a>2.4 LINDEX&amp;LSET</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help lindex</span><br><span class="line"></span><br><span class="line">  LINDEX key index</span><br><span class="line">  summary: Get an element from a list by its index</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: list</span><br><span class="line">  </span><br><span class="line">127.0.0.1:6379&gt; help lset</span><br><span class="line"></span><br><span class="line">  LSET key index value</span><br><span class="line">  summary: Set the value of an element in a list by its index</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: list</span><br></pre></td></tr></table></figure>
<p>LINDEX：返回列表 <code>key</code> 中，下标为 <code>index</code> 的元素。将列表 <code>key</code> 下标为 <code>index</code> 的元素的值设置为 <code>value</code> 。</p>
<p>LSET：将列表 <code>key</code> 下标为 <code>index</code> 的元素的值设置为 <code>value</code> 。</p>
<ul>
<li>当 <code>index</code> 参数超出范围，或对一个空列表( <code>key</code> 不存在)进行 LSET 时，返回一个错误。</li>
</ul>
<p><strong>可以实现的数据结构</strong></p>
<ul>
<li><strong>数组：LINDEX+LSET，都是对下标进行操作</strong></li>
</ul>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此时链表排列顺序为 f(0) e(1) d(2) c(3) b(4) a(5)</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LPUSH k1 a b c d e f</span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"><span class="comment"># 取下标为2的元素</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LINDEX k1 <span class="number">2</span></span><br><span class="line"><span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="comment"># 取列表最后一位元素</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LINDEX k1 <span class="literal">-1</span></span><br><span class="line"><span class="string">&quot;a&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时链表排列顺序为 f(0) e(1) d(2) c(3) b(4) a(5)</span></span><br><span class="line"><span class="comment"># 设置下标为3的元素的值为X</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LSET k1 <span class="number">3</span> X</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LRANGE k1 <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;f&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;e&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;X&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-LREM-amp-LINSERT"><a href="#2-5-LREM-amp-LINSERT" class="headerlink" title="2.5 LREM&amp;LINSERT"></a>2.5 LREM&amp;LINSERT</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help lrem</span><br><span class="line"></span><br><span class="line">  LREM key count value</span><br><span class="line">  summary: Remove elements from a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: list</span><br><span class="line">  </span><br><span class="line">127.0.0.1:6379&gt; help linsert</span><br><span class="line"></span><br><span class="line">  LINSERT key BEFORE|AFTER pivot value</span><br><span class="line">  summary: Insert an element before or after another element in a list</span><br><span class="line">  since: 2.2.0</span><br><span class="line">  group: list</span><br></pre></td></tr></table></figure>
<p>LREM：根据参数 <code>count</code> 的值，移除列表中与参数 <code>value</code> 相等的元素。</p>
<p><code>count</code> 的值可以是以下几种：</p>
<ul>
<li><code>count &gt; 0</code> : 从表头开始向表尾搜索，移除与 <code>value</code> 相等的元素，数量为 <code>count</code> 。</li>
<li><code>count &lt; 0</code> : 从表尾开始向表头搜索，移除与 <code>value</code> 相等的元素，数量为 <code>count</code> 的绝对值。</li>
<li><code>count = 0</code> : 移除表中所有与 <code>value</code> 相等的值。</li>
</ul>
<p>LINSERT：将值 <code>value</code> 插入到列表 <code>key</code> 当中，位于值 <code>pivot</code> 之前或之后。</p>
<ul>
<li><p>当 <code>pivot</code> 不存在于列表 <code>key</code> 时，不执行任何操作。</p>
</li>
<li><p>当 <code>key</code> 不存在时， <code>key</code> 被视为空列表，不执行任何操作。</p>
</li>
<li><p>如果 <code>key</code> 不是列表类型，返回一个错误。</p>
</li>
</ul>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此时链表排列顺序为 7 a 6 e 5 a 4 c 3 b 2 a 1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LPUSH k3 <span class="number">1</span> a <span class="number">2</span> b <span class="number">3</span> c <span class="number">4</span> a <span class="number">5</span> e <span class="number">6</span> a <span class="number">7</span></span><br><span class="line">(integer) <span class="number">13</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LRANGE k3 <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"> <span class="number">1</span>) <span class="string">&quot;7&quot;</span></span><br><span class="line"> <span class="number">2</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"> <span class="number">3</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"> <span class="number">4</span>) <span class="string">&quot;e&quot;</span></span><br><span class="line"> <span class="number">5</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"> <span class="number">6</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"> <span class="number">7</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"> <span class="number">8</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"> <span class="number">9</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">10</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">11</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">12</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">13</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除链表元素，count&gt;0，从表头开始向表尾开始移除</span></span><br><span class="line"><span class="comment"># 此时链表排列顺序为 7 6 e 5 4 c 3 b 2 a 1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LREM k3 <span class="number">2</span> a</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LRANGE k3 <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"> <span class="number">1</span>) <span class="string">&quot;7&quot;</span></span><br><span class="line"> <span class="number">2</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"> <span class="number">3</span>) <span class="string">&quot;e&quot;</span></span><br><span class="line"> <span class="number">4</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"> <span class="number">5</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"> <span class="number">6</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"> <span class="number">7</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"> <span class="number">8</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"> <span class="number">9</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">10</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">11</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加链表元素</span></span><br><span class="line"><span class="comment"># 在元素6后面添加a，此时链表排列顺序为 7 6 a e 5 4 c 3 b 2 a 1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LINSERT k3 after <span class="number">6</span> a</span><br><span class="line">(integer) <span class="number">12</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LRANGE k3 <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"> <span class="number">1</span>) <span class="string">&quot;7&quot;</span></span><br><span class="line"> <span class="number">2</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"> <span class="number">3</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"> <span class="number">4</span>) <span class="string">&quot;e&quot;</span></span><br><span class="line"> <span class="number">5</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"> <span class="number">6</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"> <span class="number">7</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"> <span class="number">8</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"> <span class="number">9</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">10</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">11</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">12</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="comment"># 在元素3前面添加a，此时链表排列顺序为 7 6 a e 5 4 c a 3 b 2 a 1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LINSERT k3 before <span class="number">3</span> a</span><br><span class="line">(integer) <span class="number">13</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LRANGE k3 <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"> <span class="number">1</span>) <span class="string">&quot;7&quot;</span></span><br><span class="line"> <span class="number">2</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"> <span class="number">3</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"> <span class="number">4</span>) <span class="string">&quot;e&quot;</span></span><br><span class="line"> <span class="number">5</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"> <span class="number">6</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"> <span class="number">7</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"> <span class="number">8</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"> <span class="number">9</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">10</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">11</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">12</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">13</span>) <span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-6-LLEN"><a href="#2-6-LLEN" class="headerlink" title="2.6 LLEN"></a>2.6 LLEN</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help llen</span><br><span class="line"></span><br><span class="line">  LLEN key</span><br><span class="line">  summary: Get the length of a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: list</span><br></pre></td></tr></table></figure>
<p>LLEN：返回列表 <code>key</code> 的长度。</p>
<ul>
<li><p>如果 <code>key</code> 不存在，则 <code>key</code> 被解释为一个空列表，返回 <code>0</code> .</p>
</li>
<li><p>如果 <code>key</code> 不是列表类型，返回一个错误。</p>
</li>
</ul>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LRANGE k3 <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"> <span class="number">1</span>) <span class="string">&quot;7&quot;</span></span><br><span class="line"> <span class="number">2</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"> <span class="number">3</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"> <span class="number">4</span>) <span class="string">&quot;e&quot;</span></span><br><span class="line"> <span class="number">5</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"> <span class="number">6</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"> <span class="number">7</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"> <span class="number">8</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"> <span class="number">9</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">10</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">11</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">12</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">13</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="comment"># 返回k3的元素长度</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LLEN k3</span><br><span class="line">(integer) <span class="number">13</span></span><br></pre></td></tr></table></figure>
<h3 id="2-7-LTRIM"><a href="#2-7-LTRIM" class="headerlink" title="2.7 LTRIM"></a>2.7 LTRIM</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help ltrim</span><br><span class="line"></span><br><span class="line">  LTRIM key start stop</span><br><span class="line">  summary: Trim a list to the specified range</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: list</span><br></pre></td></tr></table></figure>
<p>LTRIM：对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</p>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LPUSH k1 <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></span><br><span class="line">(integer) <span class="number">9</span></span><br><span class="line"><span class="comment"># 此时链表排列顺序为 8(0) 7(1) 6(2) 5(3) 4(4) 3(5) 2(6) 1(7) 0(8)</span></span><br><span class="line"><span class="comment"># 将下标不在2-6的元素删除</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LTRIM k1 <span class="number">2</span> <span class="number">6</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LRANGE k1 <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;2&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-8-BLPOP-amp-BRPOP"><a href="#2-8-BLPOP-amp-BRPOP" class="headerlink" title="2.8 BLPOP&amp;BRPOP"></a>2.8 BLPOP&amp;BRPOP</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help blpop</span><br><span class="line"></span><br><span class="line">  BLPOP key [key ...] timeout</span><br><span class="line">  summary: Remove and get the first element in a list, or block until one is available</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: list</span><br><span class="line">  </span><br><span class="line">127.0.0.1:6379&gt; help brpop</span><br><span class="line"></span><br><span class="line">  BRPOP key [key ...] timeout</span><br><span class="line">  summary: Remove and get the last element in a list, or block until one is available</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: list</span><br></pre></td></tr></table></figure>
<p>BLPOP：列表的阻塞式(blocking)弹出原语，超时参数 <code>timeout</code> 接受一个以秒为单位的数字作为值。超时参数设为 <code>0</code> 表示阻塞时间可以无限期延长(block indefinitely) 。</p>
<ul>
<li><p>它是 LPOP 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BLPOP 命令阻塞，直到等待超时或发现可弹出元素为止。</p>
</li>
<li><p>当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的头元素。</p>
</li>
<li><p>如果所有给定 key 都不存在或包含空列表，那么 BLPOP 命令将阻塞连接，直到等待超时，或有另一个客户端对给定 key 的任意一个执行 LPUSH 或 RPUSH 命令为止。</p>
</li>
</ul>
<p>可以实现的数据结构：</p>
<ul>
<li><strong>阻塞、单播队列，FIFO：BLPOP</strong></li>
</ul>
<p>案例：</p>
<p>client1阻塞等待：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 无限期阻塞</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; BLPOP b1 <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>client2阻塞等待:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 无限期阻塞</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; BLPOP b1 <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>client3</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># client3向b1添加&quot;hello&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; RPUSH b1 hello</span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>此时client1接收到值</p>
<img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200707220037491.png"  align="left"/>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; BLPOP b1 <span class="number">0</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;b1&quot;</span>                          <span class="comment"># 这里被 push 的是 b1</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;hello&quot;</span>            			 <span class="comment"># 被弹出的值</span></span><br><span class="line">(<span class="number">26.97</span>s)                         <span class="comment"># 等待的秒数</span></span><br></pre></td></tr></table></figure>
<p>此时client2还在阻塞</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 无限期阻塞</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; BLPOP b1 <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>client3再向b1添加值</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># client3向b1添加&quot;world&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; RPUSH b1 world</span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>此时client2</p>
<img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200707220218395.png"  align="left"/>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; BLPOP b1 <span class="number">0</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;b1&quot;</span>                          <span class="comment"># 这里被 push 的是 b1</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;world&quot;</span>            			 <span class="comment"># 被弹出的值</span></span><br><span class="line">(<span class="number">35.33</span>s)                         <span class="comment"># 等待的秒数</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Lists应用场景"><a href="#3-Lists应用场景" class="headerlink" title="3 Lists应用场景"></a>3 Lists应用场景</h2><p>官网：</p>
<p>正如你可以从上面的例子中猜到的，list可被用来实现聊天系统。还可以作为不同进程间传递消息的队列。关键是，你可以每次都以原先添加的顺序访问数据。这不需要任何SQL ORDER BY 操作，将会非常快，也会很容易扩展到百万级别元素的规模。</p>
<p>例如在评级系统中，比如社会化新闻网站 reddit.com，你可以把每个新提交的链接添加到一个list，用LRANGE可简单的对结果分页。</p>
<p>在博客引擎实现中，你可为每篇日志设置一个list，在该list中推入博客评论，等等。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 基本数据类型 Sets</title>
    <url>/2020/12/26/Redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-Sets/</url>
    <content><![CDATA[<h1 id="Redis-Sets"><a href="#Redis-Sets" class="headerlink" title="Redis Sets"></a>Redis Sets</h1><h2 id="1-Sets简介"><a href="#1-Sets简介" class="headerlink" title="1 Sets简介"></a>1 Sets简介</h2><a id="more"></a>

<p>Redis Set 是 String 的无序排列。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p>
<p>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p>
<p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>
<h2 id="2-Sets命令"><a href="#2-Sets命令" class="headerlink" title="2 Sets命令"></a>2 Sets命令</h2><h3 id="2-1-help-set"><a href="#2-1-help-set" class="headerlink" title="2.1 help @set"></a>2.1 help @set</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @set</span><br><span class="line"></span><br><span class="line">  SADD key member [member ...]</span><br><span class="line">  summary: Add one or more members to a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SCARD key</span><br><span class="line">  summary: Get the number of members in a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SDIFF key [key ...]</span><br><span class="line">  summary: Subtract multiple sets</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SDIFFSTORE destination key [key ...]</span><br><span class="line">  summary: Subtract multiple sets and store the resulting set in a key</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SINTER key [key ...]</span><br><span class="line">  summary: Intersect multiple sets</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SINTERSTORE destination key [key ...]</span><br><span class="line">  summary: Intersect multiple sets and store the resulting set in a key</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SISMEMBER key member</span><br><span class="line">  summary: Determine if a given value is a member of a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SMEMBERS key</span><br><span class="line">  summary: Get all the members in a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SMOVE source destination member</span><br><span class="line">  summary: Move a member from one set to another</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SPOP key [count]</span><br><span class="line">  summary: Remove and return one or multiple random members from a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SRANDMEMBER key [count]</span><br><span class="line">  summary: Get one or multiple random members from a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SREM key member [member ...]</span><br><span class="line">  summary: Remove one or more members from a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SSCAN key cursor [MATCH pattern] [COUNT count]</span><br><span class="line">  summary: Incrementally iterate Set elements</span><br><span class="line">  since: 2.8.0</span><br><span class="line"></span><br><span class="line">  SUNION key [key ...]</span><br><span class="line">  summary: Add multiple sets</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SUNIONSTORE destination key [key ...]</span><br><span class="line">  summary: Add multiple sets and store the resulting set in a key</span><br><span class="line">  since: 1.0.0</span><br></pre></td></tr></table></figure>
<h3 id="2-2-SADD-amp-SMEMBERS"><a href="#2-2-SADD-amp-SMEMBERS" class="headerlink" title="2.2 SADD&amp;SMEMBERS"></a>2.2 SADD&amp;SMEMBERS</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help sadd</span><br><span class="line"></span><br><span class="line">  SADD key member [member ...]</span><br><span class="line">  summary: Add one or more members to a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: set</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help smembers</span><br><span class="line"></span><br><span class="line">  SMEMBERS key</span><br><span class="line">  summary: Get all the members in a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: set</span><br></pre></td></tr></table></figure>
<p>SADD：将一个或多个 <code>member</code> 元素加入到集合 <code>key</code> 当中，已经存在于集合的 <code>member</code> 元素将被忽略。</p>
<ul>
<li><p>假如 <code>key</code> 不存在，则创建一个只包含 <code>member</code> 元素作成员的集合。</p>
</li>
<li><p>当 <code>key</code> 不是集合类型时，返回一个错误。</p>
</li>
</ul>
<p>SMEMBERS：返回集合 <code>key</code> 中的所有成员。</p>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 向k1添加重复元素</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SADD k1 sean tom peter tom ooxx ooxx</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="comment"># k1取出所有元素</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SMEMBERS k1</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;ooxx&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;peter&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;tom&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;sean&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-SREM"><a href="#2-3-SREM" class="headerlink" title="2.3 SREM"></a>2.3 SREM</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help srem</span><br><span class="line"></span><br><span class="line">  SREM key member [member ...]</span><br><span class="line">  summary: Remove one or more members from a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: set</span><br></pre></td></tr></table></figure>
<p>SREM：移除集合 <code>key</code> 中的一个或多个 <code>member</code> 元素，不存在的 <code>member</code> 元素会被忽略。</p>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># k1取出所有元素</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SMEMBERS k1</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;ooxx&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;peter&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;tom&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;sean&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SREM k1 ooxx</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SMEMBERS k1</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;tom&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;sean&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;peter&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-4-SINTER-amp-SUNION-amp-SDIFF"><a href="#2-4-SINTER-amp-SUNION-amp-SDIFF" class="headerlink" title="2.4 SINTER&amp;SUNION&amp;SDIFF"></a>2.4 SINTER&amp;SUNION&amp;SDIFF</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help sinter</span><br><span class="line"></span><br><span class="line">  SINTER key [key ...]</span><br><span class="line">  summary: Intersect multiple sets</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: set</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help sinterstore</span><br><span class="line"></span><br><span class="line">  SINTERSTORE destination key [key ...]</span><br><span class="line">  summary: Intersect multiple sets and store the resulting set in a key</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: set</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help sunion</span><br><span class="line"></span><br><span class="line">  SUNION key [key ...]</span><br><span class="line">  summary: Add multiple sets</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: set</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help sdiff</span><br><span class="line"></span><br><span class="line">  SDIFF key [key ...]</span><br><span class="line">  summary: Subtract multiple sets</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: set</span><br></pre></td></tr></table></figure>
<p>SINTER：返回一个集合的全部成员，该集合是所有给定集合的交集。</p>
<p>SINTERSTORE：这个命令类似于 SINTER 命令，但它将结果保存到 <code>destination</code> 集合，而不是简单地返回结果集。</p>
<ul>
<li><p>如果 <code>destination</code> 集合已经存在，则将其覆盖。</p>
</li>
<li><p><code>destination</code> 可以是 <code>key</code> 本身。</p>
</li>
</ul>
<p>SUNION：返回一个集合的全部成员，该集合是所有给定集合的并集。</p>
<p>SUNIONSTORE：这个命令类似于 SUNION 命令，但它将结果保存到 <code>destination</code> 集合，而不是简单地返回结果集。</p>
<ul>
<li><p>如果 <code>destination</code> 已经存在，则将其覆盖。</p>
</li>
<li><p><code>-destination</code> 可以是 <code>key</code> 本身。</p>
</li>
</ul>
<p>SDIFF：返回一个集合的全部成员，该集合是所有给定集合之间的差集。</p>
<p>SDIFFSTORE：这个命令的作用和 SDIFF 类似，但它将结果保存到 <code>destination</code> 集合，而不是简单地返回结果集。</p>
<ul>
<li><p>如果 <code>destination</code> 集合已经存在，则将其覆盖。</p>
</li>
<li><p><code>destination</code> 可以是 <code>key</code> 本身。</p>
</li>
</ul>
<p>案例：</p>
<p>交集</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SADD k2 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SADD k3 <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"><span class="comment"># k3与k3交集</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SINTER k2 k3</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将交集结果存入dest</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SINTERSTORE dest k2 k3</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SMEMBERS dest</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;6&quot;</span></span><br></pre></td></tr></table></figure>
<p>并集</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SUNION k2 k3</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"><span class="number">7</span>) <span class="string">&quot;7&quot;</span></span><br><span class="line"><span class="number">8</span>) <span class="string">&quot;8&quot;</span></span><br></pre></td></tr></table></figure>
<p>差集</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SDIFF k2 k3</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SDIFF k3 k2</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;7&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;8&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-SRANDMEMBER-amp-SPOP"><a href="#2-5-SRANDMEMBER-amp-SPOP" class="headerlink" title="2.5 SRANDMEMBER&amp;SPOP"></a>2.5 SRANDMEMBER&amp;SPOP</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help srandmember</span><br><span class="line"></span><br><span class="line">  SRANDMEMBER key [count]</span><br><span class="line">  summary: Get one or multiple random members from a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: set</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help spop</span><br><span class="line"></span><br><span class="line">  SPOP key [count]</span><br><span class="line">  summary: Remove and return one or multiple random members from a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: set</span><br></pre></td></tr></table></figure>
<p>SRANDMEMBER：如果命令执行时，只提供了 <code>key</code> 参数，那么返回集合中的一个随机元素。</p>
<p>从 Redis 2.6 版本开始， SRANDMEMBER 命令接受可选的 <code>count</code> 参数：</p>
<ul>
<li>如果 <code>count</code> 为正数，且小于集合基数，那么命令返回一个包含 <code>count</code> 个元素的数组，数组中的元素<strong>各不相同</strong>。如果 <code>count</code> 大于等于集合基数，那么返回整个集合。</li>
<li>如果 <code>count</code> 为负数，那么命令返回一个数组，数组中的元素<strong>可能会重复出现多次</strong>，而数组的长度为 <code>count</code> 的绝对值。</li>
</ul>
<p>SPOP：移除并返回集合中的一个随机元素。</p>
<p>案例：</p>
<p>SRANDMEMBER</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SADD k2 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"><span class="comment"># count正数：取出一个去重的结果集（不能超过已有集）</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SRANDMEMBER k2 <span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="comment"># count负数：取出一个带重复的结果集</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SRANDMEMBER k2 <span class="literal">-3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"><span class="comment"># count为0，不返回</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SRANDMEMBER k2 <span class="number">0</span></span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SRANDMEMBER k2 <span class="number">10</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SRANDMEMBER k2 <span class="literal">-10</span></span><br><span class="line"> <span class="number">1</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"> <span class="number">2</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"> <span class="number">3</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"> <span class="number">4</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"> <span class="number">5</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"> <span class="number">6</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"> <span class="number">7</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"> <span class="number">8</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"> <span class="number">9</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">10</span>) <span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure>
<p>SPOP</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SPOP k2 <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SPOP k2 <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SPOP k2 <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SPOP k2 <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SPOP k2 <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SPOP k2 <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SPOP k2 <span class="number">1</span></span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure>
<h2 id="3-Sets使用场景"><a href="#3-Sets使用场景" class="headerlink" title="3 Sets使用场景"></a>3 Sets使用场景</h2><ol>
<li><p>随机抽奖，一次出结果</p>
<p>情景一 人多奖品少：3个奖品，10个人抽奖，抽3个并且没有重复，使用<code>SRANDMEMBER key 3</code></p>
<p>情景二 人少奖品多：10个奖品，3个人抽奖，抽10个可以有重复，使用<code>SRANDMEMBER key -10</code></p>
</li>
<li><p>随机抽奖，一次一个</p>
<p>奖品分为一、二、三等奖，每次只抽一个人，SPOP key 1</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 基本数据类型 Sorted Sets</title>
    <url>/2020/12/26/Redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-Sorted-Sets/</url>
    <content><![CDATA[<h1 id="Redis-Sorted-Sets"><a href="#Redis-Sorted-Sets" class="headerlink" title="Redis Sorted Sets"></a>Redis Sorted Sets</h1><h2 id="1-Sorted-Sets简介"><a href="#1-Sorted-Sets简介" class="headerlink" title="1 Sorted Sets简介"></a>1 Sorted Sets简介</h2><a id="more"></a>

<p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。</p>
<p>不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>有序集合的成员是唯一的,但分数(score)却可以重复。</p>
<p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>
<h2 id="2-Sorted-Sets命令"><a href="#2-Sorted-Sets命令" class="headerlink" title="2 Sorted Sets命令"></a>2 Sorted Sets命令</h2><h3 id="2-1-help-sorted-set"><a href="#2-1-help-sorted-set" class="headerlink" title="2.1 help @sorted_set"></a>2.1 help @sorted_set</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @sorted_set</span><br><span class="line"></span><br><span class="line">  ZADD key [NX|XX] [CH] [INCR] score member [score member ...]</span><br><span class="line">  summary: Add one or more members to a sorted set, or update its score if it already exists</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  ZCARD key</span><br><span class="line">  summary: Get the number of members in a sorted set</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  ZCOUNT key min max</span><br><span class="line">  summary: Count the members in a sorted set with scores within the given values</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  ZINCRBY key increment member</span><br><span class="line">  summary: Increment the score of a member in a sorted set</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]</span><br><span class="line">  summary: Intersect multiple sorted sets and store the resulting sorted set in a new key</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  ZLEXCOUNT key min max</span><br><span class="line">  summary: Count the number of members in a sorted set between a given lexicographical range</span><br><span class="line">  since: 2.8.9</span><br><span class="line"></span><br><span class="line">  ZRANGE key start stop [WITHSCORES]</span><br><span class="line">  summary: Return a range of members in a sorted set, by index</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  ZRANGEBYLEX key min max [LIMIT offset count]</span><br><span class="line">  summary: Return a range of members in a sorted set, by lexicographical range</span><br><span class="line">  since: 2.8.9</span><br><span class="line"></span><br><span class="line">  ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br><span class="line">  summary: Return a range of members in a sorted set, by score</span><br><span class="line">  since: 1.0.5</span><br><span class="line"></span><br><span class="line">  ZRANK key member</span><br><span class="line">  summary: Determine the index of a member in a sorted set</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  ZREM key member [member ...]</span><br><span class="line">  summary: Remove one or more members from a sorted set</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  ZREMRANGEBYLEX key min max</span><br><span class="line">  summary: Remove all members in a sorted set between the given lexicographical range</span><br><span class="line">  since: 2.8.9</span><br><span class="line"></span><br><span class="line">  ZREMRANGEBYRANK key start stop</span><br><span class="line">  summary: Remove all members in a sorted set within the given indexes</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  ZREMRANGEBYSCORE key min max</span><br><span class="line">  summary: Remove all members in a sorted set within the given scores</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  ZREVRANGE key start stop [WITHSCORES]</span><br><span class="line">  summary: Return a range of members in a sorted set, by index, with scores ordered from high to low</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  ZREVRANGEBYLEX key max min [LIMIT offset count]</span><br><span class="line">  summary: Return a range of members in a sorted set, by lexicographical range, ordered from higher to lower strings.</span><br><span class="line">  since: 2.8.9</span><br><span class="line"></span><br><span class="line">  ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</span><br><span class="line">  summary: Return a range of members in a sorted set, by score, with scores ordered from high to low</span><br><span class="line">  since: 2.2.0</span><br><span class="line"></span><br><span class="line">  ZREVRANK key member</span><br><span class="line">  summary: Determine the index of a member in a sorted set, with scores ordered from high to low</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  ZSCAN key cursor [MATCH pattern] [COUNT count]</span><br><span class="line">  summary: Incrementally iterate sorted sets elements and associated scores</span><br><span class="line">  since: 2.8.0</span><br><span class="line"></span><br><span class="line">  ZSCORE key member</span><br><span class="line">  summary: Get the score associated with the given member in a sorted set</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]</span><br><span class="line">  summary: Add multiple sorted sets and store the resulting sorted set in a new key</span><br><span class="line">  since: 2.0.0</span><br></pre></td></tr></table></figure>
<h3 id="2-2-ZADD"><a href="#2-2-ZADD" class="headerlink" title="2.2 ZADD"></a>2.2 ZADD</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help zadd</span><br><span class="line"></span><br><span class="line">  ZADD key [NX|XX] [CH] [INCR] score member [score member ...]</span><br><span class="line">  summary: Add one or more members to a sorted set, or update its score if it already exists</span><br><span class="line">  since: 1.2.0</span><br><span class="line">  group: sorted_set</span><br></pre></td></tr></table></figure>
<p>ZADD：将一个或多个 <code>member</code> 元素及其 <code>score</code> 值加入到有序集 <code>key</code> 当中。</p>
<ul>
<li>如果某个 <code>member</code> 已经是有序集的成员，那么更新这个 <code>member</code> 的 <code>score</code> 值，并通过重新插入这个 <code>member</code> 元素，来保证该 <code>member</code> 在正确的位置上。</li>
<li><code>score</code> 值可以是整数值或双精度浮点数。</li>
</ul>
<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># apple 8，banana 2，orange 3</span><br><span class="line">127.0.0.1:6379&gt; ZADD k1 8 apple 2 banana 3 orange</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>
<h3 id="2-3-ZRANGE-amp-ZRANGEBYSCORE-amp-ZREVRANGE"><a href="#2-3-ZRANGE-amp-ZRANGEBYSCORE-amp-ZREVRANGE" class="headerlink" title="2.3 ZRANGE&amp;ZRANGEBYSCORE&amp;ZREVRANGE"></a>2.3 ZRANGE&amp;ZRANGEBYSCORE&amp;ZREVRANGE</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help zrange</span><br><span class="line"></span><br><span class="line">  ZRANGE key start stop [WITHSCORES]</span><br><span class="line">  summary: Return a range of members in a sorted set, by index</span><br><span class="line">  since: 1.2.0</span><br><span class="line">  group: sorted_set</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help zrangebyscore</span><br><span class="line"></span><br><span class="line">  ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br><span class="line">  summary: Return a range of members in a sorted set, by score</span><br><span class="line">  since: 1.0.5</span><br><span class="line">  group: sorted_set</span><br></pre></td></tr></table></figure>
<p><strong>取值相关命令</strong></p>
<p>ZRANGE：返回有序集 <code>key</code> 中，指定区间内的成员。</p>
<ul>
<li>其中成员的位置按 <code>score</code> 值递增(从小到大)来排序。</li>
<li>具有相同 <code>score</code> 值的成员按字典序来排列。</li>
<li>可以通过使用 <code>WITHSCORES</code> 选项，来让成员和它的 <code>score</code> 值一并返回，返回列表以 <code>value1,score1, ..., valueN,scoreN</code> 的格式表示。</li>
</ul>
<p>ZRANGEBYSCORE：返回有序集 <code>key</code> 中，所有 <code>score</code> 值介于 <code>min</code> 和 <code>max</code> 之间(包括等于 <code>min</code> 或 <code>max</code> )的成员。有序集成员按 <code>score</code> 值递增(从小到大)次序排列。</p>
<ul>
<li>具有相同 <code>score</code> 值的成员按字典序来排列(该属性是有序集提供的，不需要额外的计算)。</li>
<li>可选的 <code>WITHSCORES</code> 参数决定结果集是单单返回有序集的成员，还是将有序集成员及其 <code>score</code> 值一起返回。</li>
</ul>
<p>ZREVRANGE：ZREVRANGE返回有序集 <code>key</code> 中，指定区间内的成员。</p>
<ul>
<li>其中成员的位置按 <code>score</code> 值递减(从大到小)来排列。</li>
<li>具有相同 <code>score</code> 值的成员按字典序的逆序EVRANGE 命令的其他方面和 ZRANGE 命令一样。</li>
</ul>
<p>ZREVRANGEBYSCORE：返回有序集 <code>key</code> 中， <code>score</code> 值介于 <code>max</code> 和 <code>min</code> 之间(默认包括等于 <code>max</code> 或 <code>min</code> )的所有的成员。有序集成员按 <code>score</code> 值递减(从大到小)的次序排列。</p>
<ul>
<li>具有相同 <code>score</code> 值的成员按字典序的逆序排列。</li>
<li>除了成员按 <code>score</code> 值递减的次序排列这一点外，ZREVRANGEBYSCORE 命令的其他方面和ZRANGEBYSCORE命令一样。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ZRANGE 按照 score 正序排列</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE k1 0 -1</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;orange&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line"># 使用 WITHSCORES，成员和 score 一起返回</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE k1 0 -1 withscores</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;orange&quot;</span><br><span class="line">4) &quot;3&quot;</span><br><span class="line">5) &quot;apple&quot;</span><br><span class="line">6) &quot;8&quot;</span><br><span class="line"># 使用下标</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE k1 -2 -1</span><br><span class="line">1) &quot;orange&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line"></span><br><span class="line"># 返回score 3~8区间的值</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE k1 3 8</span><br><span class="line">1) &quot;orange&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line"></span><br><span class="line"># ZRANGE 按照 score 逆序排列</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE k1 0 1</span><br><span class="line">1) &quot;apple&quot;</span><br><span class="line">2) &quot;orange&quot;</span><br><span class="line"># ZREVRANGEBYSCORE 逆序排列</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGEBYSCORE k1 8 3</span><br><span class="line">1) &quot;apple&quot;</span><br><span class="line">2) &quot;orange&quot;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-ZSCORE"><a href="#2-4-ZSCORE" class="headerlink" title="2.4 ZSCORE"></a>2.4 ZSCORE</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help zscore</span><br><span class="line"></span><br><span class="line">  ZSCORE key member</span><br><span class="line">  summary: Get the score associated with the given member in a sorted set</span><br><span class="line">  since: 1.2.0</span><br><span class="line">  group: sorted_set</span><br></pre></td></tr></table></figure>
<p>ZSCORE：返回有序集 <code>key</code> 中，成员 <code>member</code> 的 <code>score</code> 值。</p>
<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZSCORE k1 apple</span><br><span class="line">&quot;8&quot;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-ZRANK-amp-ZREVRANK"><a href="#2-5-ZRANK-amp-ZREVRANK" class="headerlink" title="2.5 ZRANK&amp;ZREVRANK"></a>2.5 ZRANK&amp;ZREVRANK</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help zrank</span><br><span class="line"></span><br><span class="line">  ZRANK key member</span><br><span class="line">  summary: Determine the index of a member in a sorted set</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: sorted_set</span><br></pre></td></tr></table></figure>
<p>ZRANK：返回有序集 <code>key</code> 中成员 <code>member</code> 的排名。其中有序集成员按 <code>score</code> 值递增(从小到大)顺序排列。</p>
<p>ZREVRANK：返回有序集 <code>key</code> 中成员 <code>member</code> 的排名。其中有序集成员按 <code>score</code> 值递减(从大到小)排序。</p>
<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZRANK k1 apple</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>
<h3 id="2-6-ZINCRBY"><a href="#2-6-ZINCRBY" class="headerlink" title="2.6 ZINCRBY"></a>2.6 ZINCRBY</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help zincrby</span><br><span class="line"></span><br><span class="line">  ZINCRBY key increment member</span><br><span class="line">  summary: Increment the score of a member in a sorted set</span><br><span class="line">  since: 1.2.0</span><br><span class="line">  group: sorted_set</span><br></pre></td></tr></table></figure>
<p>ZINCRBY：为有序集 <code>key</code> 的成员 <code>member</code> 的 <code>score</code> 值加上增量 <code>increment</code> 。</p>
<ul>
<li>可以通过传递一个负数值 <code>increment</code> ，让 <code>score</code> 减去相应的值，比如 <code>ZINCRBY key -5 member</code> ，就是让 <code>member</code> 的 <code>score</code> 值减去 <code>5</code> 。</li>
</ul>
<p>算数运算</p>
<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZINCRBY k1 2.5 banana</span><br><span class="line">&quot;4.5&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE k1 0 -1 withscores</span><br><span class="line">1) &quot;orange&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;banana&quot;</span><br><span class="line">4) &quot;4.5&quot;</span><br><span class="line">5) &quot;apple&quot;</span><br><span class="line">6) &quot;8&quot;</span><br></pre></td></tr></table></figure>
<h3 id="2-7-ZUNIONSTORE-amp-ZINTERSTORE"><a href="#2-7-ZUNIONSTORE-amp-ZINTERSTORE" class="headerlink" title="2.7 ZUNIONSTORE&amp;ZINTERSTORE"></a>2.7 ZUNIONSTORE&amp;<strong>ZINTERSTORE</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help zunionstore</span><br><span class="line"></span><br><span class="line">  ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]</span><br><span class="line">  summary: Add multiple sorted sets and store the resulting sorted set in a new key</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: sorted_set</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help zinterstore</span><br><span class="line"></span><br><span class="line">  ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]</span><br><span class="line">  summary: Intersect multiple sorted sets and store the resulting sorted set in a new key</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: sorted_set</span><br></pre></td></tr></table></figure>
<p>ZUNIONSTORE：计算给定的一个或多个有序集的并集，其中给定 <code>key</code> 的数量必须以 <code>numkeys</code> 参数指定，并将该并集(结果集)储存到 <code>destination</code> 。</p>
<ul>
<li><p>默认情况下，结果集中某个成员的 <code>score</code> 值是所有给定集下该成员 <code>score</code> 值之和 。</p>
</li>
<li><p><strong>WEIGHTS</strong></p>
<p>使用 <code>WEIGHTS</code> 选项，你可以为 <em>每个</em> 给定有序集 <em>分别</em> 指定一个乘法因子(multiplication factor)，每个给定有序集的所有成员的 <code>score</code> 值在传递给聚合函数(aggregation function)之前都要先乘以该有序集的因子。</p>
<p>如果没有指定 <code>WEIGHTS</code> 选项，乘法因子默认设置为 <code>1</code> 。</p>
</li>
<li><p><strong>AGGREGATE</strong></p>
<p>使用 <code>AGGREGATE</code> 选项，你可以指定并集的结果集的聚合方式。</p>
<p>默认使用的参数 <code>SUM</code> ，可以将所有集合中某个成员的 <code>score</code> 值之 <em>和</em> 作为结果集中该成员的 <code>score</code> 值；使用参数 <code>MIN</code> ，可以将所有集合中某个成员的 <em>最小</em> <code>score</code> 值作为结果集中该成员的 <code>score</code> 值；而参数 <code>MAX</code> 则是将所有集合中某个成员的最大 <code>score</code> 值作为结果集中该成员的 <code>score</code> 值。</p>
</li>
</ul>
<p>ZINTERSTORE ：计算给定的一个或多个有序集的交集，其中给定 <code>key</code> 的数量必须以 <code>numkeys</code> 参数指定，并将该交集(结果集)储存到 <code>destination</code> 。</p>
<ul>
<li>默认情况下，结果集中某个成员的 <code>score</code> 值是所有给定集下该成员 <code>score</code> 值之和.</li>
</ul>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设有两个学科的考试分数</span></span><br><span class="line"><span class="comment"># 第一科分数</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZADD k1 <span class="number">80</span> tom <span class="number">60</span> sean <span class="number">70</span> baby</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="comment"># 第二科分数</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZADD k2 <span class="number">60</span> tom <span class="number">100</span> sean <span class="number">40</span> peter</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="comment"># numkeys为2，k1和k2进行整合</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZUNIONSTORE unkey <span class="number">2</span> k1 k2</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="comment"># 查看整合后的分值,默认SUM相加，正序排列</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZRANGE unkey <span class="number">0</span> <span class="literal">-1</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;peter&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;40&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;baby&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;70&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;tom&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;140&quot;</span></span><br><span class="line"><span class="number">7</span>) <span class="string">&quot;sean&quot;</span></span><br><span class="line"><span class="number">8</span>) <span class="string">&quot;160&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试权重，k1权重为1，k2权重为0.5</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZUNIONSTORE unkey1 <span class="number">2</span> k1 k2 WEIGHTS <span class="number">1</span> <span class="number">0.5</span></span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="comment"># 例如sean分数：60+100*0.5=110</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZRANGE unkey1 <span class="number">0</span> <span class="literal">-1</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;peter&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;baby&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;70&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;sean&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;110&quot;</span></span><br><span class="line"><span class="number">7</span>) <span class="string">&quot;tom&quot;</span></span><br><span class="line"><span class="number">8</span>) <span class="string">&quot;110&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试聚合，使用max</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZUNIONSTORE unkey2 <span class="number">2</span> k1 k2 aggregate max</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="comment"># 返回k1、k2分数最大值</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZRANGE unkey2 <span class="number">0</span> <span class="literal">-1</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;peter&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;40&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;baby&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;70&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;tom&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;80&quot;</span></span><br><span class="line"><span class="number">7</span>) <span class="string">&quot;sean&quot;</span></span><br><span class="line"><span class="number">8</span>) <span class="string">&quot;100&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 并集测试，不存在的值直接删掉</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZINTERSTORE interkey <span class="number">2</span> k1 k2</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZRANGE interkey <span class="number">0</span> <span class="literal">-1</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;tom&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;140&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;sean&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;160&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Sorted-Sets使用场景"><a href="#3-Sorted-Sets使用场景" class="headerlink" title="3 Sorted Sets使用场景"></a>3 Sorted Sets使用场景</h2><p>歌曲排行榜前十名</p>
<p>歌曲排行榜，第一天上线，所有的歌曲得分值都是0，排行榜按什么排名？可能是播放量、下载数、点播量其中一个，是正序还是倒序的？</p>
<p>可以使用Redis的ZINCYBY，某一首歌播放了一次，就加1，也可以非常快的使用ZRANGE&amp;ZREVRANGE正序或倒序排序。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 序列化器</title>
    <url>/2020/12/26/Redis-%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/</url>
    <content><![CDATA[<h1 id="Redis-序列化器"><a href="#Redis-序列化器" class="headerlink" title="Redis 序列化器"></a>Redis 序列化器</h1><a id="more"></a>

<p>从框架的角度来看，Redis 中存储的数据仅为字节。尽管 Redis 本身支持各种类型，但在大多数情况下，它们是指数据的存储方式，而不是其表示的内容。是否将信息转换为字符串或其他对象由用户自己决定。</p>
<p>Spring Data 中，Redis 可以通过<code>org.springframework.data.redis.serializer</code> 包处理用户（自定义）类型和原始数据之间的转换（反之亦然）。</p>
<p>该软件包包含两种类型的序列化器，顾名思义，它们负责序列化过程：</p>
<ul>
<li>基于的两路串行器的<code>RedisSerializer</code>。</li>
<li>使用 <code>RedisElementReader</code> 和 <code>RedisElementWriter</code> 的元素读取器和元素写入器。</li>
</ul>
<p>两者之间的主要区别在于，<code>RedisSerializer</code> 序列化为 <code>byte[]</code>，而 readers 和 writers 序列化为<code>ByteBuffer</code>。</p>
<p>接口的截图：</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201226225711767.png" alt="image-20201226225711767"></p>
<p>Spring Data Redis 的序列化器提供了多种实现方式：</p>
<ul>
<li>GenericToStringSerializer：使用 Spring 转换服务进行序列化。</li>
<li>GenericJackson2JsonRedisSerializer：将对象序列化为 Json</li>
<li>Jackson2JsonRedisSerializer：使用 Jackson2，将对象序列化为 Json。</li>
<li>JdkSerializationRedisSerializer：使用 Java 序列化，<code>RedisCache</code> 和 <code>RedisTemplate</code> 默认使用此方式。</li>
<li>OxmSerializer：使用 Spring O/X 映射的编排器和解排器实现序列化，用于 XML 序列化。</li>
<li>StringRedisSerializer：序列化 String 类型的 key 和 value。</li>
</ul>
<p>存储格式不仅限于 values，也可以无限制地用于 keys, values 或者 hashes。</p>
<h2 id="1-默认序列化器"><a href="#1-默认序列化器" class="headerlink" title="1 默认序列化器"></a>1 默认序列化器</h2><p> <code>RedisTemplate</code> 默认使用 <code>JdkSerializationRedisSerializer</code>，<code>StringRedisTemplate </code> 默认使用 <code>StringRedisSerializer</code></p>
<h2 id="2-自定义序列化器"><a href="#2-自定义序列化器" class="headerlink" title="2 自定义序列化器"></a>2 自定义序列化器</h2><p>如果在实际项目中上述序列化器中没有符合需求的序列化器，或者不使用默认的序列化器，那么可以自定义序列化器。</p>
<p>例如，使用  <code>RedisTemplate</code>  时，希望 key 是 String 类型，而 value 是 自定义的 Person 类且序列化为 JSON，就可以自定义 key 和 value 的序列化器。</p>
<p>配置代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Person&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory cf)</span></span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Person&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(cf);</span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        redisTemplate.setValueSerializer(<span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(Person.class));</span><br><span class="line">        <span class="keyword">return</span>  redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 持久化</title>
    <url>/2020/12/27/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h1><a id="more"></a>

<p>以下文档来自于Redis中文官网：<a href="http://redis.cn/topics/persistence.html">http://redis.cn/topics/persistence.html</a></p>
<h2 id="1-Redis持久化方式"><a href="#1-Redis持久化方式" class="headerlink" title="1 Redis持久化方式"></a>1 Redis持久化方式</h2><p>Redis是内存的数据库，掉电易失，所以需要数据需要持久化。</p>
<p>Redis提供了不同级别的持久化方式：</p>
<ul>
<li>RDB：在指定的时间间隔能对你的数据进行快照存储。</li>
<li>AOF：记录每次对服务器的写操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF 命令以 Redis 协议追加保存每次的写操作到文件的末尾，Redis 还能对 AOF 文件进行后台重写，使得 AOF 的体积不至于过大。</li>
<li>也可以同时开启两种持久化方式，在这种情况下，当 Redis 重启的时候会有限载入 AOF 文件来恢复原始的数据，因为通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整</li>
</ul>
<h2 id="2-RDB（Redis-DataBase）"><a href="#2-RDB（Redis-DataBase）" class="headerlink" title="2 RDB（Redis DataBase）"></a>2 RDB（Redis DataBase）</h2><h3 id="2-1-RDB-优点"><a href="#2-1-RDB-优点" class="headerlink" title="2.1 RDB 优点"></a>2.1 RDB 优点</h3><ul>
<li>RDB 是一个非常紧凑的文件，它保存了某个时间点的数据集，非常适用于数据集的备份，比如可以在每个小时保存一下过去 24 小时内的数据，同时每天保存过去 30 天的数据，这样即使出了问题也可以根据需求恢复到不同版本的数据集。</li>
<li>RDB 是一个紧凑的单一文件，很方便传送到另一个远端数据中心，非常适用于灾难恢复。</li>
<li>RDB 在保存文件时父进程唯一需要做的就是 fork 出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他 IO 操作，所以 RDB 持久化方式可以最大化 Redis 性能。</li>
<li>与 AOF 相比，在恢复大的数据集的时候，RDB 方式会更快一些。</li>
</ul>
<h3 id="2-2-RDB-缺点"><a href="#2-2-RDB-缺点" class="headerlink" title="2.2 RDB 缺点"></a>2.2 RDB 缺点</h3><ul>
<li>如果你希望在 Redis 意外停止工作（例如电源中断）的情况下丢失的数据最少的话，那么 RDB 不适合你。虽然你可以配置不同的 save 时间点（例如每隔 5 分钟并且对数据集有 100 个写的操作），Redis 要完整的保存整个数据集是一个比较繁重的工作，你通常会每隔 5 分钟或者更久做一次完整的保存，万一在 Redis 意外宕机，你可能会丢失几分钟的数据。</li>
<li>RDB 需要经常 fork 子进程来保存数据集到硬盘上，当数据集比较大的时候，fork 的过程是非常耗时的，可能会导致 Redis 在一些毫秒级内不能响应客户端的请求。如果数据集巨大并且 CPU 性能不是很好的情况下，这种情况会持续 1 秒，AOF 也需要 fork，但是你可以调节重写日志文件的频率来提高数据集的耐久度。</li>
</ul>
<p>总结：</p>
<ul>
<li>不支持拉链，只会有一个 dump.rdb。</li>
<li>容易丢失数据，时点与时点之间的窗口数据容易丢失。</li>
</ul>
<h3 id="2-3-RDB-工作原理"><a href="#2-3-RDB-工作原理" class="headerlink" title="2.3 RDB 工作原理"></a>2.3 RDB 工作原理</h3><p>当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作:</p>
<ul>
<li>Redis 调用 forks。同时拥有父进程和子进程。</li>
<li>子进程将数据集写入到一个临时 RDB 文件中。</li>
<li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</li>
</ul>
<p>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益。</p>
<h3 id="2-4-RDB配置方式"><a href="#2-4-RDB配置方式" class="headerlink" title="2.4 RDB配置方式"></a>2.4 RDB配置方式</h3><ol>
<li><p>手动 <code>SAVE</code>：适合关机维护时使用</p>
</li>
<li><p>手动 <code>BGSAVE</code>：fork()，创建子进程</p>
</li>
<li><p>配置文件方式 <code>BGSAVE</code> 规则：注意，使用 save 标识，触发 bsave</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">################################ SNAPSHOTTING  ################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Save the DB on disk:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   save &lt;seconds&gt; &lt;changes&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   Will save the DB if both the given number of seconds and the given</span></span><br><span class="line"><span class="comment">#   number of write operations against the DB occurred.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   In the example below the behaviour will be to save:</span></span><br><span class="line"><span class="comment">#   after 900 sec (15 min) if at least 1 key changed</span></span><br><span class="line"><span class="comment">#   after 300 sec (5 min) if at least 10 keys changed</span></span><br><span class="line"><span class="comment">#   after 60 sec if at least 10000 keys changed</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   <span class="doctag">Note:</span> you can disable saving completely by commenting out all &quot;save&quot; lines.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   It is also possible to remove all the previously configured save</span></span><br><span class="line"><span class="comment">#   points by adding a save directive with a single empty string argument</span></span><br><span class="line"><span class="comment">#   like in the following example:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   save &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">save</span> <span class="string">900 1</span></span><br><span class="line"><span class="attr">save</span> <span class="string">300 10</span></span><br><span class="line"><span class="attr">save</span> <span class="string">60 10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># By default Redis will stop accepting writes if RDB snapshots are enabled</span></span><br><span class="line"><span class="comment"># (at least one save point) and the latest background save failed.</span></span><br><span class="line"><span class="comment"># This will make the user aware (in a hard way) that data is not persisting</span></span><br><span class="line"><span class="comment"># on disk properly, otherwise chances are that no one will notice and some</span></span><br><span class="line"><span class="comment"># disaster will happen.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If the background saving process will start working again Redis will</span></span><br><span class="line"><span class="comment"># automatically allow writes again.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># However if you have setup your proper monitoring of the Redis server</span></span><br><span class="line"><span class="comment"># and persistence, you may want to disable this feature so that Redis will</span></span><br><span class="line"><span class="comment"># continue to work as usual even if there are problems with disk,</span></span><br><span class="line"><span class="comment"># permissions, and so forth.</span></span><br><span class="line"><span class="meta">stop-writes-on-bgsave-error</span> <span class="string">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Compress string objects using LZF when dump .rdb databases?</span></span><br><span class="line"><span class="comment"># For default that&#x27;s set to &#x27;yes&#x27; as it&#x27;s almost always a win.</span></span><br><span class="line"><span class="comment"># If you want to save some CPU in the saving child set it to &#x27;no&#x27; but</span></span><br><span class="line"><span class="comment"># the dataset will likely be bigger if you have compressible values or keys.</span></span><br><span class="line"><span class="attr">rdbcompression</span> <span class="string">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Since version 5 of RDB a CRC64 checksum is placed at the end of the file.</span></span><br><span class="line"><span class="comment"># This makes the format more resistant to corruption but there is a performance</span></span><br><span class="line"><span class="comment"># hit to pay (around 10%) when saving and loading RDB files, so you can disable it</span></span><br><span class="line"><span class="comment"># for maximum performances.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># RDB files created with checksum disabled have a checksum of zero that will</span></span><br><span class="line"><span class="comment"># tell the loading code to skip the check.</span></span><br><span class="line"><span class="attr">rdbchecksum</span> <span class="string">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The filename where to dump the DB</span></span><br><span class="line"><span class="attr">dbfilename</span> <span class="string">dump.rdb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The working directory.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The DB will be written inside this directory, with the filename specified</span></span><br><span class="line"><span class="comment"># above using the &#x27;dbfilename&#x27; configuration directive.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The Append Only File will also be created inside this directory.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that you must specify a directory here, not a file name.</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">./</span></span><br><span class="line"><span class="attr">----------------------------------------------------------------------------------</span></span><br><span class="line"><span class="attr">save</span> <span class="string">900 1</span></span><br><span class="line"><span class="attr">save</span> <span class="string">300 10</span></span><br><span class="line"><span class="attr">save</span> <span class="string">60 10000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dbfilename</span> <span class="string">dump.rdb</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">/var/lib/redis/6379 </span></span><br></pre></td></tr></table></figure>
<h2 id="3-AOF（Append-Only-File）"><a href="#3-AOF（Append-Only-File）" class="headerlink" title="3 AOF（Append Only File）"></a>3 AOF（Append Only File）</h2></li>
</ol>
<h4 id="3-1-AOF-优点"><a href="#3-1-AOF-优点" class="headerlink" title="3.1 AOF 优点"></a>3.1 AOF 优点</h4><ul>
<li><p>使用AOF会让Redis更加耐久：你可以使用不同的fsync策略；无fsync，每秒fsync，每次写的时候fsync，使用默认的每秒fsync策略，Redis的性能依旧很好（fsync是由后台线程进行处理的，主线程会尽力处理客户端请求），一旦出现故障，你最多丢失1秒的数据</p>
</li>
<li><p>AOF 文件是一个只进行追加的日志文件，所以不需要写入 seek，即使由于某些原因（磁盘空间已满，写的过程宕机等待）未执行完整的写入命令，你可可以使用  <code>redis-check-aof</code>  工具修复这些问题。</p>
</li>
<li><p>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写：重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。整个重写操作时绝对安全的，因为 Redis 在创建 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</p>
<ul>
<li>AOF 文件有序地保存了对数据库执行的所有写入操作，这些写入操作以 Redis 协议的格式保存，因此 AOF 文件的内容非常容易被人读懂，对文件进行分析（parse）也很轻松。导出（export）AOF 文件也非常简单：举个例子，如果你不小心执行了 FLUSHALL 命令，但只要 AOF 文件未被重写，那么只要停止服务器，移除 AOF 文件末尾的 FLUSHALL 命令，并重启 Redis，就可以将数据集恢复到 FLUSHALL 执行之前的状态。</li>
</ul>
</li>
</ul>
<h4 id="3-2-AOF-缺点"><a href="#3-2-AOF-缺点" class="headerlink" title="3.2 AOF 缺点"></a>3.2 AOF 缺点</h4><ul>
<li>相同的数据集，AOF 的体积通常要大于 RDB 文件的体积.</li>
<li>根据所使用的 fsync 策略，AOF 的速度可能慢于 RDB。在一般情况下，每秒的 fsync 的性能依旧非常高，而关闭 fsync 可以让 AOF 的速度和 RDB 一样快，即使在高负荷之下也是如此。不过在处理巨大的写入载入时，RDB可以提供更有保证的最大延迟时间（latency）。</li>
</ul>
<h4 id="3-3-AOF-工作原理"><a href="#3-3-AOF-工作原理" class="headerlink" title="3.3 AOF 工作原理"></a>3.3 AOF 工作原理</h4><p>AOF 重写和 RDB 创建快照一样，都巧妙的利用了写时复制机制：</p>
<ul>
<li>Redis 执行 fork()，现在同时拥有父进程和子进程。</li>
<li>子进程开始将新的 AOF 文件的内容写入到临时文件。</li>
<li>对于所有新执行的写入命令，父进程一边将他们累积到一个内存缓存中，一边将这些改动追加到现有的 AOF 文件的末尾</li>
</ul>
<h4 id="3-4-持久化使用方式"><a href="#3-4-持久化使用方式" class="headerlink" title="3.4 持久化使用方式"></a>3.4 持久化使用方式</h4><p>Redis 配置文件 <code>APPEND ONLY MODE</code> 部分介绍了 AOF 的配置</p>
  <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是否开启AOF，默认关闭（no）</span></span><br><span class="line"><span class="attr">appendonly</span> <span class="string">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 AOF 文件名</span></span><br><span class="line"><span class="attr">appendfilename</span> <span class="string">appendonly.aof</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis支持三种不同的刷写模式：</span></span><br><span class="line"><span class="comment"># appendfsync always #每次收到写命令就立即强制写入磁盘，是最有保证的完全的持久化，但速度也是最慢的，一般不推荐使用。</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">everysec #每秒钟强制写入磁盘一次，在性能和持久化方面做了很好的折中，是受推荐的方式。</span></span><br><span class="line"><span class="comment"># appendfsync no     #完全依赖OS的写入，一般为30秒左右一次，性能最好但是持久化最没有保证，不被推荐。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在日志重写时，不进行命令追加操作，而只是将其放在缓冲区里，避免与命令的追加造成DISK IO上的冲突。</span></span><br><span class="line"><span class="comment">#设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入，默认为no</span></span><br><span class="line"><span class="meta">no-appendfsync-on-rewrite</span> <span class="string">no </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#当前AOF文件大小是上次日志重写得到AOF文件大小的二倍时，自动启动新的日志重写过程。</span></span><br><span class="line"><span class="meta">auto-aof-rewrite-percentage</span> <span class="string">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#当前AOF文件启动新的日志重写过程的最小值，避免刚刚启动Reids时由于文件尺寸较小导致频繁的重写。</span></span><br><span class="line"><span class="meta">auto-aof-rewrite-min-size</span> <span class="string">64mb</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Redis 缓存穿透、缓存击穿、缓存雪崩</title>
    <url>/2020/12/27/Redis-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/</url>
    <content><![CDATA[<h1 id="Redis-缓存穿透、缓存击穿、缓存雪崩"><a href="#Redis-缓存穿透、缓存击穿、缓存雪崩" class="headerlink" title="Redis 缓存穿透、缓存击穿、缓存雪崩"></a>Redis 缓存穿透、缓存击穿、缓存雪崩</h1><a id="more"></a>

<h2 id="1-Redis-缓存穿透"><a href="#1-Redis-缓存穿透" class="headerlink" title="1 Redis 缓存穿透"></a>1 Redis 缓存穿透</h2><h3 id="1-1-什么是缓存穿透？"><a href="#1-1-什么是缓存穿透？" class="headerlink" title="1.1 什么是缓存穿透？"></a>1.1 什么是缓存穿透？</h3><p>缓存穿透是指在高并发场景下并使用 Redis 作为缓存的时候，查询一个 DB 不存在的数据。</p>
<h3 id="1-2-缓存穿透解决方案"><a href="#1-2-缓存穿透解决方案" class="headerlink" title="1.2 缓存穿透解决方案"></a>1.2 缓存穿透解决方案</h3><h4 id="1-2-1-布隆过滤器"><a href="#1-2-1-布隆过滤器" class="headerlink" title="1.2.1 布隆过滤器"></a>1.2.1 布隆过滤器</h4><p>将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。</p>
<h2 id="2-Redis-缓存击穿"><a href="#2-Redis-缓存击穿" class="headerlink" title="2 Redis 缓存击穿"></a>2 Redis 缓存击穿</h2><h3 id="2-1-什么是缓存击穿？"><a href="#2-1-什么是缓存击穿？" class="headerlink" title="2.1 什么是缓存击穿？"></a>2.1 什么是缓存击穿？</h3><p>缓存击穿是指在高并发场景下并使用 Redis 作为缓存的时候，由于 Redis 会清除过期的 key，某个 key 不存在造成所有的并发都访问到数据库，大量的请求可能会瞬间把后端 DB 压垮。</p>
<h3 id="2-2-缓存击穿解决方案"><a href="#2-2-缓存击穿解决方案" class="headerlink" title="2.2 缓存击穿解决方案"></a>2.2 缓存击穿解决方案</h3><h4 id="2-2-1-设置永不过期"><a href="#2-2-1-设置永不过期" class="headerlink" title="2.2.1 设置永不过期"></a>2.2.1 设置永不过期</h4><p>最简单的方法，key 设置不过期就不会产生此问题</p>
<h4 id="2-2-2-使用互斥锁"><a href="#2-2-2-使用互斥锁" class="headerlink" title="2.2.2 使用互斥锁"></a>2.2.2 使用互斥锁</h4><p>使用 Redis 的 <code>SETNX</code>，只有抢到锁的才会去 DB 加载数据，没有抢到锁的等待一段时间。</p>
<h2 id="3-Redis-缓存雪崩"><a href="#3-Redis-缓存雪崩" class="headerlink" title="3 Redis 缓存雪崩"></a>3 Redis 缓存雪崩</h2><h3 id="3-1-什么是缓存雪崩？"><a href="#3-1-什么是缓存雪崩？" class="headerlink" title="3.1 什么是缓存雪崩？"></a>3.1 什么是缓存雪崩？</h3><p>缓存雪崩是指在高并发场景下并使用 Redis 作为缓存的时候，大量的 key 同时失效间接造成大量的请求访问到达 DB。</p>
<h3 id="3-2-缓存雪崩解决方案"><a href="#3-2-缓存雪崩解决方案" class="headerlink" title="3.2  缓存雪崩解决方案"></a>3.2  缓存雪崩解决方案</h3><h4 id="3-2-1-随机过期时间"><a href="#3-2-1-随机过期时间" class="headerlink" title="3.2.1 随机过期时间"></a>3.2.1 随机过期时间</h4><p>如果 Redis 中的数据与时点性无关，可以设置 key 随机过期时间，让缓存失效的时间点尽量均匀。</p>
<h3 id="3-2-2-互斥锁"><a href="#3-2-2-互斥锁" class="headerlink" title="3.2.2 互斥锁"></a>3.2.2 互斥锁</h3><p>如果 Redis 中的数据具有时点性，假设到 0:00 大量的 key 过期，可以对 key 加互斥锁，与缓存击穿类似。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Redis 缓存穿透</tag>
        <tag>Redis 缓存击穿</tag>
        <tag>Redis 缓存雪崩</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot 线程池（一）：使用同步线程池</title>
    <url>/2020/12/21/SpringBoot-%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%90%8C%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="SpringBoot-线程池（一）：使用同步线程池"><a href="#SpringBoot-线程池（一）：使用同步线程池" class="headerlink" title="SpringBoot 线程池（一）：使用同步线程池"></a>SpringBoot 线程池（一）：使用同步线程池</h1><a id="more"></a>
<h2 id="1-创建任务"><a href="#1-创建任务" class="headerlink" title="1 创建任务"></a>1 创建任务</h2><h3 id="1-1-创建同步任务类-SyncTask"><a href="#1-1-创建同步任务类-SyncTask" class="headerlink" title="1.1 创建同步任务类 SyncTask"></a>1.1 创建同步任务类 SyncTask</h3><p>创建同步任务类 <code>SyncTask</code>，添加 <code>@Component</code> 注释</p>
<h3 id="1-2-创建需要执行的任务"><a href="#1-2-创建需要执行的任务" class="headerlink" title="1.2 创建需要执行的任务"></a>1.2 创建需要执行的任务</h3><p>为了测试方便，只打印一行信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：sync execute task...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-创建线程池、任务执行调用方法"><a href="#1-3-创建线程池、任务执行调用方法" class="headerlink" title="1.3 创建线程池、任务执行调用方法"></a>1.3 创建线程池、任务执行调用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 同步任务线程池 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">20</span>, <span class="number">60L</span>,</span><br><span class="line">	TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">50</span>),</span><br><span class="line">	<span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">&quot;sync-task-thread-pool-%d&quot;</span>).build());</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提交任务给线程池</span></span><br><span class="line">    executorService.submit(<span class="keyword">this</span>::sync);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-SyncTask-类完整代码"><a href="#1-4-SyncTask-类完整代码" class="headerlink" title="1.4 SyncTask 类完整代码"></a>1.4 SyncTask 类完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 同步任务线程池 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">20</span>, <span class="number">60L</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">50</span>),</span><br><span class="line">            <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">&quot;sync-task-thread-pool-%d&quot;</span>).build());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：sync execute task...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 提交任务给线程池</span></span><br><span class="line">        executorService.submit(<span class="keyword">this</span>::sync);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-创建单元测试进行测试"><a href="#2-创建单元测试进行测试" class="headerlink" title="2 创建单元测试进行测试"></a>2 创建单元测试进行测试</h2><p>本次使用 <code>JUnit5</code> 进行测试，完整代码如下：</p>
<h3 id="2-1-不使用线程池"><a href="#2-1-不使用线程池" class="headerlink" title="2.1 不使用线程池"></a>2.1 不使用线程池</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudyApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	SyncTask syncTask;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncWithoutThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;start execute task...&quot;</span>);</span><br><span class="line">		<span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">			syncTask.sync();</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;total time：&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印日志结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start execute task...</span><br><span class="line">main：sync execute task...</span><br><span class="line">main：sync execute task...</span><br><span class="line">main：sync execute task...</span><br><span class="line">main：sync execute task...</span><br><span class="line">main：sync execute task...</span><br><span class="line">main：sync execute task...</span><br><span class="line">main：sync execute task...</span><br><span class="line">main：sync execute task...</span><br><span class="line">main：sync execute task...</span><br><span class="line">main：sync execute task...</span><br><span class="line">total time：10117</span><br></pre></td></tr></table></figure>
<h3 id="2-2-使用线程池"><a href="#2-2-使用线程池" class="headerlink" title="2.2 使用线程池"></a>2.2 使用线程池</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudyApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	SyncTask syncTask;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncWithThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;start execute task...&quot;</span>);</span><br><span class="line">		<span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">			syncTask.execute();</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;total time：&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印日志结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start execute task...</span><br><span class="line">sync-task-thread-pool-0：sync execute task...</span><br><span class="line">sync-task-thread-pool-1：sync execute task...</span><br><span class="line">sync-task-thread-pool-2：sync execute task...</span><br><span class="line">sync-task-thread-pool-3：sync execute task...</span><br><span class="line">sync-task-thread-pool-4：sync execute task...</span><br><span class="line">sync-task-thread-pool-5：sync execute task...</span><br><span class="line">sync-task-thread-pool-6：sync execute task...</span><br><span class="line">sync-task-thread-pool-7：sync execute task...</span><br><span class="line">sync-task-thread-pool-8：sync execute task...</span><br><span class="line">total time：2</span><br><span class="line">sync-task-thread-pool-9：sync execute task...</span><br></pre></td></tr></table></figure>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>由上述结果可见：使用线程池执行批量任务速度要快。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot 线程池（二）：使用异步线程池</title>
    <url>/2020/12/21/SpringBoot-%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="SpringBoot-线程池（二）：使用异步线程池"><a href="#SpringBoot-线程池（二）：使用异步线程池" class="headerlink" title="SpringBoot 线程池（二）：使用异步线程池"></a>SpringBoot 线程池（二）：使用异步线程池</h1><a id="more"></a>
<h2 id="1-创建异步线程池配置"><a href="#1-创建异步线程池配置" class="headerlink" title="1 创建异步线程池配置"></a>1 创建异步线程池配置</h2><h3 id="1-1-配置线程池属性"><a href="#1-1-配置线程池属性" class="headerlink" title="1.1 配置线程池属性"></a>1.1 配置线程池属性</h3><p>在 <code>application.properties</code> 配置文件中添加异步线程池的相关属性</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 异步线程池相关属性</span></span><br><span class="line"><span class="meta">asyncThreadPool.corePoolSize</span> = <span class="string">10</span></span><br><span class="line"><span class="meta">asyncThreadPool.maxPoolSize</span> = <span class="string">20</span></span><br><span class="line"><span class="meta">asyncThreadPool.queueCapacity</span> = <span class="string">50</span></span><br><span class="line"><span class="meta">asyncThreadPool.keepAliveSeconds</span> = <span class="string">60</span></span><br><span class="line"><span class="meta">asyncThreadPool.threadNamePrefix</span> = <span class="string">async-task-thread-pool-%d</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-创建线程池配置类"><a href="#1-2-创建线程池配置类" class="headerlink" title="1.2 创建线程池配置类"></a>1.2 创建线程池配置类</h3><p>创建 <code>AsyncConfig</code> 类并添加 <code>@Configuration</code> 注释，完整配置如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步线程池配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;asyncThreadPool.corePoolSize&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;asyncThreadPool.maxPoolSize&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxPoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;asyncThreadPool.queueCapacity&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;asyncThreadPool.keepAliveSeconds&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> keepAliveSeconds;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;asyncThreadPool.threadNamePrefix&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String threadNamePrefix;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">asyncExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor threadPoolTaskExecutor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        threadPoolTaskExecutor.setCorePoolSize(corePoolSize);</span><br><span class="line">        threadPoolTaskExecutor.setMaxPoolSize(maxPoolSize);</span><br><span class="line">        threadPoolTaskExecutor.setQueueCapacity(queueCapacity);</span><br><span class="line">        threadPoolTaskExecutor.setKeepAliveSeconds(keepAliveSeconds);</span><br><span class="line">        threadPoolTaskExecutor.setThreadNamePrefix(threadNamePrefix);</span><br><span class="line">        threadPoolTaskExecutor.initialize();</span><br><span class="line">        <span class="keyword">return</span> threadPoolTaskExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-创建任务"><a href="#2-创建任务" class="headerlink" title="2 创建任务"></a>2 创建任务</h2><h3 id="2-1-创建异步任务类-SyncTask"><a href="#2-1-创建异步任务类-SyncTask" class="headerlink" title="2.1 创建异步任务类 SyncTask"></a>2.1 创建异步任务类 SyncTask</h3><p>创建同步任务类 <code>AsyncTask</code>，添加 <code>@Component</code> 注释</p>
<h3 id="2-2-创建需要执行的任务"><a href="#2-2-创建需要执行的任务" class="headerlink" title="2.2 创建需要执行的任务"></a>2.2 创建需要执行的任务</h3><p>为了测试方便，只打印一行信息，异步任务需要添加 <code>@Async</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Async(&quot;asyncExecutor&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：async execute task...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-SyncTask-类完整代码"><a href="#2-3-SyncTask-类完整代码" class="headerlink" title="2.3  SyncTask 类完整代码"></a>2.3  SyncTask 类完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async(&quot;asyncExecutor&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：async execute task...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-创建单元测试进行测试"><a href="#2-创建单元测试进行测试" class="headerlink" title="2 创建单元测试进行测试"></a>2 创建单元测试进行测试</h2><p>本次使用 <code>JUnit5</code> 进行测试，完整代码如下：</p>
<h3 id="2-1-无返回值"><a href="#2-1-无返回值" class="headerlink" title="2.1 无返回值"></a>2.1 无返回值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudyApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	AsyncTask asyncTask;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncWithThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;start execute task...&quot;</span>);</span><br><span class="line">		<span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 无返回值</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">			asyncTask.execute();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;total time：&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印日志结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start execute task...</span><br><span class="line">total time：5</span><br><span class="line">async-task-thread-pool-1：async execute task...</span><br><span class="line">async-task-thread-pool-10：async execute task...</span><br><span class="line">async-task-thread-pool-8：async execute task...</span><br><span class="line">async-task-thread-pool-6：async execute task...</span><br><span class="line">async-task-thread-pool-5：async execute task...</span><br><span class="line">async-task-thread-pool-7：async execute task...</span><br><span class="line">async-task-thread-pool-4：async execute task...</span><br><span class="line">async-task-thread-pool-9：async execute task...</span><br><span class="line">async-task-thread-pool-3：async execute task...</span><br><span class="line">async-task-thread-pool-2：async execute task...</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>亿级流量网站架构 设计原则</title>
    <url>/2021/01/01/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><a id="more"></a>

<h2 id="1-高并发设计原则"><a href="#1-高并发设计原则" class="headerlink" title="1 高并发设计原则"></a>1 高并发设计原则</h2><h3 id="1-1-无状态"><a href="#1-1-无状态" class="headerlink" title="1.1 无状态"></a>1.1 无状态</h3><p>无状态容易进行水平扩展。</p>
<p>实际生产环境：应用无状态+配置文件有状态</p>
<h3 id="1-2-拆分"><a href="#1-2-拆分" class="headerlink" title="1.2 拆分"></a>1.2 拆分</h3><p>系统拆分几种情况：</p>
<ul>
<li>系统维度：系统功能、业务拆分，比如商品系统、购物陈、结算、订单系统等。</li>
<li>功能维度：对一个系统进行功能再拆分，比如，优惠券系统可以拆分为后台券创建系统、领券系统、用券系统。</li>
<li>读写维度：读量大，使用缓存提升性能；写量大，分库分表。</li>
<li>AOP 维度：比如，商品详情页可以分为 CDN、页面渲染系统。</li>
<li>模块维度：代码（Web、Service、Dao）</li>
</ul>
<h3 id="1-3-服务化"><a href="#1-3-服务化" class="headerlink" title="1.3 服务化"></a>1.3 服务化</h3><p>总结为如下流程：</p>
<p>进程内服务 -&gt; 单机远程服务 -&gt; 集群手动注册服务 -&gt; 自动注册服务和发现服务 -&gt; 服务的分组/隔离/路由 -&gt; 服务治理如限流/黑白名单</p>
<h3 id="1-4-消息队列"><a href="#1-4-消息队列" class="headerlink" title="1.4 消息队列"></a>1.4 消息队列</h3><p>服务解耦（一对多）消费、异步处理、流量削峰/缓冲等。</p>
<h4 id="1-4-1-大流量缓冲"><a href="#1-4-1-大流量缓冲" class="headerlink" title="1.4.1 大流量缓冲"></a>1.4.1 大流量缓冲</h4><p>牺牲强一致性，保证最终一致性</p>
<h4 id="1-4-2-数据校对"><a href="#1-4-2-数据校对" class="headerlink" title="1.4.2 数据校对"></a>1.4.2 数据校对</h4><p>消息异步机制场景下，可能存在消息的丢失，需要考虑进行数据校对和修正数据来保证一致性和完整性。</p>
<h3 id="1-5-数据异构"><a href="#1-5-数据异构" class="headerlink" title="1.5 数据异构"></a>1.5 数据异构</h3><h4 id="1-5-1-数据异构"><a href="#1-5-1-数据异构" class="headerlink" title="1.5.1 数据异构"></a>1.5.1 数据异构</h4><h4 id="1-5-2-数据闭环"><a href="#1-5-2-数据闭环" class="headerlink" title="1.5.2 数据闭环"></a>1.5.2 数据闭环</h4><h3 id="1-6-缓存银弹"><a href="#1-6-缓存银弹" class="headerlink" title="1.6 缓存银弹"></a>1.6 缓存银弹</h3><table>
<thead>
<tr>
<th>流程节点</th>
<th>缓存技术</th>
</tr>
</thead>
<tbody><tr>
<td>客户端</td>
<td>使用浏览器缓存</td>
</tr>
<tr>
<td></td>
<td>客户端缓存</td>
</tr>
<tr>
<td>客户端网络</td>
<td>代理服务器开启缓存</td>
</tr>
<tr>
<td>广域网</td>
<td>使用代理服务器（含 CDN）</td>
</tr>
<tr>
<td></td>
<td>使用镜像服务器</td>
</tr>
<tr>
<td></td>
<td>使用 P2P 技术</td>
</tr>
<tr>
<td>源站及源站网络</td>
<td>使用接入层提供的缓存机制</td>
</tr>
<tr>
<td></td>
<td>使用应用层提供的缓存机制</td>
</tr>
<tr>
<td></td>
<td>使用分布式缓存</td>
</tr>
<tr>
<td></td>
<td>静态化、伪静态化</td>
</tr>
<tr>
<td></td>
<td>使用服务器操作系统提供的缓存机制</td>
</tr>
</tbody></table>
<h4 id="1-6-1-浏览器端缓存"><a href="#1-6-1-浏览器端缓存" class="headerlink" title="1.6.1 浏览器端缓存"></a>1.6.1 浏览器端缓存</h4><p>设置请求的过期时间。如对响应头 Expires、Cahce-control 进行控制。</p>
<p>适用于实时性不太敏感的数据，如商品详情页、商家评分、评价、广告词等。</p>
<h4 id="1-6-2-APP-客户端缓存"><a href="#1-6-2-APP-客户端缓存" class="headerlink" title="1.6.2 APP 客户端缓存"></a>1.6.2 APP 客户端缓存</h4><p>大促前提前下发素材到客户端缓存。</p>
<h4 id="1-6-3-CDN-缓存"><a href="#1-6-3-CDN-缓存" class="headerlink" title="1.6.3 CDN 缓存"></a>1.6.3 CDN 缓存</h4><p>有些页面、活动页、图片等服务推送到离用户最近的 CDN 节点</p>
<ul>
<li>推送机制</li>
<li>拉取机制</li>
</ul>
<h4 id="1-6-4-接入层缓存"><a href="#1-6-4-接入层缓存" class="headerlink" title="1.6.4 接入层缓存"></a>1.6.4 接入层缓存</h4><p>对于没有 CDN 缓存的应用来说，可以使用如 Nginx 搭建一层接入层。</p>
<h4 id="1-6-5-应用层缓存"><a href="#1-6-5-应用层缓存" class="headerlink" title="1.6.5 应用层缓存"></a>1.6.5 应用层缓存</h4><p>使用 Tomcat 时，可以使用堆内缓存/堆外缓存。可以使用 local redis cache 来代替对外缓存；或在接入层使用 share_dict 来将缓存前置，以减少风暴。</p>
<h4 id="1-6-6-分布式缓存"><a href="#1-6-6-分布式缓存" class="headerlink" title="1.6.6 分布式缓存"></a>1.6.6 分布式缓存</h4><p>数据量太大，Redis 单服务器存储不了，可以使用分片机制将流量分散到多台，或直接使用分布式缓存实现。</p>
<h3 id="1-7-并发化"><a href="#1-7-并发化" class="headerlink" title="1.7 并发化"></a>1.7 并发化</h3><h2 id="2-高可用原则"><a href="#2-高可用原则" class="headerlink" title="2 高可用原则"></a>2 高可用原则</h2><h3 id="2-1-降级"><a href="#2-1-降级" class="headerlink" title="2.1 降级"></a>2.1 降级</h3><p>设计降级开关</p>
<h3 id="2-2-限流"><a href="#2-2-限流" class="headerlink" title="2.2 限流"></a>2.2 限流</h3><p>限流的目的是防止恶意请求流量、恶意攻击，或者防止流量超出系统峰值。</p>
<p>思路：</p>
<ol>
<li>恶意请求流量只访问到 cache。</li>
<li>对于穿透到后端应用的流量可以考虑使用 Nginx 的 limit 模块处理。</li>
<li>对于恶意的 IP 可以使用 nginx deny 进行屏蔽。</li>
</ol>
<h3 id="2-3-切流量"><a href="#2-3-切流量" class="headerlink" title="2.3 切流量"></a>2.3 切流量</h3><h3 id="2-4-可回滚"><a href="#2-4-可回滚" class="headerlink" title="2.4 可回滚"></a>2.4 可回滚</h3><h2 id="3-业务设计原则"><a href="#3-业务设计原则" class="headerlink" title="3 业务设计原则"></a>3 业务设计原则</h2><h3 id="3-1-防重设计"><a href="#3-1-防重设计" class="headerlink" title="3.1 防重设计"></a>3.1 防重设计</h3><h3 id="3-2-幂等设计"><a href="#3-2-幂等设计" class="headerlink" title="3.2 幂等设计"></a>3.2 幂等设计</h3><h3 id="3-3-流程可定义"><a href="#3-3-流程可定义" class="headerlink" title="3.3 流程可定义"></a>3.3 流程可定义</h3><h3 id="3-4-状态与状态机"><a href="#3-4-状态与状态机" class="headerlink" title="3.4 状态与状态机"></a>3.4 状态与状态机</h3><h3 id="3-5-后台系统操作可反馈"><a href="#3-5-后台系统操作可反馈" class="headerlink" title="3.5 后台系统操作可反馈"></a>3.5 后台系统操作可反馈</h3><h3 id="3-6-后台系统审批化"><a href="#3-6-后台系统审批化" class="headerlink" title="3.6 后台系统审批化"></a>3.6 后台系统审批化</h3><h3 id="3-7-文档和注释"><a href="#3-7-文档和注释" class="headerlink" title="3.7 文档和注释"></a>3.7 文档和注释</h3>]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>高可用</tag>
        <tag>高并发</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>亿级流量网站架构 高可用 回滚</title>
    <url>/2021/01/02/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E9%AB%98%E5%8F%AF%E7%94%A8-%E5%9B%9E%E6%BB%9A/</url>
    <content><![CDATA[<a id="more"></a>]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>高可用</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>亿级流量网站架构 高可用 负载均衡</title>
    <url>/2021/01/02/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E9%AB%98%E5%8F%AF%E7%94%A8-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<h1 id="负载均衡与反向代理"><a href="#负载均衡与反向代理" class="headerlink" title="负载均衡与反向代理"></a>负载均衡与反向代理</h1><a id="more"></a>

<p>Nginx 一般用于七层负载均衡，其吞吐量有一定的限制。为了提升吞吐量，会在 DNS 和 Nginx 之间引入接入层，如使用 LVS（软件负载均衡器）、F5（硬件负载均衡器）可以做四层负载均衡，即首先 DNS 解析到 LVS</p>
<p>术语：</p>
<p>Nginx：接入层、反向代理服务器、负载均衡器</p>
<p>upstream server：上游服务器，也称为 real server：真实处理业务的服务器</p>
<p>负载均衡关心方面：</p>
<ul>
<li>上游服务器配置</li>
<li>负载均衡算法</li>
<li>失败重试机制</li>
<li>服务器心跳检测</li>
</ul>
<h2 id="1-upstream-配置"><a href="#1-upstream-配置" class="headerlink" title="1 upstream 配置"></a>1 upstream 配置</h2><p>Nginx 配置上游服务器</p>
<p>http 指令下 配置 upstream</p>
<h2 id="2-负载均衡算法"><a href="#2-负载均衡算法" class="headerlink" title="2 负载均衡算法"></a>2 负载均衡算法</h2><p>upstream server：</p>
<ul>
<li>round-robin：轮询</li>
<li>ip_hash：ip 哈希</li>
<li>hash key [consistent]：对 key 哈希或一致性哈希</li>
</ul>
<h2 id="3-失败重试"><a href="#3-失败重试" class="headerlink" title="3 失败重试"></a>3 失败重试</h2><p>配置：upstream server 和 proxy pass</p>
<h2 id="4-健康检查"><a href="#4-健康检查" class="headerlink" title="4 健康检查"></a>4 健康检查</h2><p>Nginx 对上游服务器的健康检查默认采用的是惰性策略，可以集成 nginx_upstream_check_module（<a href="https://github.com/yaoweibin/nginx_upstream_check_module%EF%BC%89">https://github.com/yaoweibin/nginx_upstream_check_module）</a> 模块进行主动健康检查。</p>
<h3 id="4-1-TCP-心跳检查"><a href="#4-1-TCP-心跳检查" class="headerlink" title="4.1 TCP 心跳检查"></a>4.1 TCP 心跳检查</h3><h3 id="4-2-HTTP-心跳检查"><a href="#4-2-HTTP-心跳检查" class="headerlink" title="4.2 HTTP 心跳检查"></a>4.2 HTTP 心跳检查</h3><h2 id="5-其他配置"><a href="#5-其他配置" class="headerlink" title="5 其他配置"></a>5 其他配置</h2><h3 id="5-1-上游服务器域名"><a href="#5-1-上游服务器域名" class="headerlink" title="5.1 上游服务器域名"></a>5.1 上游服务器域名</h3><h3 id="5-2-上游服务器备份"><a href="#5-2-上游服务器备份" class="headerlink" title="5.2 上游服务器备份"></a>5.2 上游服务器备份</h3><h3 id="5-3-上游服务器不可用"><a href="#5-3-上游服务器不可用" class="headerlink" title="5.3 上游服务器不可用"></a>5.3 上游服务器不可用</h3><h2 id="6-长连接"><a href="#6-长连接" class="headerlink" title="6 长连接"></a>6 长连接</h2><p>客户端与 Nginx 的长连接</p>
<p>Nginx 与 上游服务器的长连接：通过 keepalive 指令配置长连接数量。</p>
<h2 id="7-反向代理示例"><a href="#7-反向代理示例" class="headerlink" title="7 反向代理示例"></a>7 反向代理示例</h2><h2 id="8-HTTP-动态负载均衡（七层）"><a href="#8-HTTP-动态负载均衡（七层）" class="headerlink" title="8 HTTP 动态负载均衡（七层）"></a>8 HTTP 动态负载均衡（七层）</h2><p>使用 Consul 将upstream 动态注册到 Nginx 上。</p>
<p>Consul 是一款开源的动态分布式服务与发现系统。</p>
<h3 id="8-1-Consul-Consul-template"><a href="#8-1-Consul-Consul-template" class="headerlink" title="8.1 Consul + Consul-template"></a>8.1 Consul + Consul-template</h3><p>每次配置变更都需要 reload nginx，reload 是有一定的损耗的。</p>
<h3 id="8-2-Consul-OpenRestry"><a href="#8-2-Consul-OpenRestry" class="headerlink" title="8.2 Consul + OpenRestry"></a>8.2 Consul + OpenRestry</h3><p>使用 Consul 注册服务，使用 OpenRestry balancer_by_lua 实现无 reload 动态负载均衡。</p>
<h2 id="9-Nginx-四层负载均衡"><a href="#9-Nginx-四层负载均衡" class="headerlink" title="9 Nginx 四层负载均衡"></a>9 Nginx 四层负载均衡</h2><h3 id="9-1-静态负载均衡"><a href="#9-1-静态负载均衡" class="headerlink" title="9.1 静态负载均衡"></a>9.1 静态负载均衡</h3><p>ngx_stream_core_stream 默认没有启用，安装 Nginx 时，添加 <code>--with-stream</code> 配置参数启用。</p>
<p>可以使用开源的 nginx-stream-upsync-module 实现动态负载均衡。</p>
<h3 id="9-2-动态负载均衡"><a href="#9-2-动态负载均衡" class="headerlink" title="9,2 动态负载均衡"></a>9,2 动态负载均衡</h3><p> nginx-upsync-module，提供了七层动态负载均衡 </p>
]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>高可用</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>亿级流量网站架构 高可用 资源隔离</title>
    <url>/2021/01/02/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E9%AB%98%E5%8F%AF%E7%94%A8-%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB/</url>
    <content><![CDATA[<h1 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h1><a id="more"></a>

<h2 id="1-线程隔离"><a href="#1-线程隔离" class="headerlink" title="1 线程隔离"></a>1 线程隔离</h2><p>线程隔离主要是指线程池隔离，当一种业务的请求处理发生问题时，不会将故障扩散到其它线程池，从而保证其他服务可用。</p>
<h2 id="2-进程隔离"><a href="#2-进程隔离" class="headerlink" title="2 进程隔离"></a>2 进程隔离</h2><p>通过系统拆分为多个子系统来实现物理隔离，使得某一个子系统出现问题时不会影响到其它子系统。</p>
<h2 id="3-集群隔离"><a href="#3-集群隔离" class="headerlink" title="3 集群隔离"></a>3 集群隔离</h2><p>商品服务为秒杀提供单独的服务集群，即为服务分组。</p>
<h2 id="4-机房隔离"><a href="#4-机房隔离" class="headerlink" title="4 机房隔离"></a>4 机房隔离</h2><p>多机房部署，不能跨机房调用。</p>
<h2 id="5-读写隔离"><a href="#5-读写隔离" class="headerlink" title="5 读写隔离"></a>5 读写隔离</h2><p>Redis 主从模式实现读写分离、</p>
<h2 id="6-动静隔离"><a href="#6-动静隔离" class="headerlink" title="6 动静隔离"></a>6 动静隔离</h2><p>静态资源放在 CDN 上。</p>
<h2 id="7-爬虫隔离"><a href="#7-爬虫隔离" class="headerlink" title="7 爬虫隔离"></a>7 爬虫隔离</h2><ol>
<li>限流</li>
<li>爬虫路由到单独的集群上</li>
</ol>
<h2 id="8-热点隔离"><a href="#8-热点隔离" class="headerlink" title="8 热点隔离"></a>8 热点隔离</h2><p>秒杀、抢购属于热点服务，将其作成独立系统或服务进行隔离。</p>
<h2 id="9-资源隔离"><a href="#9-资源隔离" class="headerlink" title="9 资源隔离"></a>9 资源隔离</h2><h2 id="10-使用-Hystrix-实现隔离"><a href="#10-使用-Hystrix-实现隔离" class="headerlink" title="10 使用 Hystrix 实现隔离"></a>10 使用 Hystrix 实现隔离</h2><h2 id="11-基于-Servlet-3-实现请求隔离"><a href="#11-基于-Servlet-3-实现请求隔离" class="headerlink" title="11 基于 Servlet 3 实现请求隔离"></a>11 基于 Servlet 3 实现请求隔离</h2><p>异步 NIO</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>高可用</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>亿级流量网站架构 高可用 超时与重试</title>
    <url>/2021/01/02/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E9%AB%98%E5%8F%AF%E7%94%A8-%E8%B6%85%E6%97%B6%E4%B8%8E%E9%87%8D%E8%AF%95/</url>
    <content><![CDATA[<a id="more"></a>]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>高可用</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>亿级流量网站架构 高可用 降级</title>
    <url>/2021/01/02/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E9%AB%98%E5%8F%AF%E7%94%A8-%E9%99%8D%E7%BA%A7/</url>
    <content><![CDATA[<h1 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h1><a id="more"></a>

<p>当访问量剧增、服务出现问题（如响应时间长或不响应）或非核心服务影响到核心流程的性能时，任然需要保证服务还是可用的，即使有损服务。</p>
<h2 id="1-降级预案"><a href="#1-降级预案" class="headerlink" title="1 降级预案"></a>1 降级预案</h2><p>降级按是否自动化可分为：自动开关降级和人工开关降级</p>
<p>降级按功能可分为：读服务降级和写服务降级</p>
<p>降级按照处于的系统层次可分为：多级降级</p>
<h2 id="2-自动开关降级"><a href="#2-自动开关降级" class="headerlink" title="2 自动开关降级"></a>2 自动开关降级</h2><h3 id="2-1-超时降级"><a href="#2-1-超时降级" class="headerlink" title="2.1 超时降级"></a>2.1 超时降级</h3><h3 id="2-2-统计失败降级"><a href="#2-2-统计失败降级" class="headerlink" title="2.2 统计失败降级"></a>2.2 统计失败降级</h3><h3 id="2-3-故障降级"><a href="#2-3-故障降级" class="headerlink" title="2.3 故障降级"></a>2.3 故障降级</h3><h3 id="2-4-限流降级"><a href="#2-4-限流降级" class="headerlink" title="2.4 限流降级"></a>2.4 限流降级</h3><h2 id="3-人工开关降级"><a href="#3-人工开关降级" class="headerlink" title="3 人工开关降级"></a>3 人工开关降级</h2><h2 id="4-读服务降级"><a href="#4-读服务降级" class="headerlink" title="4 读服务降级"></a>4 读服务降级</h2><h2 id="5-写服务降级"><a href="#5-写服务降级" class="headerlink" title="5 写服务降级"></a>5 写服务降级</h2><h2 id="6-多级降级"><a href="#6-多级降级" class="headerlink" title="6 多级降级"></a>6 多级降级</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>高可用</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>亿级流量网站架构 高可用 限流</title>
    <url>/2021/01/02/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E9%AB%98%E5%8F%AF%E7%94%A8-%E9%99%90%E6%B5%81/</url>
    <content><![CDATA[<h1 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h1><a id="more"></a>

<h2 id="1-限流算法"><a href="#1-限流算法" class="headerlink" title="1 限流算法"></a>1 限流算法</h2><p>常见的限流算法有：令牌桶、漏桶、计数器</p>
<h3 id="1-1-令牌桶算法"><a href="#1-1-令牌桶算法" class="headerlink" title="1.1 令牌桶算法"></a>1.1 令牌桶算法</h3><h3 id="1-2-漏桶算法"><a href="#1-2-漏桶算法" class="headerlink" title="1.2 漏桶算法"></a>1.2 漏桶算法</h3><h2 id="2-应用级限流"><a href="#2-应用级限流" class="headerlink" title="2 应用级限流"></a>2 应用级限流</h2><h3 id="2-1-总并发数-连接-请求数限流"><a href="#2-1-总并发数-连接-请求数限流" class="headerlink" title="2.1 总并发数/连接/请求数限流"></a>2.1 总并发数/连接/请求数限流</h3><p>对于一个应用系统来说，一定会有极限并发数/请求数，即总有一个 TPS/QPS 阈值，如果超过了阈值，则系统就不会响应用户请求或响应变得很慢，因此我们最好进行过载保护，以防止大量请求涌入击垮系统。</p>
<p>Tomcat 的 Connector 配置：</p>
<ul>
<li>acceptCount：</li>
<li>maxConnections：</li>
<li>maxThreads：</li>
</ul>
<p>MySQL、Redis也有类似的限制连接数的配置。</p>
<h3 id="2-2-总资源数限流"><a href="#2-2-总资源数限流" class="headerlink" title="2.2 总资源数限流"></a>2.2 总资源数限流</h3><p>连接池、线程池</p>
<h3 id="2-3-某个接口的总并发-请求数"><a href="#2-3-某个接口的总并发-请求数" class="headerlink" title="2.3 某个接口的总并发/请求数"></a>2.3 某个接口的总并发/请求数</h3><p>如果接口可能会有突发情况，但又担心访问量太大造成崩溃，如抢购业务，那么就需要限制这个接口的总并发/请求数。可以使用 Java 的 AtomicLong 或者 Semaphore 进行限流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (atomic.incrementAndGet() &gt; 限流数) &#123;</span><br><span class="line">        <span class="comment">// 拒绝请求</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理请求</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    atomic.deementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-某个接口的时间窗请求数"><a href="#2-4-某个接口的时间窗请求数" class="headerlink" title="2.4 某个接口的时间窗请求数"></a>2.4 某个接口的时间窗请求数</h3><p>一个时间窗口内的请求数</p>
<p>使用 Guava 的 Cache 存储计数器</p>
<h3 id="2-5-平滑限流某个接口的请求数"><a href="#2-5-平滑限流某个接口的请求数" class="headerlink" title="2.5 平滑限流某个接口的请求数"></a>2.5 平滑限流某个接口的请求数</h3><p>以上的方法不能应对瞬时的请求，从而导致一些问题。</p>
<p>令牌桶和漏桶算法可以整形为平均速率请求。</p>
<p>Guava RateLimiter 提供了令牌桶算法可用于平滑突发限流（SmoothBursty）和平滑预热限流（SmoothWarmingUp）实现。</p>
<h2 id="3-分布式限流"><a href="#3-分布式限流" class="headerlink" title="3 分布式限流"></a>3 分布式限流</h2><p>分布式限流最关键的是要将限流服务原子化，而解决方案可以使用 Redis + Lua 或者 Nginx + Lua 技术实现。</p>
<h3 id="3-1-Redis-Lua"><a href="#3-1-Redis-Lua" class="headerlink" title="3.1 Redis + Lua"></a>3.1 Redis + Lua</h3><h3 id="3-2-Nginx-Lua"><a href="#3-2-Nginx-Lua" class="headerlink" title="3.2 Nginx + Lua"></a>3.2 Nginx + Lua</h3><p><a href="https://github.com/openresty/lua-resty-lock">https://github.com/openresty/lua-resty-lock</a></p>
<h2 id="4-接入层限流"><a href="#4-接入层限流" class="headerlink" title="4 接入层限流"></a>4 接入层限流</h2><h3 id="4-1-ngx-http-limit-conn-module"><a href="#4-1-ngx-http-limit-conn-module" class="headerlink" title="4.1 ngx_http_limit_conn_module"></a>4.1 ngx_http_limit_conn_module</h3><h3 id="4-2-ngx-http-limit-req-module"><a href="#4-2-ngx-http-limit-req-module" class="headerlink" title="4.2 ngx_http_limit_req_module"></a>4.2 ngx_http_limit_req_module</h3>]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>高可用</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>亿级流量网站架构 高并发 HTTP 缓存</title>
    <url>/2021/01/02/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E9%AB%98%E5%B9%B6%E5%8F%91-HTTP-%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h1><a id="more"></a>

<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>浏览器缓存缓存场景</p>
<h2 id="2-HTTP-缓存"><a href="#2-HTTP-缓存" class="headerlink" title="2 HTTP 缓存"></a>2 HTTP 缓存</h2><h3 id="2-1-ETag"><a href="#2-1-ETag" class="headerlink" title="2.1 ETag"></a>2.1 ETag</h3><h3 id="2-2-Last-Modified"><a href="#2-2-Last-Modified" class="headerlink" title="2.2 Last-Modified"></a>2.2 Last-Modified</h3><h2 id="3-HTTPClient-客户端缓存"><a href="#3-HTTPClient-客户端缓存" class="headerlink" title="3 HTTPClient 客户端缓存"></a>3 HTTPClient 客户端缓存</h2><h2 id="4-Nginx-HTTP-缓存设置"><a href="#4-Nginx-HTTP-缓存设置" class="headerlink" title="4 Nginx HTTP 缓存设置"></a>4 Nginx HTTP 缓存设置</h2><h2 id="5-Nginx-代理层缓存"><a href="#5-Nginx-代理层缓存" class="headerlink" title="5 Nginx 代理层缓存"></a>5 Nginx 代理层缓存</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>高并发</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>亿级流量网站架构 高并发 多级缓存</title>
    <url>/2021/01/02/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E9%AB%98%E5%B9%B6%E5%8F%91-%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h1><a id="more"></a>

<p>从架构和提升命中率层面探讨缓存方案</p>
<h2 id="1-多级缓存介绍"><a href="#1-多级缓存介绍" class="headerlink" title="1 多级缓存介绍"></a>1 多级缓存介绍</h2><h2 id="2-如何缓存数据"><a href="#2-如何缓存数据" class="headerlink" title="2 如何缓存数据"></a>2 如何缓存数据</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>高并发</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>亿级流量网站架构 高并发 应用级缓存</title>
    <url>/2021/01/02/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E9%AB%98%E5%B9%B6%E5%8F%91-%E5%BA%94%E7%94%A8%E7%BA%A7%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="应用级缓存"><a href="#应用级缓存" class="headerlink" title="应用级缓存"></a>应用级缓存</h1><a id="more"></a>

<h2 id="1-缓存简介"><a href="#1-缓存简介" class="headerlink" title="1 缓存简介"></a>1 缓存简介</h2><p>缓存工作机制是先从缓存中读取数据，如果没有，再从慢速设备上读取实际数据并同步到缓存。经常读取的数据、频繁访问的数据、热点数据、I/O 瓶颈数据、计算昂贵的数据、服务 5 分钟法则的数据和局部性原理的数据都可以存进缓存。</p>
<h2 id="2-缓存命中率"><a href="#2-缓存命中率" class="headerlink" title="2 缓存命中率"></a>2 缓存命中率</h2><p>缓存命中率 = 从缓存中读取次数 / (总读取次数（从缓存中读取次数 + 从慢速设备上读取次数）)</p>
<p>命中率越高越好</p>
<h2 id="3-缓存回收策略"><a href="#3-缓存回收策略" class="headerlink" title="3 缓存回收策略"></a>3 缓存回收策略</h2><ol>
<li><p>基于空间</p>
<p>缓存设置了存储空间</p>
</li>
<li><p>基于容量</p>
<p>缓存设置了最大大小</p>
</li>
<li><p>基于时间</p>
<p>TTL（Time To Live）：存活期</p>
<p>TTI（Time To Idle）：空闲期</p>
</li>
<li><p>基于 Java 对象引用</p>
<ul>
<li>软引用</li>
<li>弱引用</li>
<li>虚引用</li>
</ul>
</li>
<li><p>回收算法</p>
<ul>
<li>FIFO</li>
<li>LRU</li>
<li>LFU</li>
</ul>
</li>
</ol>
<h2 id="4-Java-缓存类型"><a href="#4-Java-缓存类型" class="headerlink" title="4 Java 缓存类型"></a>4 Java 缓存类型</h2><h3 id="4-1-堆缓存"><a href="#4-1-堆缓存" class="headerlink" title="4.1 堆缓存"></a>4.1 堆缓存</h3><p>使用  Java 堆来存储缓存对象。一般使用堆缓存存储较热的数据。可以使用 Guava Cache、Ehcache 3.X，MapDB 实现。</p>
<h3 id="4-2-堆外缓存"><a href="#4-2-堆外缓存" class="headerlink" title="4.2 堆外缓存"></a>4.2 堆外缓存</h3><h3 id="4-3-磁盘缓存"><a href="#4-3-磁盘缓存" class="headerlink" title="4.3 磁盘缓存"></a>4.3 磁盘缓存</h3><h3 id="4-4-分布式缓存"><a href="#4-4-分布式缓存" class="headerlink" title="4.4 分布式缓存"></a>4.4 分布式缓存</h3><p>多 JVM 实例会存在两个问题：</p>
<ol>
<li>单机容量问题</li>
<li>资源一致性问题</li>
</ol>
<p>可以使用分布式缓存解决。</p>
<p>可以使用 ehcache-clustered（配合 Terracotta server）实现 Java 进程间分布式缓存。也可以使用 Redis 实现分布式缓存。</p>
<p>两种模式如下：</p>
<ul>
<li>单机时：存储最热的数据到堆缓存，相对较热的数据到堆外缓存，不热的数据到磁盘缓存。</li>
<li>集群时：存储最热的数据到堆缓存，相对较热的数据到堆外缓存，全量数据到分布式缓存。</li>
</ul>
<h2 id="5-应用级缓存实例"><a href="#5-应用级缓存实例" class="headerlink" title="5 应用级缓存实例"></a>5 应用级缓存实例</h2><h2 id="6-缓存使用模式实践"><a href="#6-缓存使用模式实践" class="headerlink" title="6 缓存使用模式实践"></a>6 缓存使用模式实践</h2><p>缓存使用模式/模板：</p>
<ul>
<li>Cache-Aside</li>
<li>Cache-As-SoR</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>高并发</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>亿级流量网站架构 高并发 异步并发</title>
    <url>/2021/01/02/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E9%AB%98%E5%B9%B6%E5%8F%91-%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h1 id="异步并发实战"><a href="#异步并发实战" class="headerlink" title="异步并发实战"></a>异步并发实战</h1><a id="more"></a>

<h2 id="1-同步阻塞调用"><a href="#1-同步阻塞调用" class="headerlink" title="1 同步阻塞调用"></a>1 同步阻塞调用</h2><h2 id="2-异步-Future"><a href="#2-异步-Future" class="headerlink" title="2 异步 Future"></a>2 异步 Future</h2><h2 id="3-异步-Callback"><a href="#3-异步-Callback" class="headerlink" title="3 异步 Callback"></a>3 异步 Callback</h2><h2 id="4-异步编排-CompletableFuture"><a href="#4-异步编排-CompletableFuture" class="headerlink" title="4 异步编排 CompletableFuture"></a>4 异步编排 CompletableFuture</h2><h2 id="5-异步-Web-服务实现"><a href="#5-异步-Web-服务实现" class="headerlink" title="5 异步 Web 服务实现"></a>5 异步 Web 服务实现</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>高并发</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>亿级流量网站架构 高并发 扩容</title>
    <url>/2021/01/02/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E9%AB%98%E5%B9%B6%E5%8F%91-%E6%89%A9%E5%AE%B9/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>高并发</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>亿级流量网站架构 高并发 线程池连接池</title>
    <url>/2021/01/02/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E9%AB%98%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>高并发</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>亿级流量网站架构 高并发 队列</title>
    <url>/2021/01/02/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E9%AB%98%E5%B9%B6%E5%8F%91-%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>高并发</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式 ID</title>
    <url>/2021/01/02/%E5%88%86%E5%B8%83%E5%BC%8F-ID/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>使用ThreadLocal创建线程上下文</title>
    <url>/2020/12/26/%E4%BD%BF%E7%94%A8ThreadLocal%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<h1 id="使用ThreadLocal创建线程上下文"><a href="#使用ThreadLocal创建线程上下文" class="headerlink" title="使用ThreadLocal创建线程上下文"></a>使用ThreadLocal创建线程上下文</h1><a id="more"></a>

<h2 id="1-定义上下文接口"><a href="#1-定义上下文接口" class="headerlink" title="1 定义上下文接口"></a>1 定义上下文接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加属性</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(String key, Object object)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得属性</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">get</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-定义上下文实现类"><a href="#2-定义上下文实现类" class="headerlink" title="2 定义上下文实现类"></a>2 定义上下文实现类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskThreadContext</span> <span class="keyword">implements</span> <span class="title">ThreadContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 订单id */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> orderId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 任务开始执行时间 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> startTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** task context map */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; taskContextMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String key, Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == taskContextMap) &#123;</span><br><span class="line">            taskContextMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        taskContextMap.put(key, object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == taskContextMap) &#123;</span><br><span class="line">            taskContextMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> taskContextMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrderId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderId</span><span class="params">(<span class="keyword">int</span> orderId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderId = orderId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getStartTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStartTime</span><span class="params">(<span class="keyword">long</span> startTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.startTime = startTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-定义ThreadContext持有类"><a href="#3-定义ThreadContext持有类" class="headerlink" title="3 定义ThreadContext持有类"></a>3 定义ThreadContext持有类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskContextHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** task context threadLocal */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ThreadContext&gt; TASK_CONTEXT = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadContext <span class="title">getTaskContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (TASK_CONTEXT.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            TASK_CONTEXT.set(<span class="keyword">new</span> TaskThreadContext());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> TASK_CONTEXT.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setTaskContext</span><span class="params">(ThreadContext taskContext)</span> </span>&#123;</span><br><span class="line">        TASK_CONTEXT.set(taskContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String key, Object param)</span> </span>&#123;</span><br><span class="line">        getTaskContext().add(key, param);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getTaskContext().get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4 测试"></a>4 测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程t1</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 添加上下文</span></span><br><span class="line">            TaskThreadContext context = <span class="keyword">new</span> TaskThreadContext();</span><br><span class="line">            context.setOrderId(<span class="number">1</span>);</span><br><span class="line">            TaskContextHolder.setTaskContext(context);</span><br><span class="line">            <span class="comment">// 添加普通属性</span></span><br><span class="line">            TaskContextHolder.add(<span class="string">&quot;t1&quot;</span>, <span class="string">&quot;Hello t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">            TaskThreadContext taskContext = (TaskThreadContext) TaskContextHolder.getTaskContext();</span><br><span class="line">            System.out.println(<span class="string">&quot;t1 order id：&quot;</span> + taskContext.getOrderId());</span><br><span class="line">            System.out.println(<span class="string">&quot;t1：&quot;</span> + TaskContextHolder.get(<span class="string">&quot;t1&quot;</span>));</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程t2</span></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 添加上下文</span></span><br><span class="line">            TaskThreadContext context = <span class="keyword">new</span> TaskThreadContext();</span><br><span class="line">            context.setOrderId(<span class="number">2</span>);</span><br><span class="line">            TaskContextHolder.setTaskContext(context);</span><br><span class="line">            <span class="comment">// 添加普通属性</span></span><br><span class="line">            TaskContextHolder.add(<span class="string">&quot;t2&quot;</span>, <span class="string">&quot;Hello t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">            TaskThreadContext taskContext = (TaskThreadContext) TaskContextHolder.getTaskContext();</span><br><span class="line">            System.out.println(<span class="string">&quot;t2 order id：&quot;</span> + taskContext.getOrderId());</span><br><span class="line">            System.out.println(<span class="string">&quot;t2：&quot;</span> + TaskContextHolder.get(<span class="string">&quot;t2&quot;</span>));</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t1 order id：1</span><br><span class="line">t1：Hello t1</span><br><span class="line">t2 order id：2</span><br><span class="line">t2：Hello t2</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>ThreadLocal</tag>
        <tag>上下文</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事物</title>
    <url>/2021/01/02/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E7%89%A9/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>分布式锁</title>
    <url>/2021/01/02/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>项目启动加载配置类型数据至内存</title>
    <url>/2020/12/25/%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E8%87%B3%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h1 id="项目启动加载配置类型数据至内存"><a href="#项目启动加载配置类型数据至内存" class="headerlink" title="项目启动加载配置类型数据至内存"></a>项目启动加载配置类型数据至内存</h1><a id="more"></a>

<p>一般数据分类</p>
<ul>
<li>流水型数据</li>
<li>状态型数据</li>
<li>配置型数据。</li>
</ul>
<p>对于配置型数据而言，改动不是很频繁，可以在项目启动的时候直接加载到内存，避免需要数据时去查询数据库，造成不必要的IO消耗。<br>配置类型的数据可以在数据库中存储，也可以托管至github。<br>下图是启动时加载数据的原理图：<br><img src="https://img2020.cnblogs.com/blog/2029601/202012/2029601-20201219215901828-1492959658.png"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Redis 基本数据类型 String</title>
    <url>/2020/12/26/Redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-String/</url>
    <content><![CDATA[<h1 id="Redis-Strings"><a href="#Redis-Strings" class="headerlink" title="Redis Strings"></a>Redis Strings</h1><h2 id="1-Strings-简介"><a href="#1-Strings-简介" class="headerlink" title="1 Strings 简介"></a>1 Strings 简介</h2><p>官网：</p>
<p>这是最简单Redis类型。如果你只用这种类型，Redis就像一个可以持久化的memcached服务器</p>
<a id="more"></a>

<h2 id="2-String-命令"><a href="#2-String-命令" class="headerlink" title="2 String 命令"></a>2 String 命令</h2><h3 id="2-1-help-string"><a href="#2-1-help-string" class="headerlink" title="2.1 help @string"></a>2.1 help @string</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @string</span><br><span class="line"></span><br><span class="line">  APPEND key value</span><br><span class="line">  summary: Append a value to a key</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  BITCOUNT key [start end]</span><br><span class="line">  summary: Count set bits in a string</span><br><span class="line">  since: 2.6.0</span><br><span class="line"></span><br><span class="line">  BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]</span><br><span class="line">  summary: Perform arbitrary bitfield integer operations on strings</span><br><span class="line">  since: 3.2.0</span><br><span class="line"></span><br><span class="line">  BITOP operation destkey key [key ...]</span><br><span class="line">  summary: Perform bitwise operations between strings</span><br><span class="line">  since: 2.6.0</span><br><span class="line"></span><br><span class="line">  BITPOS key bit [start] [end]</span><br><span class="line">  summary: Find first bit set or clear in a string</span><br><span class="line">  since: 2.8.7</span><br><span class="line"></span><br><span class="line">  DECR key</span><br><span class="line">  summary: Decrement the integer value of a key by one</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  DECRBY key decrement</span><br><span class="line">  summary: Decrement the integer value of a key by the given number</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  GET key</span><br><span class="line">  summary: Get the value of a key</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  GETBIT key offset</span><br><span class="line">  summary: Returns the bit value at offset in the string value stored at key</span><br><span class="line">  since: 2.2.0</span><br><span class="line"></span><br><span class="line">  GETRANGE key start end</span><br><span class="line">  summary: Get a substring of the string stored at a key</span><br><span class="line">  since: 2.4.0</span><br><span class="line"></span><br><span class="line">  GETSET key value</span><br><span class="line">  summary: Set the string value of a key and return its old value</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  INCR key</span><br><span class="line">  summary: Increment the integer value of a key by one</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  INCRBY key increment</span><br><span class="line">  summary: Increment the integer value of a key by the given amount</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  INCRBYFLOAT key increment</span><br><span class="line">  summary: Increment the float value of a key by the given amount</span><br><span class="line">  since: 2.6.0</span><br><span class="line"></span><br><span class="line">  MGET key [key ...]</span><br><span class="line">  summary: Get the values of all the given keys</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  MSET key value [key value ...]</span><br><span class="line">  summary: Set multiple keys to multiple values</span><br><span class="line">  since: 1.0.1</span><br><span class="line"></span><br><span class="line">  MSETNX key value [key value ...]</span><br><span class="line">  summary: Set multiple keys to multiple values, only if none of the keys exist</span><br><span class="line">  since: 1.0.1</span><br><span class="line"></span><br><span class="line">  PSETEX key milliseconds value</span><br><span class="line">  summary: Set the value and expiration in milliseconds of a key</span><br><span class="line">  since: 2.6.0</span><br><span class="line"></span><br><span class="line">  SET key value [expiration EX seconds|PX milliseconds] [NX|XX]</span><br><span class="line">  summary: Set the string value of a key</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SETBIT key offset value</span><br><span class="line">  summary: Sets or clears the bit at offset in the string value stored at key</span><br><span class="line">  since: 2.2.0</span><br><span class="line"></span><br><span class="line">  SETEX key seconds value</span><br><span class="line">  summary: Set the value and expiration of a key</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  SETNX key value</span><br><span class="line">  summary: Set the value of a key, only if the key does not exist</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SETRANGE key offset value</span><br><span class="line">  summary: Overwrite part of a string at key starting at the specified offset</span><br><span class="line">  since: 2.2.0</span><br><span class="line"></span><br><span class="line">  STRLEN key</span><br><span class="line">  summary: Get the length of the value stored in a key</span><br><span class="line">  since: 2.2.0</span><br></pre></td></tr></table></figure>
<h3 id="2-2-Strings字符串操作命令详解"><a href="#2-2-Strings字符串操作命令详解" class="headerlink" title="2.2 Strings字符串操作命令详解"></a>2.2 Strings字符串操作命令详解</h3><h4 id="2-2-1-SET-amp-GET"><a href="#2-2-1-SET-amp-GET" class="headerlink" title="2.2.1 SET&amp;GET"></a>2.2.1 SET&amp;GET</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help set</span><br><span class="line"></span><br><span class="line">  SET key value [EX seconds] [PX milliseconds] [NX|XX]</span><br><span class="line">  summary: Set the string value of a key</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: string</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help get</span><br><span class="line"></span><br><span class="line">  GET key</span><br><span class="line">  summary: Get the value of a key</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>通常用SET command 和 GET command来设置和获取字符串值，值可以是任何种类的字符串（包括二进制数据）</p>
<ul>
<li><p>EX：过期时间</p>
</li>
<li><p>PX：时间单位</p>
</li>
<li><p>NX ：key未创建时则创建，已经创建时不创建。</p>
<p>用处：分布式锁，一堆人都想删一个文件，很多链接对单线程redis操作，谁成功就拿到锁，其余人失败</p>
</li>
<li><p>XX：只能更新，key存在时更新，key不存在时不能更新</p>
</li>
</ul>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span>测试</span></span><br><span class="line">127.0.0.1:6379&gt; set k1 hello</span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash"> get测试</span></span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;hello&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> nx测试</span></span><br><span class="line">127.0.0.1:6379&gt; set k1 ooxx nx</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;hello&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> xx测试</span></span><br><span class="line">127.0.0.1:6379&gt; set k2 hello xx</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<h4 id="2-2-2-MSET-amp-MGET"><a href="#2-2-2-MSET-amp-MGET" class="headerlink" title="2.2.2 MSET&amp;MGET"></a>2.2.2 MSET&amp;MGET</h4><p>同时设置一个或多个 key-value 对。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help mset</span><br><span class="line"></span><br><span class="line">  MSET key value [key value ...]</span><br><span class="line">  summary: Set multiple keys to multiple values</span><br><span class="line">  since: 1.0.1</span><br><span class="line">  group: string</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help mget</span><br><span class="line"></span><br><span class="line">  MGET key [key ...]</span><br><span class="line">  summary: Get the values of all the given keys</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置[k3,a]，[k4,b]</span></span><br><span class="line">127.0.0.1:6379&gt; mset k3 a k4 b</span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取k3，k4的value</span></span><br><span class="line">127.0.0.1:6379&gt; mget k3 k4</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-3-APPEND"><a href="#2-2-3-APPEND" class="headerlink" title="2.2.3 APPEND"></a>2.2.3 APPEND</h4><p>如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help append</span><br><span class="line"></span><br><span class="line">  APPEND key value</span><br><span class="line">  summary: Append a value to a key</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; append k1 &quot; world&quot;</span><br><span class="line">(integer) 11</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;hello world&quot;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-4-GETRANGE-amp-SETRANGE"><a href="#2-2-4-GETRANGE-amp-SETRANGE" class="headerlink" title="2.2.4 GETRANGE&amp;SETRANGE"></a>2.2.4 GETRANGE&amp;SETRANGE</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help getrange</span><br><span class="line"></span><br><span class="line">  GETRANGE key start end</span><br><span class="line">  summary: Get a substring of the string stored at a key</span><br><span class="line">  since: 2.4.0</span><br><span class="line">  group: string</span><br><span class="line">  </span><br><span class="line">127.0.0.1:6379&gt; help setrange</span><br><span class="line"></span><br><span class="line">  SETRANGE key offset value</span><br><span class="line">  summary: Overwrite part of a string at key starting at the specified offset</span><br><span class="line">  since: 2.2.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>GETRANGE：获取存储在指定 key 中字符串的子字符串。字符串的截取范围由 start 和 end 两个偏移量决定(包括 start 和 end 在内)。</p>
<p>SETRANGE：用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 此时k1 value=<span class="string">&quot;hello world&quot;</span></span></span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;hello world&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取子字符串<span class="string">&quot;world&quot;</span></span></span><br><span class="line">127.0.0.1:6379&gt; GETRANGE k1 6 10</span><br><span class="line">&quot;world&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 逆向索引取值</span></span><br><span class="line">127.0.0.1:6379&gt; GETRANGE k1 6 -1</span><br><span class="line">&quot;world&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 正向索引取值</span></span><br><span class="line">127.0.0.1:6379&gt; GETRANGE k1 0 -1</span><br><span class="line">&quot;hello world&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> SETRANGE</span></span><br><span class="line">127.0.0.1:6379&gt; SETRANGE k1 6 yeyangshu</span><br><span class="line">(integer) 15</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;hello yeyangshu&quot;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-5-STRLEN"><a href="#2-2-5-STRLEN" class="headerlink" title="2.2.5 STRLEN"></a>2.2.5 STRLEN</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help strlen</span><br><span class="line"></span><br><span class="line">  STRLEN key</span><br><span class="line">  summary: Get the length of the value stored in a key</span><br><span class="line">  since: 2.2.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>获取指定 key 所储存的字符串值的长度。当 key 储存的不是字符串值时，返回一个错误。</p>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;hello yeyangshu&quot;</span><br><span class="line">127.0.0.1:6379&gt; STRLEN k1</span><br><span class="line">(integer) 15</span><br></pre></td></tr></table></figure>
<h4 id="2-2-6-GETSET"><a href="#2-2-6-GETSET" class="headerlink" title="2.2.6 GETSET"></a>2.2.6 GETSET</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help getset</span><br><span class="line"></span><br><span class="line">  GETSET key value</span><br><span class="line">  summary: Set the string value of a key and return its old value</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>设置指定 key 的值，并返回 key 的旧值。</p>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GET k1</span><br><span class="line">&quot;100&quot;</span><br><span class="line">127.0.0.1:6379&gt; GETSET k1 200</span><br><span class="line">&quot;100&quot;</span><br><span class="line">127.0.0.1:6379&gt; GET k1</span><br><span class="line">&quot;200&quot;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-7-MSETNX"><a href="#2-2-7-MSETNX" class="headerlink" title="2.2.7 MSETNX"></a>2.2.7 MSETNX</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help MSETNX</span><br><span class="line"></span><br><span class="line">  MSETNX key value [key value ...]</span><br><span class="line">  summary: Set multiple keys to multiple values, only if none of the keys exist</span><br><span class="line">  since: 1.0.1</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都<strong>不存在</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置k1、k2的值</span></span><br><span class="line">127.0.0.1:6379&gt; MSETNX k1 a k2 b</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; MGET k1 k2</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置k2、k3的值，k2已经存在整体返回失败</span></span><br><span class="line">127.0.0.1:6379&gt; MSETNX k2 c k3 d</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>
<h3 id="2-3-Strings数值操作命令详解"><a href="#2-3-Strings数值操作命令详解" class="headerlink" title="2.3 Strings数值操作命令详解"></a>2.3 Strings数值操作命令详解</h3><h4 id="2-3-1-INCR-amp-DECR"><a href="#2-3-1-INCR-amp-DECR" class="headerlink" title="2.3.1 INCR&amp;DECR"></a>2.3.1 INCR&amp;DECR</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help incr</span><br><span class="line"></span><br><span class="line">  INCR key</span><br><span class="line">  summary: Increment the integer value of a key by one</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: string</span><br><span class="line">  </span><br><span class="line">127.0.0.1:6379&gt; help decr</span><br><span class="line"></span><br><span class="line">  DECR key</span><br><span class="line">  summary: Decrement the integer value of a key by one</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>INCR：将 key 中储存的数字值增一。</p>
<ul>
<li>如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作。</li>
<li>如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</li>
</ul>
<p>DECR：将 key 中储存的数字值减一。</p>
<ul>
<li><p>如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECR 操作。</p>
</li>
<li><p>如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</p>
</li>
</ul>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> k1原值99</span></span><br><span class="line">127.0.0.1:6379&gt; INCR k1</span><br><span class="line">(integer) 100</span><br><span class="line">127.0.0.1:6379&gt; GET k1</span><br><span class="line">&quot;100&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 不存在k6这个key</span></span><br><span class="line">127.0.0.1:6379&gt; incr k6</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get k6</span><br><span class="line">&quot;1&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> k1原值100</span></span><br><span class="line">127.0.0.1:6379&gt; DECR k1</span><br><span class="line">(integer) 99</span><br><span class="line"><span class="meta">#</span><span class="bash"> 不存在k7这个key</span></span><br><span class="line">127.0.0.1:6379&gt; DECR k7</span><br><span class="line">(integer) -1</span><br></pre></td></tr></table></figure>
<h4 id="2-3-2-INCRBY-amp-DECRBY"><a href="#2-3-2-INCRBY-amp-DECRBY" class="headerlink" title="2.3.2 INCRBY&amp;DECRBY"></a>2.3.2 INCRBY&amp;DECRBY</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help incrby</span><br><span class="line"></span><br><span class="line">  INCRBY key increment</span><br><span class="line">  summary: Increment the integer value of a key by the given amount</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: string</span><br><span class="line">  </span><br><span class="line">127.0.0.1:6379&gt; help decrby</span><br><span class="line"></span><br><span class="line">  DECRBY key decrement</span><br><span class="line">  summary: Decrement the integer value of a key by the given number</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>INCRBY：将 key 中储存的数字加上指定的增量值。</p>
<ul>
<li><p>如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCRBY 命令。</p>
</li>
<li><p>如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</p>
</li>
</ul>
<p>DECRBY：将 key 所储存的值减去指定的减量值。</p>
<ul>
<li><p>如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECRBY 操作。</p>
</li>
<li><p>如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</p>
</li>
</ul>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GET k1</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; INCRBY k1 <span class="number">10</span></span><br><span class="line">(integer) <span class="number">11</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GET k1</span><br><span class="line"><span class="string">&quot;11&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; DECRBY k1 <span class="number">10</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GET k1</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-3-3-INCRBYFLOAT"><a href="#2-3-3-INCRBYFLOAT" class="headerlink" title="2.3.3 INCRBYFLOAT"></a>2.3.3 INCRBYFLOAT</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help incrbyfloat</span><br><span class="line"></span><br><span class="line">  INCRBYFLOAT key increment</span><br><span class="line">  summary: Increment the float value of a key by the given amount</span><br><span class="line">  since: 2.6.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>INCRBYFLOAT：为 key 中所储存的值加上指定的浮点数增量值。</p>
<ul>
<li>如果 key 不存在，那么 INCRBYFLOAT 会先将 key 的值设为 0 ，再执行加法操作</li>
</ul>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GET k1</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; INCRBYFLOAT k1 1.1</span><br><span class="line">&quot;2.1&quot;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-Strings位图操作命令详解"><a href="#2-4-Strings位图操作命令详解" class="headerlink" title="2.4 Strings位图操作命令详解"></a>2.4 Strings位图操作命令详解</h3><h4 id="2-4-1-SETBIT"><a href="#2-4-1-SETBIT" class="headerlink" title="2.4.1 SETBIT"></a>2.4.1 SETBIT</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help setbit</span><br><span class="line"></span><br><span class="line">  SETBIT key offset value</span><br><span class="line">  summary: Sets or clears the bit at offset in the string value stored at key</span><br><span class="line">  since: 2.2.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</p>
<p><strong>注意：是二进制位上的偏移，非字节数组</strong></p>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 一个字节有八个二进制位，二进制的值只有0和1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将k1二进制位的第2位变为1，00000000 -&gt; 01000000</span></span><br><span class="line">127.0.0.1:6379&gt; SETBIT k1 1 1</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> k1长度为一个字节</span></span><br><span class="line">127.0.0.1:6379&gt; STRLEN k1</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 01000000在ASCII码中代表<span class="string">&#x27;@&#x27;</span></span></span><br><span class="line">127.0.0.1:6379&gt; GET k1</span><br><span class="line">&quot;@&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将k1二进制位的第8位变为1，01000000 -&gt; 01000001</span></span><br><span class="line">127.0.0.1:6379&gt; SETBIT k1 7 1</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时还没有超过8位，k1长度为1个字节</span></span><br><span class="line">127.0.0.1:6379&gt; STRLEN k1</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 01000001在ASCII码中代表<span class="string">&#x27;@&#x27;</span></span></span><br><span class="line">127.0.0.1:6379&gt; GET k1</span><br><span class="line">&quot;A&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将k1二进制位的第10位变为1，01000001 -&gt; 01000001 01000000</span></span><br><span class="line">127.0.0.1:6379&gt; SETBIT k1 9 1</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时已经超过8位，k1长度为2个字节</span></span><br><span class="line">127.0.0.1:6379&gt; STRLEN k1</span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 01000001 01000000在ASCII码中代表<span class="string">&#x27;A@&#x27;</span></span></span><br><span class="line">127.0.0.1:6379&gt; GET k1</span><br><span class="line">&quot;A@&quot;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-2-BITPOS"><a href="#2-4-2-BITPOS" class="headerlink" title="2.4.2 BITPOS"></a>2.4.2 BITPOS</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help bitpos</span><br><span class="line"></span><br><span class="line">  BITPOS key bit [start] [end]</span><br><span class="line">  summary: Find first bit set or clear in a string</span><br><span class="line">  since: 2.8.7</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>二进制位<code>1</code>在第几个字节和第几个字节之间最开始的位置</p>
<p><strong>注意：是字节，不是二进制位</strong></p>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 01000001 01000000</span></span><br><span class="line">127.0.0.1:6379&gt; GET k1</span><br><span class="line">&quot;A@&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在第一个字节中寻找二进制位为1的第一个位置，结果：下标为1的位置</span></span><br><span class="line">127.0.0.1:6379&gt; BITPOS k1 1 0 0</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在第二个字节中寻找二进制位为1的第一个位置，结果：下标为9的位置</span></span><br><span class="line">127.0.0.1:6379&gt; BITPOS k1 1 1 1</span><br><span class="line">(integer) 9</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在第一、二个字节中寻找二进制位为1的第一个位置，结果：下标为1的位置</span></span><br><span class="line">127.0.0.1:6379&gt; BITPOS k1 1 0 1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<h4 id="2-4-3-BITCOUNT"><a href="#2-4-3-BITCOUNT" class="headerlink" title="2.4.3 BITCOUNT"></a>2.4.3 BITCOUNT</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help bitcount</span><br><span class="line"></span><br><span class="line">  BITCOUNT key [start end]</span><br><span class="line">  summary: Count set bits in a string</span><br><span class="line">  since: 2.6.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>计算给定字符串中，被设置为 <code>1</code> 的比特位的数量。</p>
<ul>
<li><p>一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 <code>start</code> 或 <code>end</code> 参数，可以让计数只在特定的位上进行。</p>
</li>
<li><p>不存在的 <code>key</code> 被当成是空字符串来处理，因此对一个不存在的 <code>key</code> 进行 <code>BITCOUNT</code> 操作，结果为 <code>0</code> 。</p>
</li>
</ul>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 01000001 01000000</span></span><br><span class="line">127.0.0.1:6379&gt; GET k1</span><br><span class="line">&quot;A@&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在第一个字节中计算二进制位为1的数量，结果：2</span></span><br><span class="line">127.0.0.1:6379&gt; BITCOUNT k1 0 0</span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在第二个字节中计算二进制位为1的数量，结果：1</span></span><br><span class="line">127.0.0.1:6379&gt; BITCOUNT k1 1 1 </span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在第一、二个字节中计算二进制位为1的数量，结果：3</span></span><br><span class="line">127.0.0.1:6379&gt; BITCOUNT k1 0 1 </span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>
<h4 id="2-4-4-BITOP"><a href="#2-4-4-BITOP" class="headerlink" title="2.4.4 BITOP"></a>2.4.4 BITOP</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help bitop</span><br><span class="line"></span><br><span class="line">  BITOP operation destkey key [key ...]</span><br><span class="line">  summary: Perform bitwise operations between strings</span><br><span class="line">  since: 2.6.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>对一个或多个保存二进制位的字符串 <code>key</code> 进行位元操作，并将结果保存到 <code>destkey</code> 上。</p>
<p><code>operation</code> 可以是 <code>AND</code> 、 <code>OR</code> 、 <code>NOT</code> 、 <code>XOR</code> 这四种操作中的任意一种：</p>
<ul>
<li><code>BITOP AND destkey key [key ...]</code> ，对一个或多个 <code>key</code> 求逻辑并，并将结果保存到 <code>destkey</code> 。</li>
<li><code>BITOP OR destkey key [key ...]</code> ，对一个或多个 <code>key</code> 求逻辑或，并将结果保存到 <code>destkey</code> 。</li>
<li><code>BITOP XOR destkey key [key ...]</code> ，对一个或多个 <code>key</code> 求逻辑异或，并将结果保存到 <code>destkey</code> 。</li>
<li><code>BITOP NOT destkey key</code> ，对给定 <code>key</code> 求逻辑非，并将结果保存到 <code>destkey</code> 。</li>
</ul>
<p>除了 <code>NOT</code> 操作之外，其他操作都可以接受一个或多个 <code>key</code> 作为输入。</p>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SETBIT k1 1 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT k1 7 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;A&quot;</span><br><span class="line">127.0.0.1:6379&gt; SETBIT k2 1 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT k2 6 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">&quot;B&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 按位与计算k1、k2</span></span><br><span class="line">127.0.0.1:6379&gt; bitop and andkey k1 k2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get andkey</span><br><span class="line">&quot;@&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 按位或计算k1、k2</span></span><br><span class="line">127.0.0.1:6379&gt; bitop or orkey k1 k2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get orkey</span><br><span class="line">&quot;C&quot;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-String应用场景"><a href="#2-3-String应用场景" class="headerlink" title="2.3 String应用场景"></a>2.3 String应用场景</h2><h3 id="2-3-1-字符串"><a href="#2-3-1-字符串" class="headerlink" title="2.3.1 字符串"></a>2.3.1 字符串</h3><h3 id="2-3-2-数值"><a href="#2-3-2-数值" class="headerlink" title="2.3.2 数值"></a>2.3.2 数值</h3><h3 id="2-3-3-bitmap"><a href="#2-3-3-bitmap" class="headerlink" title="2.3.3 bitmap"></a>2.3.3 bitmap</h3><h4 id="2-3-3-1-用户系统，统计用户登陆天数，且窗口随机"><a href="#2-3-3-1-用户系统，统计用户登陆天数，且窗口随机" class="headerlink" title="2.3.3.1 用户系统，统计用户登陆天数，且窗口随机"></a>2.3.3.1 用户系统，统计用户登陆天数，且窗口随机</h4><p>公司的用户系统，统计未来用户的登陆天数，且窗口随机。比如说在电商的公司当中，统计双十一前一周和后一周用户的登陆天数。</p>
<ol>
<li><p>解决方案一：MySQL数据库</p>
<p>使用MySQL数据库，创建一张用户登录表，用户每次登录可以产生一行记录，登记登陆时间。</p>
<p>问题：</p>
<ul>
<li>关系型数据库表与表之间会有主外键或者关联，关联的 <code>id</code> 可能3、4个字节</li>
<li>成本复杂度，每张表每行需要存储一个日期，登陆时间，日期也需要至少4个字节</li>
</ul>
<p>一个用户的一笔登录就需要消耗8个字节，电商可能有几十万人，每人一年至少登陆200天，这张表的数据量可能非常大；随机窗口进行查询的时候，需要遍历所有的数据，成本非常高！</p>
</li>
<li><p>解决方案二：Redis数据库</p>
<p>成本计算，两个固定的数值，第一个固定的数值就是一年的天数，365或者366，假设一年400天，如果每一天从左向右对应一个二进制位，第一个二进制位代表第一天，第二个二进制位代表第二天，一共400个二进制位，400(位)/ 8=50(字节)，使用50个字节可以记录一个用户全年365天的登录状态。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yeyangshu第2天登录</span></span><br><span class="line">127.0.0.1:6379&gt; SETBIT yeyangshu 1 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> yeyangshu第8天登录</span></span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT yeyangshu 7 1</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> yeyangshu第365天登录</span></span><br><span class="line">127.0.0.1:6379&gt; SETBIT yeyangshu 364 1</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 计算总共占用的空间</span></span><br><span class="line">127.0.0.1:6379&gt; STRLEN yeyangshu</span><br><span class="line">(integer) 46</span><br></pre></td></tr></table></figure>
<p>统计最后两周用户登录的天数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 统计最后两周yeyangshu登陆天数</span></span><br><span class="line">127.0.0.1:6379&gt; BITCOUNT yeyangshu -2 -1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<p>优点：CPU对二进制位的计算速度是最快的，关系型数据库需要从磁盘读取文件，第一个会产生IO，第二个读取磁盘之后，需要将数据解码再参与计算，而且不是二进制位的计算</p>
</li>
</ol>
<h4 id="2-3-3-2-电商做活动，该准备多少礼物"><a href="#2-3-3-2-电商做活动，该准备多少礼物" class="headerlink" title="2.3.3.2 电商做活动，该准备多少礼物"></a>2.3.3.2 电商做活动，该准备多少礼物</h4><p>电商做活动，当天登陆就送礼物，准备多少礼物？假设电商有2亿用户，活动当天登录送礼物，每个人只能送一件，请问库存需要准备多少礼物？</p>
<p>电商里面有一个基本常识，用户分为僵尸用户、冷热用户（忠诚用户）。</p>
<p>过往一年中或同比去年的时间范围内或上一个月窗口内，网站有1亿活跃用户或100万活跃用户经常登录，其实根本不是2亿用户，所以最终的目标是活跃用户。</p>
<p>这也是需要经常做的一个统计：活跃用户统计。活跃用户统计的本质是什么？比如说1号到3号，1号里面有多少人，2号里面有多少人并且还需要去重，如何去设计？</p>
<p>需求综上：活跃用户统计，随机窗口，连续登录并且去重。</p>
<p>Redis做法</p>
<p>日期作为key，20200101，用户id映射到二进制位上。假设小明的id是10，小李的id是1000，二进制位1代表登录，二进制位0代表未登录，假设第一天只有小明登录了，<code>setbit 20200101 10 1</code>，第二天小明和小李都登陆了，<code>setbit 20200102 1000 1</code>，计算1号和2号的活跃用户。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> SETBIT date OFFSET id</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1号小明登录</span></span><br><span class="line">127.0.0.1:6379&gt; SETBIT 20200101 10 1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2号小明登录</span></span><br><span class="line">127.0.0.1:6379&gt; SETBIT 20200102 10 1</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2号小李登录</span></span><br><span class="line">127.0.0.1:6379&gt; SETBIT 20200102 1000 1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或运算，参加运算的两个对象，一个为1，其值为1，目的是统计这两天的登录人数</span></span><br><span class="line">127.0.0.1:6379&gt; BITOP or destkey 20200101 20200102</span><br><span class="line">(integer) 126</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> BITCOUNT计算出活跃人数</span></span><br><span class="line">127.0.0.1:6379&gt; BITCOUNT destkey 0 -1</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
</search>
