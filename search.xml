<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JVM class文件结构</title>
    <url>/2020/12/28/JVM-class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="class-文件结构"><a href="#class-文件结构" class="headerlink" title="class 文件结构"></a>class 文件结构</h1><a id="more"></a>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 类加载过程</title>
    <url>/2020/12/28/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><a id="more"></a>

<p>一个java文件从编码到最终运行，一般主要包括两个过程：</p>
<ul>
<li>编译：将写好的 .java 文件，通过 javac 命令编译成字节码，也就是 .class（二进制字节流） 文件。</li>
<li>运行：JVM 把编译生成好的 .class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型的过程叫做虚拟机的类加载机制。</li>
</ul>
<p>与其他语言不同，Java 类型的加载、连接和初始化是在程序运行期间完成的。</p>
<p>类加载的过程主要分为三个部分：</p>
<ul>
<li><p>加载</p>
</li>
<li><p>链接</p>
<p>而链接又可以细分为三个小部分：</p>
<ul>
<li>验证</li>
<li>准备</li>
<li>解析</li>
</ul>
</li>
<li><p>初始化</p>
</li>
</ul>
<h2 id="1-加载"><a href="#1-加载" class="headerlink" title="1 加载"></a>1 加载</h2><p>简单来说，加载指的是把 class 文件从各个来源通过类加载器加载到内存中。</p>
<p>在加载阶段，Java 虚拟机需要完成下面三件事情：</p>
<ol>
<li><p>通过一个类的全限定名来获取定义此类的二进制字节流。</p>
<ul>
<li>可以从ZIP</li>
<li>网络</li>
<li>数据库</li>
<li>其他文件生成</li>
<li>加密文件中获取</li>
</ul>
<p>Java 虚拟机并没有规定二进制字节流必须从 Class 文件中获取。</p>
</li>
<li><p>将这个字节流所代表的的静态存储结构转化为方法区的运行时数结构。</p>
</li>
<li><p>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</p>
<blockquote>
<p>什么是 Class 类？在 Java 中每个类都有一个相对应的 Class 类的对象，用于表示这个类的类型信息。</p>
</blockquote>
</li>
<li></li>
</ol>
<h2 id="2-连接"><a href="#2-连接" class="headerlink" title="2 连接"></a>2 连接</h2><h3 id="2-1-验证"><a href="#2-1-验证" class="headerlink" title="2.1 验证"></a>2.1 验证</h3><p>这一步的目的是确保 Class 文件的字节流中包含的信息是否符合《Java虚拟机规范》的全部元数要求，保证这些信息被当做运行代码不会危害虚拟机自身的安全。</p>
<ol>
<li><p>文件格式验证</p>
<ul>
<li><p>行为：验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理。</p>
</li>
<li><p>目的：该阶段的主要目的是保证输入的字节流能正确的解析并存储于方法区之内，后面的 3 个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。</p>
</li>
</ul>
</li>
<li><p>元数据验证</p>
<ul>
<li>行为：对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求。</li>
<li>目的：对类的元数据信息进行语义校验，保证不存在不符合 Java 语言规范的元数据信息。</li>
</ul>
</li>
<li><p>字节码验证</p>
<ul>
<li>目的：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。对类的方法体进行校验分析，保证被校验类在运行时不会做出危害虚拟机安全的事件。</li>
</ul>
</li>
<li><p>符号引用验证</p>
<ul>
<li>行为：符合引用可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。</li>
<li>目的：确保解析动作能正常执行。</li>
</ul>
</li>
</ol>
<h3 id="2-2-准备"><a href="#2-2-准备" class="headerlink" title="2.2 准备"></a>2.2 准备</h3><p>正式为<strong>类中定义的变量</strong>分配内存并设置类变量的<strong>初始值</strong>的阶段，这些变量所使用的内存都将在方法区中进行分配。</p>
<p>注意：</p>
<ol>
<li><p>这个时候进行内存分配的仅包括类变量（被 static 修饰的变量），并不包括实例变量。</p>
</li>
<li><p>初始值“通常情况”下是数据类型的零值。</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">零值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">oL</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">(short)0</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">‘\u0000’</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">(byte)0</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">0.0f</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">0.0d</td>
</tr>
<tr>
<td align="center">refrence</td>
<td align="center">null</td>
</tr>
</tbody></table>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>value 在准备期间就赋值为 0。</p>
<p>如果是常量的话，直接赋值为常量指定的值。</p>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>value 在准备期间就赋值为 123。</p>
</li>
</ol>
<h3 id="2-3-解析"><a href="#2-3-解析" class="headerlink" title="2.3 解析"></a>2.3 解析</h3><p>Java 虚拟机将常量池内的符号引用替换为直接引用的过程</p>
<h2 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3 初始化"></a>3 初始化</h2><p>调用类的初始化代码，给成员变量赋初始值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类初始化和静态变量初始化测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T_ClassLoadingProduce</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(T.count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 情景一</span></span><br><span class="line"><span class="comment">     * public static int count = 2;</span></span><br><span class="line"><span class="comment">     * public static T t = new T();</span></span><br><span class="line"><span class="comment">     * 结果：3</span></span><br><span class="line"><span class="comment">     * 分析：</span></span><br><span class="line"><span class="comment">     * 当调用T时，先把T Class load内存进行校验，然后进行preparation赋默认值，此时T是空值，</span></span><br><span class="line"><span class="comment">     * 然后Resolution，在进行initializing初始化赋初始值，这个时候是2，然后count++，输出3</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 情景二</span></span><br><span class="line"><span class="comment">     * public static T t = new T();</span></span><br><span class="line"><span class="comment">     * public static int count = 2;</span></span><br><span class="line"><span class="comment">     * 结果：2</span></span><br><span class="line"><span class="comment">     * 分析：</span></span><br><span class="line"><span class="comment">     * 当调用T时，先把T Class load内存进行校验，然后进行preparation赋默认值，此时T是空值，</span></span><br><span class="line"><span class="comment">     * 然后Resolution，在进行initializing初始化赋初始值，先调用new T这个时候是0，然后count++变成一，然后赋值输出结果为2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始值null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T t = <span class="keyword">new</span> T();</span><br><span class="line">    <span class="comment">// 初始值0</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">T</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 虚拟机基础概念</title>
    <url>/2020/12/28/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="虚拟机基础概念"><a href="#虚拟机基础概念" class="headerlink" title="虚拟机基础概念"></a>虚拟机基础概念</h1><a id="more"></a>

<h2 id="1-什么是虚拟机"><a href="#1-什么是虚拟机" class="headerlink" title="1 什么是虚拟机"></a>1 什么是虚拟机</h2><p>百度百科：虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java 虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java 虚拟机屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在 Java 虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</p>
<h2 id="2-流行的-Java-虚拟机"><a href="#2-流行的-Java-虚拟机" class="headerlink" title="2 流行的 Java 虚拟机"></a>2 流行的 Java 虚拟机</h2><ul>
<li><p>Hotspot</p>
<p>Oracle 官方虚拟机</p>
</li>
<li><p>JRockit</p>
</li>
<li><p> J9</p>
</li>
<li><p>Microsoft VM</p>
</li>
<li><p>Liquid VM</p>
</li>
<li><p>Taobao VM</p>
</li>
</ul>
<h2 id="3-JDK、JRE、JVM"><a href="#3-JDK、JRE、JVM" class="headerlink" title="3 JDK、JRE、JVM"></a>3 JDK、JRE、JVM</h2><ul>
<li>JVM：</li>
<li>JRE = JVM + core libraries</li>
<li>JDK = JRE + Development Kit</li>
</ul>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201228215823470.png" alt="image-20201228215823470"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java NIO 教程</title>
    <url>/2020/12/24/Java-NIO-%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Java-NIO-教程"><a href="#Java-NIO-教程" class="headerlink" title="Java NIO 教程"></a>Java NIO 教程</h1><p>本系列教程翻译自 Jakob Jenkov 的文章，原文链接：<a href="http://tutorials.jenkov.com/java-nio/index.html">http://tutorials.jenkov.com/java-nio/index.html</a></p>
<a id="more"></a>
<p>Java NIO（New IO）是 Java IO API 的替代品，意味着可以替代标准 Java IO 和 Java Networking API。 Java NIO 提供了与传统 IO API 不同的 IO 编程模型。 注意：有时 NIO 被称为是非阻塞 IO。 但是，这并不是 NIO 最初的意思。 另外，NIO API 的某些部分实际上是阻塞的，例如：文件 API，因此，“非阻塞”标签可能会引起误导。</p>
<h2 id="1-Java-NIO-Non-blocking-IO（非阻塞-IO）"><a href="#1-Java-NIO-Non-blocking-IO（非阻塞-IO）" class="headerlink" title="1 Java NIO: Non-blocking IO（非阻塞 IO）"></a>1 Java NIO: Non-blocking IO（非阻塞 IO）</h2><p>Java NIO 使您可以使用非阻塞 IO。 例如，线程可以要求通道将数据读入缓冲区，当通道将数据读入缓冲区时，线程可以执行其他操作。 一旦将数据读入缓冲区，线程就可以继续对其进行处理。 将数据写入通道时也是如此。</p>
<h2 id="2-Java-NIO-Channels-and-Buffers（通道和缓冲区）"><a href="#2-Java-NIO-Channels-and-Buffers（通道和缓冲区）" class="headerlink" title="2 Java NIO: Channels and Buffers（通道和缓冲区）"></a>2 Java NIO: Channels and Buffers（通道和缓冲区）</h2><p>标准的 IO 基于字节流和字符流进行操作的，而 NIO 是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。</p>
<h2 id="3-Java-NIO-Selectors（选择器）"><a href="#3-Java-NIO-Selectors（选择器）" class="headerlink" title="3 Java NIO: Selectors（选择器）"></a>3 Java NIO: Selectors（选择器）</h2><p>Java NIO包含“选择器”的概念。 选择器是一个对象，可以监视多个通道的事件（例如：打开连接，到达数据等）。 因此，单个线程可以监视多个通道以获取数据。</p>
<h2 id="4-Java-NIO-Concepts"><a href="#4-Java-NIO-Concepts" class="headerlink" title="4 Java NIO Concepts"></a>4 Java NIO Concepts</h2><p>与旧的 Java IO 模型相比，在 Java NIO 中需要学习几个新概念。 这些概念在下面列出：</p>
<ul>
<li><a href="http://tutorials.jenkov.com/java-nio/channels.html">Channels</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/buffers.html">Buffers</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/scatter-gather.html">Scatter - Gather</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/channel-to-channel-transfers.html">Channel to Channel Transfers</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/selectors.html">Selectors</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/file-channel.html">FileChannel</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/socketchannel.html">SocketChannel</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/server-socket-channel.html">ServerSocketChannel</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/non-blocking-server.html">Non-blocking Server Design</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/datagram-channel.html">DatagramChannel</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/pipe.html">Pipe</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/nio-vs-io.html">NIO vs. IO</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/path.html">Path</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/files.html">Files</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/asynchronousfilechannel.html">AsynchronousFileChannel</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java NIO Channel</title>
    <url>/2020/12/24/Java-NIO-Channel/</url>
    <content><![CDATA[<h1 id="Java-NIO-Channel"><a href="#Java-NIO-Channel" class="headerlink" title="Java NIO Channel"></a>Java NIO Channel</h1><p><code>Java NIO Channels</code> 类似于流，但有一些区别：</p>
<ul>
<li>可以从通道中读取数据或写入数据到通道中。流通常是单向的（读或写）。</li>
<li>通道可以异步读写。</li>
<li>通道的数据总是被读取到缓冲区中或将缓冲区中数据写入到通道。<a id="more"></a>
如上所述，将数据从通道读取到缓冲区中，然后将数据从缓冲区写入通道中。这是一个说明：</li>
</ul>
<p><img src="http://tutorials.jenkov.com/images/java-nio/overview-channels-buffers.png" alt="Java NIO：通道和缓冲区"></p>
<h2 id="1-Channel-实现"><a href="#1-Channel-实现" class="headerlink" title="1 Channel 实现"></a>1 Channel 实现</h2><p>以下是 Java NIO 中最重要的 Channel 实现：</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p><code>FileChannel</code>从文件中读取和写入数据。</p>
<p><code>DatagramChannel</code>可以通过 UDP 读取和写入网络数据。</p>
<p><code>SocketChannel</code>可以通过 TCP 读取和写入网络数据。</p>
<p><code>ServerSocketChannel</code> 可以监听新的 TCP 连接，像 Web 服务器一样，为每个新的 TCP 连接创建一个<code>SocketChannel</code>。</p>
<h2 id="2-Channel-简单示例"><a href="#2-Channel-简单示例" class="headerlink" title="2 Channel 简单示例"></a>2 Channel 简单示例</h2><p>这是一个简单示例，该示例使用 <code>FileChannel</code> 将一些数据读取到 <code>Buffer</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RandomAccessFile accessFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;data/nio-data.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">FileChannel inChannel = accessFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">// create buffer with capacity 48 bytes.</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// read into buffer</span></span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buffer);</span><br><span class="line"><span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Read &quot;</span> + bytesRead);</span><br><span class="line">    <span class="comment">// make buffer ready for read.</span></span><br><span class="line">    buffer.flip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">        <span class="comment">// read 1 byte at a time.</span></span><br><span class="line">        System.out.println((<span class="keyword">char</span>) buffer.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make buffer ready for writing.</span></span><br><span class="line">    buffer.clear();</span><br><span class="line">    bytesRead = inChannel.read(buffer);</span><br><span class="line">&#125;</span><br><span class="line">accessFile.close();</span><br></pre></td></tr></table></figure>
<p>注意 <code>buf.flip()</code> 的调用。首先，读入数据到缓冲区，然后反转 Buffer，再从 Buffer 中读取数据。在下一节有关 <code>Buffer</code> 的文档中，将对此进行详细的说明。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka主题与分区</title>
    <url>/2021/01/25/Kafka%E4%B8%BB%E9%A2%98%E4%B8%8E%E5%88%86%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="Kafka主题与分区"><a href="#Kafka主题与分区" class="headerlink" title="Kafka主题与分区"></a>Kafka主题与分区</h1><a id="more"></a>

<h2 id="1-主题的管理"><a href="#1-主题的管理" class="headerlink" title="1 主题的管理"></a>1 主题的管理</h2><p>主题的管理包括创建主题、查看主题信息、修改主题和删除主题等操作。</p>
<h3 id="1-1-创建主题"><a href="#1-1-创建主题" class="headerlink" title="1.1 创建主题"></a>1.1 创建主题</h3><h2 id="2-初识KafkaAdminClient"><a href="#2-初识KafkaAdminClient" class="headerlink" title="2 初识KafkaAdminClient"></a>2 初识KafkaAdminClient</h2><h2 id="3-分区的管理"><a href="#3-分区的管理" class="headerlink" title="3 分区的管理"></a>3 分区的管理</h2><h2 id="4-分区数的选择"><a href="#4-分区数的选择" class="headerlink" title="4 分区数的选择"></a>4 分区数的选择</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>深入理解Kafka：核心设计与实践原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Java NIO 概述</title>
    <url>/2020/12/24/Java-NIO-%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="Java-NIO-概述"><a href="#Java-NIO-概述" class="headerlink" title="Java NIO 概述"></a>Java NIO 概述</h1><p>原文链接：<a href="http://tutorials.jenkov.com/java-nio/overview.html">http://tutorials.jenkov.com/java-nio/overview.html</a></p>
<a id="more"></a>
<p>Java NIO 由以下核心组件组成：</p>
<ul>
<li>通道</li>
<li>缓冲区</li>
<li>选择器</li>
</ul>
<p>Java NIO 拥有比这些更多的类和组件，但在我看来 <code>Channel</code>，<code>Buffer</code>  和 <code>Selector</code>构成了 API 的核心。其余组件，例如  <code>Pipe</code> 和 <code>FileLock</code> 仅仅是与三个核心组件结合使用的实用程序类。因此，在本 NIO 概述中，我将重点介绍这三个组件。其他组件在本教程的其他地方以其自己的文本进行了说明。</p>
<h2 id="1-通道（Channel）和缓冲区（Buffer）"><a href="#1-通道（Channel）和缓冲区（Buffer）" class="headerlink" title="1 通道（Channel）和缓冲区（Buffer）"></a>1 通道（Channel）和缓冲区（Buffer）</h2><p>通常，NIO 中的所有 IO 都从一个 <code>Channel</code> 开始。<code>Channel</code>有点像流。<code>Channel</code> 中的数据可以读入到一个<code>Buffer</code>。数据也可以从一个<code>Buffer</code>写入到<code>Channel</code>。如下图所示：</p>
<p><img src="http://tutorials.jenkov.com/images/java-nio/overview-channels-buffers.png" alt="Java NIO：通道和缓冲区"></p>
<p>Java NIO：通道将数据读取到缓冲区中，缓冲区将数据写入通道中</p>
<p>Java中有几种<code>Channel</code>和<code>Buffer</code>类型。这是<code>Channel</code>Java NIO中主要实现的列表：</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p>如您所见，这些通道涵盖 UDP + TCP 网络 IO 和文件 IO。</p>
<p>这些类也有一些有趣的接口，但是为了简单起见，我将它们排除在 Java NIO 概述之外。在本 Java NIO 教程的其他文本中将对它们进行解释。</p>
<p>这是 Java NIO 中 <code>Buffer</code> 的关键的实现：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>这些 <code>Buffer</code> 包括了您可以通过 IO 发送的基本数据类型：byte, short, int, long, float, double 和 char。</p>
<p>Java NIO 还有与内存映射文件结合使用的 <code>MappedByteBuffer</code> ，不过，不在 <code>Buffer</code>  概述中说明。</p>
<h2 id="2-选择器（Selectors）"><a href="#2-选择器（Selectors）" class="headerlink" title="2 选择器（Selectors）"></a>2 选择器（Selectors）</h2><p><code>Selector</code> 允许单线程处理多个 <code>Channel</code>。如果您的应用程序打开了很多个连接（通道），但每个连接的流量很少，使用 <code>Selector</code> 就会很方便。例如，在聊天服务器中。</p>
<p>这是使用一个 <code>Selector</code> 来处理 3 个 <code>Channel</code> 的示意图：</p>
<p><img src="http://tutorials.jenkov.com/images/java-nio/overview-selectors.png" alt="Java NIO：选择器"></p>
<p>要想使用 <code>Selector</code>，需要向 <code>Selector</code> 注册 <code>Channel</code>，然后，调用  <code>select()</code> 方法。该方法会一直阻塞，直到有一个已注册通道有事件准备就绪。方法返回后，线程就会处理这些事件。事件可以是传入连接，接收到的数据等。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka基本概念</title>
    <url>/2021/01/24/Kafka%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="Kafka基本概念"><a href="#Kafka基本概念" class="headerlink" title="Kafka基本概念"></a>Kafka基本概念</h1><a id="more"></a>

<h2 id="Kafka-是什么？"><a href="#Kafka-是什么？" class="headerlink" title="Kafka 是什么？"></a>Kafka 是什么？</h2><h2 id="Kafka-基础架构"><a href="#Kafka-基础架构" class="headerlink" title="Kafka 基础架构"></a>Kafka 基础架构</h2><p>一个典型的 Kafka 体系架构包括：</p>
<h3 id="ZooKeeper集群"><a href="#ZooKeeper集群" class="headerlink" title="ZooKeeper集群"></a>ZooKeeper集群</h3><p>ZooKeeper 是 Kafka 用来负责集群元数据的管理、控制器的选举等操作的。</p>
<h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>生产者，也就是发送消息的一方。生产者负责创建消息，然后将其投递到Kafka中。</p>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>消费者，也就是接收消息的一方。消费者连接到Kafka上并接收消息，进而进行相应的业务逻辑处理。</p>
<h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><p>服务代理节点。对于 Kafka 而言，Broker 可以简单地看作一个独立的 Kafka 服务节点或 Kafka 服务实例。</p>
<h2 id="Kafka-基本术语"><a href="#Kafka-基本术语" class="headerlink" title="Kafka 基本术语"></a>Kafka 基本术语</h2><h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><p>Kafka 将消息分门别类，每一类的消息称之为一个主题（Topic）。 </p>
<h3 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h3><p>对于每个 topic，Kafka 集群都会维护一个分区 log</p>
<p><img src="https://img.orchome.com/group1/M00/00/01/KmCudlf7DsaAVF0WAABMe0J0lv4158.png" alt="img"></p>
<h3 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h3><p>offset 是消息在分区中的唯一标识，Kafka 通过它来保证消息在分区内的顺序性，不过 offset 并不跨越分区，Kafka 保证的是分区有序而不是主题有序。</p>
<p>Kafka集群保持所有的消息，直到它们过期（无论消息是否被消费）。实际上消费者所持有的仅有的元数据就是这个offset（偏移量），也就是说offset由消费者来控制：正常情况当消费者消费消息的时候，偏移量也线性的的增加。但是实际偏移量由消费者控制，消费者可以将偏移量重置为更早的位置，重新读取消息。可以看到这种设计对消费者来说操作自如，一个消费者的操作不会影响其它消费者对此log的处理。</p>
<p><img src="https://img.orchome.com/group1/M00/00/01/KmCudlf7D2iALXG_AAIhinsLf_Q676.png" alt="img"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>深入理解Kafka：核心设计与实践原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka消费者</title>
    <url>/2021/01/24/Kafka%E6%B6%88%E8%B4%B9%E8%80%85/</url>
    <content><![CDATA[<h1 id="Kafka消费者"><a href="#Kafka消费者" class="headerlink" title="Kafka消费者"></a>Kafka消费者</h1><a id="more"></a>

<p>消费者（Consumer）负责订阅Kafka中的主题（Topic），并且从订阅的主题上拉取消息。在Kafka的消费理念中还有一层消费组（Consumer Group）的概念，每个消费者都有一个对应的消费组。当消息发布到主题后，只会被投递给订阅它的每个消费组中的一个消费者。也就是每一个分区只能被一个消费组中的一个消费者所消费。</p>
<p>对于消息中间件而言，一般有两种消息投递模式：</p>
<ul>
<li><p>点对点（P2P，Point-to-Point）模式</p>
<p>如果所有的消费者都隶属于同一个消费组，那么所有的消息都会被均衡地投递给每一个消费者，即每条消息只会被一个消费者处理，这就相当于点对点模式的应用。</p>
</li>
<li><p>发布/订阅（Pub/Sub）模式。</p>
<p>·如果所有的消费者都隶属于不同的消费组，那么所有的消息都会被广播给所有的消费者，即每条消息会被所有的消费者处理，这就相当于发布/订阅模式的应用。</p>
</li>
</ul>
<h2 id="1-简要消费步骤"><a href="#1-简要消费步骤" class="headerlink" title="1 简要消费步骤"></a>1 简要消费步骤</h2><p>一个正常的消费逻辑需要具备以下几个步骤：</p>
<ol>
<li>配置消费者客户端参数及创建相应的消费者实例。</li>
<li>订阅主题。</li>
<li>拉取消息并消费。</li>
<li>提交消费位移。</li>
<li>关闭消费者实例。</li>
</ol>
<p>代码示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerOffset</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 配置属性信息</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// bootstrap.servers，必填，服务器参数</span></span><br><span class="line">        properties.setProperty(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;node02:9092,node03:9092,node04:9092&quot;</span>);</span><br><span class="line">        <span class="comment">// key.deserializer，必填，key反序列化操作的序列化器</span></span><br><span class="line">        properties.setProperty(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">        <span class="comment">// value.deserializer，必填，value反序列化操作的序列化器</span></span><br><span class="line">        properties.setProperty(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">        <span class="comment">// group.id，必填，消费者隶属的消费组的名称</span></span><br><span class="line">        properties.setProperty(ConsumerConfig.GROUP_ID_CONFIG, <span class="string">&quot;g1&quot;</span>);</span><br><span class="line">        <span class="comment">// auto.offset.reset，默认提交方式</span></span><br><span class="line">        properties.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, <span class="string">&quot;latest&quot;</span>);</span><br><span class="line">        <span class="comment">// 2 创建Kafka consumer</span></span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 消费者订阅topics</span></span><br><span class="line">        consumer.subscribe(Arrays.asList(<span class="string">&quot;topic01&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 拉取消息并消费</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                ConsumerRecords&lt;String, String&gt; consumerRecords = consumer.poll(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span> (!consumerRecords.isEmpty()) &#123;</span><br><span class="line">                    Iterator&lt;ConsumerRecord&lt;String, String&gt;&gt; recordIterator = consumerRecords.iterator();</span><br><span class="line">                    <span class="keyword">while</span> (recordIterator.hasNext()) &#123;</span><br><span class="line">                        ConsumerRecord&lt;String, String&gt; record = recordIterator.next();</span><br><span class="line">                        String topic = record.topic();</span><br><span class="line">                        <span class="keyword">int</span> partition = record.partition();</span><br><span class="line">                        <span class="keyword">long</span> offset = record.offset();</span><br><span class="line">                        String key = record.key();</span><br><span class="line">                        String value = record.value();</span><br><span class="line">                        <span class="keyword">long</span> timestamp = record.timestamp();</span><br><span class="line">                        System.out.println(topic + <span class="string">&quot;\t&quot;</span> + partition + <span class="string">&quot;\t&quot;</span> + key + <span class="string">&quot;\t&quot;</span> + value + timestamp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭消费者实例</span></span><br><span class="line">            consumer.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-配置属性信息，创建Kafka-consumer"><a href="#2-配置属性信息，创建Kafka-consumer" class="headerlink" title="2 配置属性信息，创建Kafka consumer"></a>2 配置属性信息，创建Kafka consumer</h2><p>注意必填选项</p>
<h3 id="2-1-反序列化器"><a href="#2-1-反序列化器" class="headerlink" title="2.1 反序列化器"></a>2.1 反序列化器</h3><h4 id="2-1-1-默认反序列化器"><a href="#2-1-1-默认反序列化器" class="headerlink" title="2.1.1 默认反序列化器"></a>2.1.1 默认反序列化器</h4><p>在 <code>org.apache.kafka.common.serialization</code> 包下有各种各样的反序列化器</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20210124225943680.png" alt="image-20210124225943680"></p>
<h4 id="2-1-2-自定义反序列化器"><a href="#2-1-2-自定义反序列化器" class="headerlink" title="2.1.2 自定义反序列化器"></a>2.1.2 自定义反序列化器</h4><p>如果需要自定义序列化器，需要实现 <code>Deserializer</code> 接口，重写 <code>deserialize</code> 方法。</p>
<h3 id="2-2-指定位移消费"><a href="#2-2-指定位移消费" class="headerlink" title="2.2 指定位移消费"></a>2.2 指定位移消费</h3><p>当一个新的消费组建立的时候，没有可以查找的消费位移。在 Kafka 中每当消费者查找不到所记录的消费位移时，就会根据消费者客户端参数auto.offset.reset的配置来决定从何处开始进行消费，这个参数的默认值为“latest”，表示从分区末尾开始消费消息。</p>
<p>消费位移可选属性：</p>
<ul>
<li>latest</li>
<li>earliest</li>
<li>none</li>
</ul>
<h4 id="2-2-1-seek-，从特定的位移处开始拉取消息"><a href="#2-2-1-seek-，从特定的位移处开始拉取消息" class="headerlink" title="2.2.1 seek()，从特定的位移处开始拉取消息"></a>2.2.1 seek()，从特定的位移处开始拉取消息</h4><h3 id="2-3-消费者拦截器"><a href="#2-3-消费者拦截器" class="headerlink" title="2.3 消费者拦截器"></a>2.3 消费者拦截器</h3><h4 id="2-3-1-自定义消费者拦截器"><a href="#2-3-1-自定义消费者拦截器" class="headerlink" title="2.3.1 自定义消费者拦截器"></a>2.3.1 自定义消费者拦截器</h4><h2 id="3-订阅主题与分区"><a href="#3-订阅主题与分区" class="headerlink" title="3  订阅主题与分区"></a>3  订阅主题与分区</h2><h3 id="3-1-订阅主题"><a href="#3-1-订阅主题" class="headerlink" title="3.1 订阅主题"></a>3.1 订阅主题</h3><p>一个消费者可以订阅一个或多个主题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以以集合的形式订阅多个主题</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Collection&lt;String&gt; topics)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subscribe((Collection)topics, <span class="keyword">new</span> NoOpConsumerRebalanceListener());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以以正则表达式的形式订阅特定模式的主题</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Pattern pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subscribe((Pattern)pattern, <span class="keyword">new</span> NoOpConsumerRebalanceListener());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再均衡监听器的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Pattern pattern, ConsumerRebalanceListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.maybeThrowInvalidGroupIdException();</span><br><span class="line">    <span class="keyword">if</span> (pattern == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Topic pattern to subscribe to cannot be null&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.acquireAndEnsureOpen();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.throwIfNoAssignorsConfigured();</span><br><span class="line">            <span class="keyword">this</span>.log.info(<span class="string">&quot;Subscribed to pattern: &#x27;&#123;&#125;&#x27;&quot;</span>, pattern);</span><br><span class="line">            <span class="keyword">this</span>.subscriptions.subscribe(pattern, listener);</span><br><span class="line">            <span class="keyword">this</span>.metadata.needMetadataForAllTopics(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">this</span>.coordinator.updatePatternSubscription(<span class="keyword">this</span>.metadata.fetch());</span><br><span class="line">            <span class="keyword">this</span>.metadata.requestUpdate();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-1-再均衡，ConsumerRebalanceListener"><a href="#3-1-1-再均衡，ConsumerRebalanceListener" class="headerlink" title="3.1.1 再均衡，ConsumerRebalanceListener"></a>3.1.1 再均衡，ConsumerRebalanceListener</h4><h3 id="3-2-订阅分区"><a href="#3-2-订阅分区" class="headerlink" title="3.2 订阅分区"></a>3.2 订阅分区</h3><p>可以使用 <code>assign()</code> 方法直接订阅某些主题的特定分区</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assign</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 源码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TopicPartition类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicPartition</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">613627415771699627L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 分区所属的编号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> partition;</span><br><span class="line">    <span class="comment">// 分区所属的主题</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String topic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>案例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">consumer.assign(Arrays.asList(<span class="keyword">new</span> TopicPartition(<span class="string">&quot;topic01&quot;</span>, <span class="number">1</span>)));</span><br></pre></td></tr></table></figure>
<h2 id="4-拉取消息并消费"><a href="#4-拉取消息并消费" class="headerlink" title="4 拉取消息并消费"></a>4 拉取消息并消费</h2><h3 id="4-1-消息消费模式"><a href="#4-1-消息消费模式" class="headerlink" title="4.1 消息消费模式"></a>4.1 消息消费模式</h3><p>消息的消费一般有两种模式：</p>
<ul>
<li><p>推模式（push）</p>
<p>推模式是服务端主动将消息推送给消费者</p>
</li>
<li><p>拉模式（poll）</p>
<p>拉模式是消费者主动向服务端发起请求来拉取消息</p>
</li>
</ul>
<p>Kafka中的消费是基于拉模式的。</p>
<p>Kafka中的消息消费是一个不断轮询的过程，消费者所要做的就是重复地调用poll()方法，而poll()方法返回的是所订阅的主题（分区）上的一组消息。</p>
<p>poll源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ConsumerRecords&lt;K, V&gt; <span class="title">poll</span><span class="params">(<span class="keyword">final</span> Timer timer, <span class="keyword">final</span> <span class="keyword">boolean</span> includeMetadataInTimeout)</span> </span>&#123;</span><br><span class="line">    acquireAndEnsureOpen();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.subscriptions.hasNoSubscriptionOrUserAssignment()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Consumer is not subscribed to any topics or assigned any partitions&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// poll for new data until the timeout expires</span></span><br><span class="line">        <span class="comment">// 没有超时的话会一直循环</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            client.maybeTriggerWakeup();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (includeMetadataInTimeout) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!updateAssignmentMetadataIfNeeded(timer)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ConsumerRecords.empty();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!updateAssignmentMetadataIfNeeded(time.timer(Long.MAX_VALUE))) &#123;</span><br><span class="line">                    log.warn(<span class="string">&quot;Still waiting for metadata&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在timer时间内拉取一次消息</span></span><br><span class="line">            <span class="keyword">final</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records = pollForFetches(timer);</span><br><span class="line">            <span class="keyword">if</span> (!records.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// before returning the fetched records, we can send off the next round of fetches</span></span><br><span class="line">                <span class="comment">// and avoid block waiting for their responses to enable pipelining while the user</span></span><br><span class="line">                <span class="comment">// is handling the fetched records.</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// <span class="doctag">NOTE:</span> since the consumed position has already been updated, we must not allow</span></span><br><span class="line">                <span class="comment">// wakeups or any other errors to be triggered prior to returning the fetched records.</span></span><br><span class="line">                <span class="keyword">if</span> (fetcher.sendFetches() &gt; <span class="number">0</span> || client.hasPendingRequests()) &#123;</span><br><span class="line">                    client.pollNoWakeup();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.interceptors.onConsume(<span class="keyword">new</span> ConsumerRecords&lt;&gt;(records));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (timer.notExpired());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ConsumerRecords.empty();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-提交消费位移"><a href="#5-提交消费位移" class="headerlink" title="5 提交消费位移"></a>5 提交消费位移</h2><p>在每次调用poll()方法时，它返回的是还没有被消费过的消息集，要做到这一点，就需要记录上一次消费时的消费位移。并且这个消费位移必须做持久化保存，而不是单单保存在内存中，否则消费者重启之后就无法知晓之前的消费位移。</p>
<h3 id="5-1-自动位移提交"><a href="#5-1-自动位移提交" class="headerlink" title="5.1 自动位移提交"></a>5.1 自动位移提交</h3><p>在 Kafka 中默认的消费位移的提交方式是自动提交，这个由消费者客户端参数enable.auto.commit 配置，默认值为 true。当然这个默认的自动提交不是每消费一条消息就提交一次，而是定期提交，这个定期的周期时间由客户端参数auto.commit.interval.ms配置，默认值为5秒，此参数生效的前提是enable.auto.commit参数为true。</p>
<p>在默认的方式下，消费者每隔5秒会将拉取到的每个分区中最大的消息位移进行提交。自动位移提交的动作是在poll()方法的逻辑里完成的，在每次真正向服务端发起拉取请求之前会检查是否可以进行位移提交，如果可以，那么就会提交上一次轮询的位移。</p>
<h3 id="5-2-手动位移提交"><a href="#5-2-手动位移提交" class="headerlink" title="5.2 手动位移提交"></a>5.2 手动位移提交</h3><p>开启手动提交功能的前提是消费者客户端参数enable.auto.commit配置为false。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">enable.auto.commit</span> = <span class="string">false</span></span><br></pre></td></tr></table></figure>
<p>手动提交可以细分为同步提交和异步提交，对应于 KafkaConsumer 中的commitSync()和commitAsync()两种类型的方法。</p>
<h4 id="5-2-1-同步提交"><a href="#5-2-1-同步提交" class="headerlink" title="5.2.1 同步提交"></a>5.2.1 同步提交</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">consumer.commitSync()</span><br></pre></td></tr></table></figure>
<h4 id="5-2-2-异步提交"><a href="#5-2-2-异步提交" class="headerlink" title="5.2.2 异步提交"></a>5.2.2 异步提交</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">consumer.commitAsync();</span><br></pre></td></tr></table></figure>
<h2 id="6-关闭消费者实例"><a href="#6-关闭消费者实例" class="headerlink" title="6 关闭消费者实例"></a>6 关闭消费者实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">consumer.close();</span><br></pre></td></tr></table></figure>
<h2 id="7-多线程实现"><a href="#7-多线程实现" class="headerlink" title="7 多线程实现"></a>7 多线程实现</h2><p>KafkaProducer是线程安全的，然而KafkaConsumer却是非线程安全的。KafkaConsumer中定义了一个 acquire()方法，用来检测当前是否只有一个线程在操作，若有其他线程正在操作则会抛出ConcurrentModifcationException异</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>深入理解Kafka：核心设计与实践原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka生产者</title>
    <url>/2021/01/24/Kafka%E7%94%9F%E4%BA%A7%E8%80%85/</url>
    <content><![CDATA[<h1 id="Kafka生产者"><a href="#Kafka生产者" class="headerlink" title="Kafka生产者"></a>Kafka生产者</h1><a id="more"></a>

<h2 id="1-简要生产步骤"><a href="#1-简要生产步骤" class="headerlink" title="1 简要生产步骤"></a>1 简要生产步骤</h2><p>一个正常的生产逻辑需要具备以下几个步骤：</p>
<ol>
<li>配置生产者客户端参数及创建相应的生产者实例。</li>
<li>构建待发送的消息。</li>
<li>发送消息。</li>
<li>关闭生产者实例。</li>
</ol>
<p>生产者代码示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 配置属性信息</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// bootstrap.servers，必填，生产者客户端连接Kafka集群所需的broker地址清单</span></span><br><span class="line">        properties.setProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;node01:9092,node02:9092,node03:9092&quot;</span>);</span><br><span class="line">        <span class="comment">// key.serializer，必填，key序列化操作的序列化器</span></span><br><span class="line">        properties.setProperty(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">        <span class="comment">// value.serializer，必填，value序列化操作的序列化器</span></span><br><span class="line">        properties.setProperty(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 创建Kafka producer</span></span><br><span class="line">        <span class="comment">// KafkaProducer是线程安全的，可以在多个线程中共享单个KafkaProducer实例，也可以将KafkaProducer实例进行池化来供其他线程调用</span></span><br><span class="line">        KafkaProducer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 生产者生产消息</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">&quot;topic01&quot;</span>, <span class="string">&quot;Hello Kafka&quot;</span>);</span><br><span class="line">        <span class="comment">// 发送消息给服务器</span></span><br><span class="line">        producer.send(record);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 关闭生产者</span></span><br><span class="line">        producer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-配置属性信息，创建Kafka-producer"><a href="#2-配置属性信息，创建Kafka-producer" class="headerlink" title="2 配置属性信息，创建Kafka producer"></a>2 配置属性信息，创建Kafka producer</h2><p>见代码必填项</p>
<p>消息在真正发往Kafka之前，有可能需要经历拦截器（Interceptor）、序列化器（Serializer）和分区器（Partitioner）等一系列的作用</p>
<h3 id="2-1-序列化器"><a href="#2-1-序列化器" class="headerlink" title="2.1 序列化器"></a>2.1 序列化器</h3><h4 id="2-1-1-默认序列化器"><a href="#2-1-1-默认序列化器" class="headerlink" title="2.1.1 默认序列化器"></a>2.1.1 默认序列化器</h4><p>在 <code>org.apache.kafka.common.serialization</code> 包下有各种各样的序列化器</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20210124225943680.png" alt="image-20210124225943680"></p>
<h4 id="2-1-2-自定义序列化器"><a href="#2-1-2-自定义序列化器" class="headerlink" title="2.1.2 自定义序列化器"></a>2.1.2 自定义序列化器</h4><p>如果需要自定义序列化器，需要实现 <code>Serializer</code> 接口，重写 <code>serialize</code> 方法。</p>
<h3 id="2-2-分区器"><a href="#2-2-分区器" class="headerlink" title="2.2 分区器"></a>2.2 分区器</h3><p>消息经过序列化之后就需要确定它发往的分区，如果消息ProducerRecord中指定了partition字段，那么就不需要分区器的作用，因为partition代表的就是所要发往的分区号。</p>
<p>如果消息ProducerRecord中没有指定partition字段，那么就需要依赖分区器，根据key这个字段来计算partition的值。分区器的作用就是为消息分配分区。</p>
<h4 id="2-1-1-默认分区器"><a href="#2-1-1-默认分区器" class="headerlink" title="2.1.1 默认分区器"></a>2.1.1 默认分区器</h4><p>默认分区器 ：DefaultPartitioner</p>
<p>在 partition() 方法中定义了主要的分区分配逻辑。如果 key 不为 null，那么默认的分区器会对 key 进行哈希，最终根据得到的哈希值来计算分区号，拥有相同key的消息会被写入同一个分区。如果key为null，那么消息将会以轮询的方式发往主题内的各个可用分区。</p>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span> </span>&#123;</span><br><span class="line">    List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line">    <span class="keyword">int</span> numPartitions = partitions.size();</span><br><span class="line">    <span class="keyword">if</span> (keyBytes == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextValue = <span class="keyword">this</span>.nextValue(topic);</span><br><span class="line">        List&lt;PartitionInfo&gt; availablePartitions = cluster.availablePartitionsForTopic(topic);</span><br><span class="line">        <span class="keyword">if</span> (availablePartitions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> part = Utils.toPositive(nextValue) % availablePartitions.size();</span><br><span class="line">            <span class="keyword">return</span> ((PartitionInfo)availablePartitions.get(part)).partition();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Utils.toPositive(nextValue) % numPartitions;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-2-自定义分区"><a href="#2-1-2-自定义分区" class="headerlink" title="2.1.2 自定义分区"></a>2.1.2 自定义分区</h4><p>实现 Partitioner 接口，重写partition方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">props.put(ProducerConfig.PARTITIONER_CLASS_CONFIG, UserDefinePartitioner.class.getName());</span><br></pre></td></tr></table></figure>
<h3 id="2-3-拦截器"><a href="#2-3-拦截器" class="headerlink" title="2.3 拦截器"></a>2.3 拦截器</h3><p>生产者拦截器既可以用来在消息发送前做一些准备工作，比如按照某个规则过滤不符合要求的消息、修改消息的内容等，也可以用来在发送回调逻辑前做一些定制化的需求，比如统计类工作。</p>
<h4 id="2-3-1-自定义拦截器"><a href="#2-3-1-自定义拦截器" class="headerlink" title="2.3.1 自定义拦截器"></a>2.3.1 自定义拦截器</h4><p>实现 ProducerInterceptor 接口，重写onSend方法</p>
<h2 id="3-生产者生产消息"><a href="#3-生产者生产消息" class="headerlink" title="3 生产者生产消息"></a>3 生产者生产消息</h2><p>ProducerRecord对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerRecord</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** 主题，必填项 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String topic;</span><br><span class="line">    <span class="comment">/** 分区号 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer partition;</span><br><span class="line">    <span class="comment">/** 消息头部 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Headers headers;</span><br><span class="line">    <span class="comment">/** 键 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="comment">/** 值，必填项 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> V value;</span><br><span class="line">    <span class="comment">/** 时间戳 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long timestamp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-发送消息"><a href="#4-发送消息" class="headerlink" title="4 发送消息"></a>4 发送消息</h2><p>发送消息有三种模式：</p>
<ul>
<li>发后即忘（fire-and-forget）</li>
<li>同步（sync）</li>
<li>异步（async）</li>
</ul>
<p>send方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;RecordMetadata&gt; <span class="title">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.send(record, (Callback)<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;RecordMetadata&gt; <span class="title">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span> </span>&#123;</span><br><span class="line">    ProducerRecord&lt;K, V&gt; interceptedRecord = <span class="keyword">this</span>.interceptors.onSend(record);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.doSend(interceptedRecord, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-发后即忘"><a href="#4-1-发后即忘" class="headerlink" title="4.1 发后即忘"></a>4.1 发后即忘</h3><p>只管往Kafka中发送消息而并不关心消息是否正确到达。可能会造成消息的丢失，性能最高，可靠性最差。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">&quot;topic&quot;</span>, <span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">producer.send(record)</span><br></pre></td></tr></table></figure>
<h3 id="4-2-同步"><a href="#4-2-同步" class="headerlink" title="4.2 同步"></a>4.2 同步</h3><p>同步发送的方式可靠性高，要么消息被发送成功，要么发生异常。性能会差很多，需要阻塞等待一条消息发送完之后才能发送下一条。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">&quot;topic&quot;</span>, <span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    Future&lt;RecordMetadata&gt; recordFuture = producer.send(record);</span><br><span class="line">    <span class="comment">// 调用了get()方法阻塞等待Kafka的响应，直到消息发送成功，或者发生异常。</span></span><br><span class="line">    recordFuture.get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用 <code>Future.get()</code> 方法获得元数据信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RecordMetadata metadata = recordFuture.get();</span><br></pre></td></tr></table></figure>
<h3 id="4-3-异步"><a href="#4-3-异步" class="headerlink" title="4.3 异步"></a>4.3 异步</h3><p>在send（）方法里指定一个Callback的回调函数，Kafka在返回响应时调用该函数来实现异步的发送确认。Kafka有响应时就会回调，要么发送成功，要么抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">&quot;topic&quot;</span>, <span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">Future&lt;RecordMetadata&gt; recordFuture = producer.send(record, <span class="keyword">new</span> Callback() &#123;</span><br><span class="line">    <span class="comment">// 消息发送成功时，metadata不为null而exception为null；</span></span><br><span class="line">    <span class="comment">// 消息发送异常时，metadata为null而exception不为null。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(RecordMetadata recordMetadata, Exception exception)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (exception == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(recordMetadata.topic() + recordMetadata.offset());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            exception.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="5-关闭生产者"><a href="#5-关闭生产者" class="headerlink" title="5 关闭生产者"></a>5 关闭生产者</h2><p>close() 方法会阻塞等待之前所有的发送请求完成后再关闭 KafkaProducer。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">producer.close();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>深入理解Kafka：核心设计与实践原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis Hash mapping</title>
    <url>/2020/12/27/Redis-Hash-mapping/</url>
    <content><![CDATA[<h1 id="Redis-Hash-映射"><a href="#Redis-Hash-映射" class="headerlink" title="Redis Hash 映射"></a>Redis Hash 映射</h1><a id="more"></a>

<p>Redis 序列化器文章中讲到对象可以序列化为 Json 格式，也可以将对象转换为 Hash 键值对的形式。</p>
<p>Spring Data Redis提供了各种将数据映射到 Hash 的策略：</p>
<ul>
<li>使用<code>HashOperations</code>和 serializer 直接映射</li>
<li>使用 Redis Repositories</li>
<li>使用 <code>HashMapper</code> 和 <code>HashOperations</code></li>
</ul>
<h2 id="1-Hash-Mappers"><a href="#1-Hash-Mappers" class="headerlink" title="1 Hash Mappers"></a>1 Hash Mappers</h2><p>Hash Mappers 是将对象映射到 <code>Map&lt;K, V&gt;</code> 的转换器。<code>HashMapper </code> 适用于 Redis Hashes 类型。</p>
<p>Hash Mappers 有多种实现：</p>
<ul>
<li>BeanUtilsHashMapper ：使用 Spring 的 <a href="https://docs.spring.io/spring/docs/5.3.2/javadoc-api/org/springframework/beans/BeanUtils.html">BeanUtils</a>。</li>
<li>ObjectHashMapper：使用 <a href="https://docs.spring.io/spring-data/redis/docs/2.4.2/reference/html/#redis.repositories.mapping">Object-to-Hash Mapping</a>。</li>
<li>Jackson2HashMapper：使用 <a href="https://github.com/FasterXML/jackson">FasterXML Jackson</a>。</li>
</ul>
<h2 id="2-Jackson2HashMapper-案例"><a href="#2-Jackson2HashMapper-案例" class="headerlink" title="2 Jackson2HashMapper 案例"></a>2 Jackson2HashMapper 案例</h2><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jackson2HashMapperTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Person yeyangshu = <span class="keyword">new</span> Person();</span><br><span class="line">        yeyangshu.setName(<span class="string">&quot;yeyangshu&quot;</span>);</span><br><span class="line">        yeyangshu.setAge(<span class="number">20</span>);</span><br><span class="line">        Address address = <span class="keyword">new</span> Address();</span><br><span class="line">        address.setCountry(<span class="string">&quot;china&quot;</span>);</span><br><span class="line">        address.setCity(<span class="string">&quot;Shanghai&quot;</span>);</span><br><span class="line">        yeyangshu.setAddress(address);</span><br><span class="line">        </span><br><span class="line">        stringRedisTemplate.setHashValueSerializer(<span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(Object.class));</span><br><span class="line">        HashOperations hashOperations = stringRedisTemplate.opsForHash();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1 将对象转换为键值对</span></span><br><span class="line">        Jackson2HashMapper jackson2HashMapper = <span class="keyword">new</span> Jackson2HashMapper(objectMapper, <span class="keyword">false</span>);</span><br><span class="line">        Map&lt;String, Object&gt; objectToHash = jackson2HashMapper.toHash(yeyangshu);</span><br><span class="line">        hashOperations.putAll(<span class="string">&quot;yeyangshu&quot;</span>, objectToHash);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2 将键值对转换为对象</span></span><br><span class="line">        Map map = hashOperations.entries(<span class="string">&quot;yeyangshu&quot;</span>);</span><br><span class="line">        Person person = objectMapper.convertValue(map, Person.class);</span><br><span class="line">        System.out.println(person.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 value 是对象，为了能正常显示，还涉及到序列化的问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stringRedisTemplate.setHashValueSerializer(<span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(Object.class));</span><br></pre></td></tr></table></figure>
<p>RedisTemplate 提供的序列化的方法：</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201227095630172.png" alt="image-20201227095630172"></p>
<p>控制台打印：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Person&#123;name=&#x27;yeyangshu&#x27;, age=20, address=Address&#123;city=&#x27;Shanghai&#x27;, country=&#x27;china&#x27;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p><code>redis-cli</code> 查看：</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201227103958851.png" alt="image-20201227103958851"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 主从复制</title>
    <url>/2020/12/27/Redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h1 id="Redis-主从复制"><a href="#Redis-主从复制" class="headerlink" title="Redis 主从复制"></a>Redis 主从复制</h1><a id="more"></a>

<h2 id="1-主从复制配置和演示"><a href="#1-主从复制配置和演示" class="headerlink" title="1 主从复制配置和演示"></a>1 主从复制配置和演示</h2><h3 id="1-1-手动演示"><a href="#1-1-手动演示" class="headerlink" title="1.1 手动演示"></a>1.1 手动演示</h3><h4 id="1-1-1-准备工作"><a href="#1-1-1-准备工作" class="headerlink" title="1.1.1 准备工作"></a>1.1.1 准备工作</h4><p>一台机器开三个实例，更改配置文件关闭后台运行</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主机和从机都设置一下日志</span></span><br><span class="line"><span class="comment"># 关闭后台运行</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">no</span></span><br><span class="line"><span class="comment"># 关闭日志文件，实时打印日志</span></span><br><span class="line"><span class="comment">#logfile /var/log/redis_6379.log</span></span><br><span class="line"><span class="comment"># 关掉AOF日志</span></span><br><span class="line"><span class="attr">appendonly</span> <span class="string">no</span></span><br><span class="line"><span class="comment"># 效果：Redis实例前台阻塞运行，没有AOF日志</span></span><br></pre></td></tr></table></figure>
<p>进入test文件夹，启动redis</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-server .&#x2F;6379.conf</span><br><span class="line">redis-server .&#x2F;6380.conf</span><br><span class="line">redis-server .&#x2F;6381.conf</span><br></pre></td></tr></table></figure>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200721224518202.png" alt="image-20200721224518202"></p>
<p>现在已经有了三台实例，此时希望 6379 作为主机</p>
<h4 id="1-1-2-手动复制"><a href="#1-1-2-手动复制" class="headerlink" title="1.1.2 手动复制"></a>1.1.2 手动复制</h4><p>从机复制命令</p>
<ul>
<li>5.0 以前：SLAVEOF</li>
<li>5.0 以后：REPLICAIF</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">help</span> <span class="string">SLAVEOF</span></span><br></pre></td></tr></table></figure>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200721225251413.png" alt="image-20200721225251413"></p>
<p>6380 机器连接 6379</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slaveof 192.168.1.1 6379</span><br></pre></td></tr></table></figure>
<p>6379 机器日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6629:M 13 Jul 2020 15:37:10.256 * Replica 127.0.0.1:6380 asks for synchronization</span><br><span class="line">6629:M 13 Jul 2020 15:37:10.256 * Partial resynchronization not accepted: Replication ID mismatch (Replica asked for &#39;753f1f7659bb7ff017cc7c9e1c1ef0bb23eee769&#39;, my replication IDs are &#39;ce4485f2cc7f71534865b54ca649a7833b7c71a5&#39; and &#39;0000000000000000000000000000000000000000&#39;)</span><br><span class="line">6629:M 13 Jul 2020 15:37:10.256 * Starting BGSAVE for SYNC with target: disk</span><br><span class="line">6629:M 13 Jul 2020 15:37:10.292 * Background saving started by pid 6748</span><br><span class="line">6748:C 13 Jul 2020 15:37:10.302 * DB saved on disk</span><br><span class="line">6748:C 13 Jul 2020 15:37:10.303 * RDB: 4 MB of memory used by copy-on-write</span><br><span class="line">6629:M 13 Jul 2020 15:37:10.355 * Background saving terminated with success</span><br><span class="line">6629:M 13 Jul 2020 15:37:10.355 * Synchronization with replica 127.0.0.1:6380 succeeded</span><br></pre></td></tr></table></figure>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200721231737542.png" alt="image-20200721231737542"></p>
<p>6380 机器日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6669:S 13 Jul 2020 15:37:09.547 * Before turning into a replica, using my master parameters to synthesize a cached master: I may be able to synchronize with the new master with just a partial transfer.</span><br><span class="line">6669:S 13 Jul 2020 15:37:09.547 * REPLICAOF 127.0.0.1:6379 enabled (user request from &#39;id&#x3D;3 addr&#x3D;127.0.0.1:52883 fd&#x3D;7 name&#x3D; age&#x3D;1580 idle&#x3D;0 flags&#x3D;N db&#x3D;0 sub&#x3D;0 psub&#x3D;0 multi&#x3D;-1 qbuf&#x3D;44 qbuf-free&#x3D;32724 obl&#x3D;0 oll&#x3D;0 omem&#x3D;0 events&#x3D;r cmd&#x3D;replicaof&#39;)</span><br><span class="line">6669:S 13 Jul 2020 15:37:10.254 * Connecting to MASTER 127.0.0.1:6379</span><br><span class="line">6669:S 13 Jul 2020 15:37:10.256 * MASTER &lt;-&gt; REPLICA sync started</span><br><span class="line">6669:S 13 Jul 2020 15:37:10.256 * Non blocking connect for SYNC fired the event.</span><br><span class="line">6669:S 13 Jul 2020 15:37:10.256 * Master replied to PING, replication can continue...</span><br><span class="line">6669:S 13 Jul 2020 15:37:10.256 * Trying a partial resynchronization (request 753f1f7659bb7ff017cc7c9e1c1ef0bb23eee769:1).</span><br><span class="line">6669:S 13 Jul 2020 15:37:10.317 * Full resync from master: 6f76be684c7924f28999c4a24b6f212002285eff:0</span><br><span class="line">6669:S 13 Jul 2020 15:37:10.317 * Discarding previously cached master state.</span><br><span class="line">6669:S 13 Jul 2020 15:37:10.355 * MASTER &lt;-&gt; REPLICA sync: receiving 175 bytes from master</span><br><span class="line">&#x2F;&#x2F; 清除老数据</span><br><span class="line">6669:S 13 Jul 2020 15:37:10.355 * MASTER &lt;-&gt; REPLICA sync: Flushing old data</span><br><span class="line">6669:S 13 Jul 2020 15:37:10.355 * MASTER &lt;-&gt; REPLICA sync: Loading DB in memory</span><br><span class="line">6669:S 13 Jul 2020 15:37:10.355 * MASTER &lt;-&gt; REPLICA sync: Finished with success</span><br></pre></td></tr></table></figure>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200721231941240.png" alt="image-20200721231941240"></p>
<p>6379 插入数据 k1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set k1 123</span><br></pre></td></tr></table></figure>
<p>6380 可以查询此数据，但是 6380 不可以新增</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6380&gt; get k1</span><br><span class="line">&quot;123&quot;</span><br><span class="line">127.0.0.1:6380&gt; set k2 123</span><br><span class="line">(error) READONLY You can&#39;t write against a read only replica.</span><br></pre></td></tr></table></figure>
<p>如果slave不想追随主机</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REPLICAOF no one</span><br></pre></td></tr></table></figure>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200721233951199.png" alt="image-20200721233951199"></p>
<h3 id="1-2-配置文件"><a href="#1-2-配置文件" class="headerlink" title="1.2 配置文件"></a>1.2 配置文件</h3><p>查看 6379.conf</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200721235844532.png" alt="image-20200721235844532"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 机器</span><br><span class="line">replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line">&#x2F;&#x2F; 密码</span><br><span class="line">masterauth &lt;master-password&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置成yes，主从复制中，从服务器可以响应客户端请求;设置成no，主从复制中，从服务器将阻塞所有请求，有客户端请求时返回“SYNC with master in progress”</span><br><span class="line">replica-serve-stale-data yes</span><br><span class="line"></span><br><span class="line">replica-read-only yes</span><br><span class="line">repl-diskless-sync no</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 事务</title>
    <url>/2020/12/27/Redis-%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h1><p>将一组命令放在同一个事务中进行处理</p>
<a id="more"></a>

<h2 id="1-事务简介"><a href="#1-事务简介" class="headerlink" title="1 事务简介"></a>1 事务简介</h2><p>MULTI、EXEC、DISCARD和WATCH是Redis食物相关的命令。事务可以一次执行多个命令，并且带有以下两个重要保证：</p>
<ul>
<li><p>事务是一个单独的隔离操作</p>
<p>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
</li>
<li><p>事务是一个原子操作</p>
<p>事务中的所有命令要么全部被执行，要么全部都不执行。</p>
</li>
</ul>
<p>EXEC 命令负责触发并执行事务中的所有的命令</p>
<ul>
<li>如果客户端在使用 MULTI 开启了一个事物，却因为断线而没有成功执行 EXEC，那么事务中的所有命令都不会被执行。</li>
<li>如果客户端成功在开启事务之后执行 EXEC，那么事务中的所有命令都会被执行。</li>
</ul>
<h2 id="2-事务使用"><a href="#2-事务使用" class="headerlink" title="2 事务使用"></a>2 事务使用</h2><h3 id="2-1-help-transactions"><a href="#2-1-help-transactions" class="headerlink" title="2.1 help @transactions"></a>2.1 help @transactions</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @transactions</span><br><span class="line"></span><br><span class="line">  DISCARD -</span><br><span class="line">  summary: Discard all commands issued after MULTI</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  EXEC -</span><br><span class="line">  summary: Execute all commands issued after MULTI</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  MULTI -</span><br><span class="line">  summary: Mark the start of a transaction block</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  UNWATCH -</span><br><span class="line">  summary: Forget about all watched keys</span><br><span class="line">  since: 2.2.0</span><br><span class="line"></span><br><span class="line">  WATCH key [key ...]</span><br><span class="line">  summary: Watch the given keys to determine execution of the MULTI&#x2F;EXEC block</span><br><span class="line">  since: 2.2.0</span><br></pre></td></tr></table></figure>
<p>MULTI：标记一个事务块的开始。 随后的指令将在执行 EXEC 时作为一个原子执行。</p>
<ul>
<li>返回值：始终为OK</li>
</ul>
<p>EXEC：执行事务中所有在排队等待的指令并将链接状态恢复到正常，当使用 WATCH 时，只有当被监视的键没有被修改，且允许检查设定机制时，EXEC会被执行。</p>
<ul>
<li>返回值：每个元素与原子事务中的指令一一对应 当使用 WATCH 时，如果被终止，EXEC 则返回一个空的应答集合</li>
</ul>
<p>DISCARD：刷新一个事务中所有在排队等待的指令，并且将连接状态恢复到正常。如果已使用WATCH，DISCARD将释放所有被 WATCH 的 key。</p>
<ul>
<li>返回值：所有返回都是 OK</li>
</ul>
<p>WATCH：标记所有指定的 key 被监视起来，在事务中有条件的执行（乐观锁）。</p>
<ul>
<li>返回值：始终为 OK</li>
</ul>
<h3 id="2-2-事务用法"><a href="#2-2-事务用法" class="headerlink" title="2.2 事务用法"></a>2.2 事务用法</h3><h4 id="2-2-1-开启并执行事务"><a href="#2-2-1-开启并执行事务" class="headerlink" title="2.2.1 开启并执行事务"></a>2.2.1 开启并执行事务</h4><p>MULTI 用于开启一个事务，它总是返回 <code>OK</code>，MULTI 执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即执行，而是被放在一个队列中，当 EXEC 命令被调用时，所有队列中的命令才会被执行。</p>
<p>一个事务</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; MULTI </span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; <span class="built_in">SET</span> k1 aaa</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> k2 bbb</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; EXEC</span><br><span class="line"><span class="number">1</span>) OK</span><br><span class="line"><span class="number">2</span>) OK</span><br></pre></td></tr></table></figure>
<p>两个客户端两个事物不同顺序</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># client1:</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get k1</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="comment"># client2:</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; <span class="built_in">DEL</span> k1</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; EXEC</span><br><span class="line"><span class="number">1</span>) (integer) <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># client1:</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; EXEC</span><br><span class="line"><span class="number">1</span>) (nil)</span><br></pre></td></tr></table></figure>
<h4 id="2-2-2-放弃事务"><a href="#2-2-2-放弃事务" class="headerlink" title="2.2.2 放弃事务"></a>2.2.2 放弃事务</h4><p>当执行 DISCARD 命令时， 事务会被放弃， 事务队列会被清空， 并且客户端会从事务状态中退出</p>
<h4 id="2-2-3-WATCH，使用-check-and-set-操作实现乐观锁"><a href="#2-2-3-WATCH，使用-check-and-set-操作实现乐观锁" class="headerlink" title="2.2.3 WATCH，使用 check-and-set 操作实现乐观锁"></a>2.2.3 WATCH，使用 check-and-set 操作实现乐观锁</h4><p>WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。</p>
<p>被 WATCH  的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回 nil 来表示事务已经失败。</p>
<p>测试：</p>
<p>同时开启两个Redis客户端，client1和client2，数据库中存在k1:abc，client1 WATCH k1，先开始事务后执行，client2后开启事务先执行</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># client1开启事务不执行</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; KEYS *</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;k1&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; WATCH k1</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GET k1</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; KEYS *</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="comment"># client2开启事务并执行，此时k1值被更改</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; KEYS *</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; <span class="built_in">SET</span> k1 def</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; EXEC</span><br><span class="line"><span class="number">1</span>) <span class="number">1</span>) <span class="string">&quot;k1&quot;</span></span><br><span class="line"><span class="number">2</span>) OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GET k1</span><br><span class="line"><span class="string">&quot;def&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># client1执行事务返回nil，证明k1事务执行失败</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; EXEC</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Transactions</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 使用LRU算法做缓存使用</title>
    <url>/2020/12/27/Redis-%E4%BD%BF%E7%94%A8LRU%E7%AE%97%E6%B3%95%E5%81%9A%E7%BC%93%E5%AD%98%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Redis-作为缓存使用"><a href="#Redis-作为缓存使用" class="headerlink" title="Redis 作为缓存使用"></a>Redis 作为缓存使用</h1><a id="more"></a>

<p>使用 Redis 做缓存，当你新增数据时，让 Redis 自动地回收旧数据是件很方便的事情。</p>
<p>Redis 回收数据分为两种情况：</p>
<ul>
<li>内存回收</li>
<li>key 过期删除</li>
</ul>
<h2 id="1-内存回收"><a href="#1-内存回收" class="headerlink" title="1 内存回收"></a>1 内存回收</h2><p>当 Redis 存储数据使用的内存超过 Redis 设置的内存限制就会触发内存回收。当达到指定的内存限制大小时，需要选择回收策略进行内存回收。</p>
<h3 id="1-1-内存设置"><a href="#1-1-内存设置" class="headerlink" title="1.1 内存设置"></a>1.1 内存设置</h3><p><code>maxmemory </code> 配置指令用于配置 Redis 存储数据时指定限制的内存大小</p>
<p>通过配置文件 <code>redis.conf</code> 可以设置该指令，或者在运行时使用 <code>CONFIG SET</code> 命令来进行配置。</p>
<p>配置文件内存设置案例：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">maxmemory</span> <span class="string">100mb</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-回收策略"><a href="#1-2-回收策略" class="headerlink" title="1.2 回收策略"></a>1.2 回收策略</h3><p><code>maxmemory-policy</code> 配置指令用于 Redis 的回收策略。</p>
<p>回收策略：</p>
<ul>
<li>volatile-lru：采用最近使用最少的淘汰策略，Redis 将回收那些超时的（仅仅是超时的）键值对，也就是它只淘汰那些超时的键值对。</li>
<li>allkeys-lru：采用最近最少使用的淘汰策略，Redis 将对所有（不仅仅是超时的）的键值对采用最近最少使用的淘汰策略。</li>
<li>volatile-lfu：采用最近最不常用的淘汰策略，所谓最近最不常用，也就是一定时期内被访问次数最少的。Redis将回收超时的键值对。</li>
<li>allkeys-lfu：采用最近最不常用的淘汰策略，Redis 将对所有的键值对采用最近最不常用的淘汰策略。</li>
<li>volatile-random：采用随机淘汰策略删除超时的键值对。</li>
<li>allkeys-random：采用随机淘汰策略删除所有的键值对，这个策略不常用。</li>
<li>volatile-ttl：采用删除存活时间最短的键值对策略。</li>
<li>noeviction：不淘汰任何键值对，当内存满时，如果进行读操作，例如get命令，它将正常工作，而做写操作，它将返回错误，也就是说，当Redis采用这个策略内存达到最大的时候，它就只能读不能写了。</li>
</ul>
<h3 id="2-key-过期删除"><a href="#2-key-过期删除" class="headerlink" title="2 key 过期删除"></a>2 key 过期删除</h3><p>Redis keys 过期有两种方式：</p>
<ul>
<li>被动方式</li>
<li>主动方式</li>
</ul>
<h3 id="2-1-被动方式"><a href="#2-1-被动方式" class="headerlink" title="2.1 被动方式"></a>2.1 被动方式</h3><p>放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。</p>
<h3 id="2-2-主动方式"><a href="#2-2-主动方式" class="headerlink" title="2.2 主动方式"></a>2.2 主动方式</h3><p>被动方式的删除是不够的，因为有些过期的 keys，永远不会访问他们，但是这些 keys 应该过期，所以定时随机测试设置 keys 的过期时间，将这些过期的 keys 从 key 空间删除。</p>
<p>Redis会每秒10 次去做以下的事情：</p>
<ol>
<li>测试随机的 20 个 keys 进行相关过期检测。</li>
<li>删除所有已经过期的 keys。</li>
<li>如果有多于 25% 的 keys 过期，重复步骤 1。</li>
</ol>
<p>Redis 会不断重复过期检测，直到过期的 keys 的低于 25%，这意味着在任意时刻，最多会清除 1/4 过期的 keys。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>LRU</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 分区</title>
    <url>/2020/12/27/Redis-%E5%88%86%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="Redis-分区"><a href="#Redis-分区" class="headerlink" title="Redis 分区"></a>Redis 分区</h1><a id="more"></a>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 发布订阅</title>
    <url>/2020/12/27/Redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/</url>
    <content><![CDATA[<h1 id="Redis-发布订阅"><a href="#Redis-发布订阅" class="headerlink" title="Redis 发布订阅"></a>Redis 发布订阅</h1><a id="more"></a>

<p>发布、订阅和取消订阅实现了发布/订阅消息范式，发送者（发布者）不是计划发送消息给特定的接收者（订阅者）。而是发布的消息分到不同的频道，不需要知道什么样的订阅者订阅。订阅者对一个或多个频道感兴趣，只需接收感兴趣的消息，不需要知道什么样的发布者发布的。这种发布者和订阅者的解耦合可以带来更大的扩展性和更加动态的网络拓扑。</p>
<h2 id="1-Pub-Sub的基本知识"><a href="#1-Pub-Sub的基本知识" class="headerlink" title="1 Pub/Sub的基本知识"></a>1 Pub/Sub的基本知识</h2><p>Redis 是一个快速、稳定的发布/订阅的信息系统。</p>
<h2 id="2-Pub-Sub使用"><a href="#2-Pub-Sub使用" class="headerlink" title="2 Pub/Sub使用"></a>2 Pub/Sub使用</h2><h3 id="2-1-help-pubsub"><a href="#2-1-help-pubsub" class="headerlink" title="2.1 help @pubsub"></a>2.1 help @pubsub</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @pubsub</span><br><span class="line"></span><br><span class="line">  PSUBSCRIBE pattern [pattern ...]</span><br><span class="line">  summary: Listen for messages published to channels matching the given patterns</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  PUBLISH channel message</span><br><span class="line">  summary: Post a message to a channel</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  PUBSUB subcommand [argument [argument ...]]</span><br><span class="line">  summary: Inspect the state of the Pub&#x2F;Sub subsystem</span><br><span class="line">  since: 2.8.0</span><br><span class="line"></span><br><span class="line">  PUNSUBSCRIBE [pattern [pattern ...]]</span><br><span class="line">  summary: Stop listening for messages posted to channels matching the given patterns</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  SUBSCRIBE channel [channel ...]</span><br><span class="line">  summary: Listen for messages published to the given channels</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  UNSUBSCRIBE [channel [channel ...]]</span><br><span class="line">  summary: Stop listening for messages posted to the given channels</span><br><span class="line">  since: 2.0.0</span><br></pre></td></tr></table></figure>
<h3 id="2-2-发布订阅"><a href="#2-2-发布订阅" class="headerlink" title="2.2 发布订阅"></a>2.2 发布订阅</h3><h4 id="2-2-1-推送消息的格式"><a href="#2-2-1-推送消息的格式" class="headerlink" title="2.2.1 推送消息的格式"></a>2.2.1 推送消息的格式</h4><p>消息是一个有三个元素的多块响应，有三种情况:</p>
<ul>
<li>第一个元素消息类型是 subscribe：表示我们成功订阅到响应的第二个元素提供的频道，第三个参数代表我们现在订阅频道的数量。</li>
<li>第一个元素消息类型是 unsubscribe：表示我们成功取消订阅响应的第二个元素提供的频道，第三个参数代表我们目前订阅的频道的数量。当最后一个参数是 0 的时候，我们不再订阅到任何频道。当我们在 Pub/Sub 以外状态，客户端可以发出任何 redis 命令。</li>
<li>第一个元素消息类型是 message：这是另外一个客户端发出的发布命令的结果。第二个元素是来源频道的名称，第三个参数是实际消息的内容。</li>
</ul>
<h4 id="2-2-2-发布-订阅"><a href="#2-2-2-发布-订阅" class="headerlink" title="2.2.2 发布/订阅"></a>2.2.2 发布/订阅</h4><p>订阅 foo 和 bar，客户端发出一个订阅的频道名称</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># client1 订阅渠道foo和bar</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SUBSCRIBE foo bar</span><br><span class="line">Reading messages... (press Ctrl<span class="literal">-C</span> to quit)</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;foo&quot;</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;bar&quot;</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>其他客户端发到这些频道的消息将会被推送到所有订阅的客户端。</p>
<p>foo 和 bar 发布消息</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># client2 渠道发布</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PUBLISH foo Hello</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PUBLISH bar World</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># client1 接收消息</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SUBSCRIBE foo bar</span><br><span class="line">Reading messages... (press Ctrl<span class="literal">-C</span> to quit)</span><br><span class="line"><span class="comment"># 消息类型message</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;message&quot;</span></span><br><span class="line"><span class="comment"># 消息来源频道</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;foo&quot;</span></span><br><span class="line"><span class="comment"># 实际消息内容</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;message&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;bar&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;World&quot;</span></span><br></pre></td></tr></table></figure>
<p>取消订阅</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; UNSUBSCRIBE foo</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;unsubscribe&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;foo&quot;</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">0</span>	</span><br></pre></td></tr></table></figure>
<h4 id="2-2-3-模式匹配订阅（正则匹配）"><a href="#2-2-3-模式匹配订阅（正则匹配）" class="headerlink" title="2.2.3 模式匹配订阅（正则匹配）"></a>2.2.3 模式匹配订阅（正则匹配）</h4><p>Redis 的 Pub/Sub 实现支持模式匹配。客户端可以订阅全风格的模式以便接收所有来自能匹配到给定模式的频道的消息。</p>
<p>订阅</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># client1订阅消息</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PSUBSCRIBE news.*</span><br><span class="line">Reading messages... (press Ctrl<span class="literal">-C</span> to quit)</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;psubscribe&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;news.*&quot;</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>发布</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># client2消息发布</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PUBLISH news.foo Hello</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># client1消息接收</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PSUBSCRIBE news.*</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;pmessage&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;news.*&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;news.foo&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>
<p>取消订阅</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PUNSUBSCRIBE news.*</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;punsubscribe&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;news.*&quot;</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-4-同时匹配模式和频道订阅的消息"><a href="#2-2-4-同时匹配模式和频道订阅的消息" class="headerlink" title="2.2.4 同时匹配模式和频道订阅的消息"></a>2.2.4 同时匹配模式和频道订阅的消息</h4><p>订阅</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">SUBSCRIBE foo</span><br><span class="line">PSUBSCRIBE f*</span><br></pre></td></tr></table></figure>
<p>上面的例子中，如果一个消息被发送到 foo，客户端会接收到两条消息：一条 message 类型，一条 pmessage 类型。</p>
<h2 id="3-发布订阅使用场景：聊天系统"><a href="#3-发布订阅使用场景：聊天系统" class="headerlink" title="3 发布订阅使用场景：聊天系统"></a>3 发布订阅使用场景：聊天系统</h2><p>Peter Noordhuis 提供了一个使用EventMachine 和Redis创建多用户高性能网路聊天的很棒的例子，链接：<a href="https://gist.github.com/pietern/348262">https://gist.github.com/pietern/348262</a></p>
<h2 id="4-SpringBoot-中使用发布订阅实现简单的聊天室"><a href="#4-SpringBoot-中使用发布订阅实现简单的聊天室" class="headerlink" title="4 SpringBoot 中使用发布订阅实现简单的聊天室"></a>4 SpringBoot 中使用发布订阅实现简单的聊天室</h2><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pubSubTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RedisConnection connection = stringRedisTemplate.getConnectionFactory().getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 订阅</span></span><br><span class="line">        connection.subscribe(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">            <span class="comment">// 处理消息</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">byte</span>[] body = message.getBody();</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;chat&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            stringRedisTemplate.convertAndSend(<span class="string">&quot;chat&quot;</span>, <span class="string">&quot;Hello World&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>redis-cli</code> 显示：</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201227110414063.png" alt="image-20201227110414063"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 哨兵模式高可用解决方案</title>
    <url>/2020/12/27/Redis-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E9%AB%98%E5%8F%AF%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="Redis-哨兵模式高可用解决方案"><a href="#Redis-哨兵模式高可用解决方案" class="headerlink" title="Redis 哨兵模式高可用解决方案"></a>Redis 哨兵模式高可用解决方案</h1><a id="more"></a>

<h2 id="1-Redis哨兵简介"><a href="#1-Redis哨兵简介" class="headerlink" title="1 Redis哨兵简介"></a>1 Redis哨兵简介</h2><p>Redis的哨兵系统用于管理多个Redis服务器，该系统执行以下三个任务：</p>
<ul>
<li>监控</li>
<li>提醒</li>
<li>自动故障转移</li>
</ul>
<h2 id="2-Redis哨兵使用"><a href="#2-Redis哨兵使用" class="headerlink" title="2 Redis哨兵使用"></a>2 Redis哨兵使用</h2><h3 id="2-1-配置-Sentinel"><a href="#2-1-配置-Sentinel" class="headerlink" title="2.1 配置 Sentinel"></a>2.1 配置 Sentinel</h3><p>新建三个 sentinel 配置文件，例 26379.conf、26380.conf、26381.conf 监听主机，内容为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">port 26379&#x2F;26380&#x2F;26381</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br></pre></td></tr></table></figure>
<p>运行主机</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-server .&#x2F;6379.conf</span><br></pre></td></tr></table></figure>
<p>运行两个 slave</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-server .&#x2F;6380.conf --replicaof 127.0.0.1 6379</span><br><span class="line">redis-server .&#x2F;6381.conf --replicaof 127.0.0.1 6379</span><br></pre></td></tr></table></figure>
<p>启动哨兵</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-server .&#x2F;26379.conf --sentinel</span><br><span class="line">redis-server .&#x2F;26380.conf --sentinel</span><br><span class="line">redis-server .&#x2F;26381.conf --sentinel</span><br></pre></td></tr></table></figure>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200722211540287.png" alt="image-20200722211540287"></p>
<h3 id="2-2-测试哨兵"><a href="#2-2-测试哨兵" class="headerlink" title="2.2 测试哨兵"></a>2.2 测试哨兵</h3><p>此时断开 6379，经过一段时间，会投票选出新的主机，本次测试 2 票选出 6381</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6909:X 13 Jul 2020 17:06:41.887 # +sdown master mymaster 127.0.0.1 6379</span><br><span class="line">6909:X 13 Jul 2020 17:06:41.946 # +odown master mymaster 127.0.0.1 6379 #quorum 3&#x2F;2</span><br><span class="line">6909:X 13 Jul 2020 17:06:41.946 # +new-epoch 1</span><br><span class="line">6909:X 13 Jul 2020 17:06:41.946 # +try-failover master mymaster 127.0.0.1 6379</span><br><span class="line">6909:X 13 Jul 2020 17:06:41.964 # +vote-for-leader f0d0f7c12cc881a04d88ad7831100d0eea82cec4 1</span><br><span class="line">6909:X 13 Jul 2020 17:06:41.969 # 3dd3212a440f415e989718634222ae89fc2fd219 voted for 3dd3212a440f415e989718634222ae89fc2fd219 1</span><br><span class="line">6909:X 13 Jul 2020 17:06:41.989 # 44c8a525d5b8390571e2621fa3dfa416eafa8c0b voted for f0d0f7c12cc881a04d88ad7831100d0eea82cec4 1</span><br><span class="line">6909:X 13 Jul 2020 17:06:42.027 # +elected-leader master mymaster 127.0.0.1 6379</span><br><span class="line">6909:X 13 Jul 2020 17:06:42.027 # +failover-state-select-slave master mymaster 127.0.0.1 6379</span><br><span class="line">6909:X 13 Jul 2020 17:06:42.100 # +selected-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379</span><br><span class="line">6909:X 13 Jul 2020 17:06:42.100 * +failover-state-send-slaveof-noone slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379</span><br><span class="line">6909:X 13 Jul 2020 17:06:42.159 * +failover-state-wait-promotion slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379</span><br><span class="line">6909:X 13 Jul 2020 17:06:42.445 # +promoted-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379</span><br><span class="line">6909:X 13 Jul 2020 17:06:42.445 # +failover-state-reconf-slaves master mymaster 127.0.0.1 6379</span><br><span class="line">6909:X 13 Jul 2020 17:06:42.528 * +slave-reconf-sent slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379</span><br><span class="line">6909:X 13 Jul 2020 17:06:43.113 # -odown master mymaster 127.0.0.1 6379</span><br><span class="line">6909:X 13 Jul 2020 17:06:43.482 * +slave-reconf-inprog slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379</span><br><span class="line">6909:X 13 Jul 2020 17:06:43.482 * +slave-reconf-done slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379</span><br><span class="line">6909:X 13 Jul 2020 17:06:43.554 # +failover-end master mymaster 127.0.0.1 6379</span><br><span class="line">6909:X 13 Jul 2020 17:06:43.554 # +switch-master mymaster 127.0.0.1 6379 127.0.0.1 6381</span><br><span class="line">6909:X 13 Jul 2020 17:06:43.554 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381</span><br><span class="line">6909:X 13 Jul 2020 17:06:43.554 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381</span><br><span class="line">6909:X 13 Jul 2020 17:07:13.568 # +sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381</span><br></pre></td></tr></table></figure>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200722212104628.png" alt="image-20200722212104628"></p>
<p>哨兵会自动更改配置文件</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200722212459813.png" alt="image-20200722212459813"></p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200722212525730.png" alt="image-20200722212525730"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>HA</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 基于SpringBoot API的使用</title>
    <url>/2020/12/26/Redis-%E5%9F%BA%E4%BA%8ESpringBoot-API%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="基于-Spring-Boot-的-Redis-API-使用"><a href="#基于-Spring-Boot-的-Redis-API-使用" class="headerlink" title="基于 Spring Boot 的 Redis API 使用"></a>基于 Spring Boot 的 Redis API 使用</h1><a id="more"></a>

<h2 id="1-新建-Spring-Boot-项目"><a href="#1-新建-Spring-Boot-项目" class="headerlink" title="1 新建 Spring Boot 项目"></a>1 新建 Spring Boot 项目</h2><p>本次使用的工具是 <code>IDEA</code>，新建项目，点击 <code>Next</code></p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201226003848807.png" alt="image-20201226003848807"></p>
<p><code>NoSQL</code> 中选中 <code>Spring Data Redis</code>，继续点击 <code>Next</code></p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201226003954727.png" alt="image-20201226003954727"></p>
<p>选择一个合适的磁盘目录，创建新项目，一个新的项目就创建好了。</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201226004241036.png" alt="image-20201226004241036"></p>
<p>可以看到 <code>pom.xml</code> 中引用了 <code>spring-boot-starter-data-redis</code></p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201226004412233.png" alt="image-20201226004412233"></p>
<p><code>Maven</code> 依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-Redis-参数配置"><a href="#2-Redis-参数配置" class="headerlink" title="2 Redis 参数配置"></a>2 Redis 参数配置</h2><p>在 <code>application.properties</code>（也可以是 <code>application.yml</code>）添加 <code>Redis </code> 的参数：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br></pre></td></tr></table></figure>
<h2 id="3-基础-API"><a href="#3-基础-API" class="headerlink" title="3 基础 API"></a>3 基础 API</h2><h3 id="3-1-低级-API"><a href="#3-1-低级-API" class="headerlink" title="3.1 低级 API"></a>3.1 低级 API</h3><h4 id="3-1-1-RedisConnection"><a href="#3-1-1-RedisConnection" class="headerlink" title="3.1.1 RedisConnection"></a>3.1.1 RedisConnection</h4><p>虽然 <code>Redis</code> 是二进制安全的，但是 <code>RedisConnection</code> 提供了接受和返回二进制值（<code>byte</code> 数组）的低级方法，模板负责序列化和连接管理，用户无需处理此类细节。</p>
<h3 id="3-2-高级-API"><a href="#3-2-高级-API" class="headerlink" title="3.2 高级 API"></a>3.2 高级 API</h3><h4 id="3-2-1-RedisTemplate"><a href="#3-2-1-RedisTemplate" class="headerlink" title="3.2.1 RedisTemplate"></a>3.2.1 RedisTemplate</h4><p><code>RedisTemplate</code> 为 <code>Redis</code> 交互提供了高级抽象，提供了操作视图（根据Redis命令进行分组），提供了丰富的，通用的接口，用于针对某种类型或某些键（通过 <code>KeyBound</code> 接口），如下表所述：</p>
<table>
<thead>
<tr>
<th align="left">接口</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">按键类型操作</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>GeoOperations</code></td>
<td align="left">Redis 的 geospatial 操作, 例如 <code>GEOADD</code>, <code>GEORADIUS</code>,…</td>
</tr>
<tr>
<td align="left"><code>HashOperations</code></td>
<td align="left">Redis 的 hash 类型操作</td>
</tr>
<tr>
<td align="left"><code>HyperLogLogOperations</code></td>
<td align="left">Redis 的 HyperLogLog 操作, 例如 <code>PFADD</code>, <code>PFCOUNT</code>,…</td>
</tr>
<tr>
<td align="left"><code>ListOperations</code></td>
<td align="left">Redis 的 list 类型操作</td>
</tr>
<tr>
<td align="left"><code>SetOperations</code></td>
<td align="left">Redis 的 set 类型操作</td>
</tr>
<tr>
<td align="left"><code>ValueOperations</code></td>
<td align="left">Redis 的 string (或者 value) 类型操作</td>
</tr>
<tr>
<td align="left"><code>ZSetOperations</code></td>
<td align="left">Redis 的 zset (或者 sorted set) 类型操作</td>
</tr>
<tr>
<td align="left">键值绑定操作</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>BoundGeoOperations</code></td>
<td align="left">Redis 的 key 绑定 geospatial 操作</td>
</tr>
<tr>
<td align="left"><code>BoundHashOperations</code></td>
<td align="left">Redis 的 hash key 绑定操作</td>
</tr>
<tr>
<td align="left"><code>BoundKeyOperations</code></td>
<td align="left">Redis 的 key 绑定操作</td>
</tr>
<tr>
<td align="left"><code>BoundListOperations</code></td>
<td align="left">Redis 的 list key 绑定操作</td>
</tr>
<tr>
<td align="left"><code>BoundSetOperations</code></td>
<td align="left">Redis 的 set key 绑定操作</td>
</tr>
<tr>
<td align="left"><code>BoundValueOperations</code></td>
<td align="left">Redis 的 string (或者 value) key 绑定操作</td>
</tr>
<tr>
<td align="left"><code>BoundZSetOperations</code></td>
<td align="left">Redis 的 zset (或者 sorted set) key 绑定操作</td>
</tr>
</tbody></table>
<h4 id="3-2-2-StringRedisTemplate"><a href="#3-2-2-StringRedisTemplate" class="headerlink" title="3.2.2 StringRedisTemplate"></a>3.2.2 StringRedisTemplate</h4><p>由于 <code>Redis</code> 中的键和值通常是 <code>java.lang.String</code>，因此 <code>Redis</code> 提供对 <code>String</code> 类型操作更便利的 <code>StringRedisTemplate</code> 。</p>
<h2 id="4-API-操作测试案例"><a href="#4-API-操作测试案例" class="headerlink" title="4 API 操作测试案例"></a>4 API 操作测试案例</h2><p>新建测试类，本次使用的 <code>Junit5</code>，每次测试前首先清空 <code>Redis</code> 中所有数据</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201226210010782.png" alt="image-20201226210010782"></p>
<h3 id="4-1-String-类型操作案例"><a href="#4-1-String-类型操作案例" class="headerlink" title="4.1 String 类型操作案例"></a>4.1 String 类型操作案例</h3><p>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stringTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 使用低级API RedisConnection操作String</span></span><br><span class="line">        RedisConnection redisConnection = redisTemplate.getConnectionFactory().getConnection();</span><br><span class="line">        redisConnection.set(<span class="string">&quot;redisConnectionTestString&quot;</span>.getBytes(), <span class="string">&quot;redis connection test string&quot;</span>.getBytes());</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(redisConnection.get(<span class="string">&quot;redisConnectionTestString&quot;</span>.getBytes())));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 使用redisTemplate操作String</span></span><br><span class="line">        ValueOperations redisTemplateOperations = redisTemplate.opsForValue();</span><br><span class="line">        redisTemplateOperations.set(<span class="string">&quot;redisTmplOpsTestString&quot;</span>, <span class="string">&quot;redis template operations test string&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplateOperations.get(<span class="string">&quot;redisTmplOpsTestString&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 使用stringRedisTemplate操作String</span></span><br><span class="line">        ValueOperations&lt;String, String&gt; stringRedisTemplateOperations = stringRedisTemplate.opsForValue();</span><br><span class="line">        stringRedisTemplateOperations.set(<span class="string">&quot;stringRedisTmplOpsTestString&quot;</span>, <span class="string">&quot;string redis template operations test string&quot;</span>);</span><br><span class="line">        System.out.println(stringRedisTemplateOperations.get(<span class="string">&quot;stringRedisTmplOpsTestString&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 使用redisTemplate boundValueOps操作String</span></span><br><span class="line">        BoundValueOperations boundValueOps = redisTemplate.boundValueOps(<span class="string">&quot;redisTmplOpsTestString&quot;</span>);</span><br><span class="line">        System.out.println(boundValueOps.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 使用redisTemplate boundValueOps操作String</span></span><br><span class="line">        BoundValueOperations&lt;String, String&gt; stringBoundValueOperations = stringRedisTemplate.boundValueOps(<span class="string">&quot;stringRedisTmplOpsTestString&quot;</span>);</span><br><span class="line">        System.out.println(stringBoundValueOperations.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台打印：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis connection test string</span><br><span class="line">redis template operations test string</span><br><span class="line">string redis template operations test string</span><br><span class="line">redis template operations test string</span><br><span class="line">string redis template operations test string</span><br></pre></td></tr></table></figure>
<p><code>redis-cli</code> 查看：</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201226211610274.png" alt="image-20201226211610274"></p>
<p>上面 <code>keys *</code> 打印所有的 <code>key</code> 时 <code>3)</code> 显示乱码，是什么原因？</p>
<p>原因是 <code>Redis </code> 是二进制安全的，会把所有的数据变成二进制数组，有关序列化参考序列化文章。</p>
<h3 id="4-2-List-类型操作案例"><a href="#4-2-List-类型操作案例" class="headerlink" title="4.2 List 类型操作案例"></a>4.2 List 类型操作案例</h3><p>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">listTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        values.addAll(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 使用低级API RedisConnection操作List</span></span><br><span class="line">        RedisConnection redisConnection = redisTemplate.getConnectionFactory().getConnection();</span><br><span class="line">        redisConnection.lPush(<span class="string">&quot;redisConnectionTestList&quot;</span>.getBytes(), <span class="string">&quot;1&quot;</span>.getBytes(), <span class="string">&quot;2&quot;</span>.getBytes(), <span class="string">&quot;3&quot;</span>.getBytes());</span><br><span class="line">        System.out.println(redisConnection.lRange(<span class="string">&quot;redisConnectionTestList&quot;</span>.getBytes(), <span class="number">0L</span>, -<span class="number">1L</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 使用redisTemplate操作String</span></span><br><span class="line"></span><br><span class="line">        ListOperations redisTemplateOperations = redisTemplate.opsForList();</span><br><span class="line">        redisTemplateOperations.leftPushAll(<span class="string">&quot;redisTmplOpsTestList&quot;</span>, values);</span><br><span class="line">        System.out.println(redisTemplateOperations.range(<span class="string">&quot;redisTmplOpsTestList&quot;</span>, <span class="number">0L</span>, -<span class="number">1L</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 使用redisTemplate boundListOps操作List</span></span><br><span class="line">        BoundListOperations boundListOps = redisTemplate.boundListOps(<span class="string">&quot;redisTmplOpsTestList&quot;</span>);</span><br><span class="line">        System.out.println(boundListOps.range(<span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台打印：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[B@6fa0450e, [B@37468787, [B@51ec2856]</span><br><span class="line">[3, 2, 1]</span><br><span class="line">[3, 2, 1]</span><br></pre></td></tr></table></figure>
<p><code>redis-cli</code> 查看：</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201226214257532.png" alt="image-20201226214257532"></p>
<h3 id="4-3-Hash-类型操作案例"><a href="#4-3-Hash-类型操作案例" class="headerlink" title="4.3 Hash 类型操作案例"></a>4.3 Hash 类型操作案例</h3><p>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">listTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 使用低级API RedisConnection操作Hash</span></span><br><span class="line">        RedisConnection redisConnection = redisTemplate.getConnectionFactory().getConnection();</span><br><span class="line">        redisConnection.hSet(<span class="string">&quot;redisConnectionTestHash&quot;</span>.getBytes(), <span class="string">&quot;name&quot;</span>.getBytes(), <span class="string">&quot;yeyangshu&quot;</span>.getBytes());</span><br><span class="line">        redisConnection.hSet(<span class="string">&quot;redisConnectionTestHash&quot;</span>.getBytes(), <span class="string">&quot;age&quot;</span>.getBytes(), <span class="string">&quot;20&quot;</span>.getBytes());</span><br><span class="line">        System.out.println(redisConnection.hGet(<span class="string">&quot;redisConnectionTestHash&quot;</span>.getBytes(), <span class="string">&quot;name&quot;</span>.getBytes()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 使用redisTemplate操作Hash</span></span><br><span class="line">        HashOperations redisTemplateOperations = redisTemplate.opsForHash();</span><br><span class="line">        redisTemplateOperations.put(<span class="string">&quot;redisTmplOpsTestHash&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;yeyangshu&quot;</span>);</span><br><span class="line">        redisTemplateOperations.put(<span class="string">&quot;redisTmplOpsTestHash&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;20&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplateOperations.values(<span class="string">&quot;redisTmplOpsTestHash&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 使用redisTemplate boundHashOps操作Hash</span></span><br><span class="line">        BoundHashOperations boundHashOps = redisTemplate.boundHashOps(<span class="string">&quot;redisTmplOpsTestHash&quot;</span>);</span><br><span class="line">        System.out.println(boundHashOps.values());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台打印：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[B@33425811</span><br><span class="line">[yeyangshu, 20]</span><br><span class="line">[yeyangshu, 20]</span><br></pre></td></tr></table></figure>
<p><code>redis-cli</code> 查看：</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201226215806979.png" alt="image-20201226215806979"></p>
<p>使用 <code>Hash</code> 的时候更希望直接使用对象，会在后面文章讲解</p>
<h3 id="4-4-Set-类型操作案例"><a href="#4-4-Set-类型操作案例" class="headerlink" title="4.4 Set 类型操作案例"></a>4.4 Set 类型操作案例</h3><h3 id="4-5-Sorted-Sets-类型操作案例"><a href="#4-5-Sorted-Sets-类型操作案例" class="headerlink" title="4.5 Sorted Sets 类型操作案例"></a>4.5 Sorted Sets 类型操作案例</h3>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 基本数据类型 Hashes</title>
    <url>/2020/12/26/Redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-Hashes/</url>
    <content><![CDATA[<h1 id="Redis-Hashes"><a href="#Redis-Hashes" class="headerlink" title="Redis Hashes"></a>Redis Hashes</h1><h2 id="1-Hashes简介"><a href="#1-Hashes简介" class="headerlink" title="1 Hashes简介"></a>1 Hashes简介</h2><a id="more"></a>

<p>Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</p>
<p>Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）。</p>
<h2 id="2-Hashes命令"><a href="#2-Hashes命令" class="headerlink" title="2 Hashes命令"></a>2 Hashes命令</h2><h3 id="2-1-help-hash"><a href="#2-1-help-hash" class="headerlink" title="2.1 help @hash"></a>2.1 help @hash</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @hash</span><br><span class="line"></span><br><span class="line">  HDEL key field [field ...]</span><br><span class="line">  summary: Delete one or more hash fields</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HEXISTS key field</span><br><span class="line">  summary: Determine if a hash field exists</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HGET key field</span><br><span class="line">  summary: Get the value of a hash field</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HGETALL key</span><br><span class="line">  summary: Get all the fields and values in a hash</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HINCRBY key field increment</span><br><span class="line">  summary: Increment the integer value of a hash field by the given number</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HINCRBYFLOAT key field increment</span><br><span class="line">  summary: Increment the float value of a hash field by the given amount</span><br><span class="line">  since: 2.6.0</span><br><span class="line"></span><br><span class="line">  HKEYS key</span><br><span class="line">  summary: Get all the fields in a hash</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HLEN key</span><br><span class="line">  summary: Get the number of fields in a hash</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HMGET key field [field ...]</span><br><span class="line">  summary: Get the values of all the given hash fields</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HMSET key field value [field value ...]</span><br><span class="line">  summary: Set multiple hash fields to multiple values</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HSCAN key cursor [MATCH pattern] [COUNT count]</span><br><span class="line">  summary: Incrementally iterate hash fields and associated values</span><br><span class="line">  since: 2.8.0</span><br><span class="line"></span><br><span class="line">  HSET key field value</span><br><span class="line">  summary: Set the string value of a hash field</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HSETNX key field value</span><br><span class="line">  summary: Set the value of a hash field, only if the field does not exist</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HSTRLEN key field</span><br><span class="line">  summary: Get the length of the value of a hash field</span><br><span class="line">  since: 3.2.0</span><br><span class="line"></span><br><span class="line">  HVALS key</span><br><span class="line">  summary: Get all the values in a hash</span><br><span class="line">  since: 2.0.0</span><br></pre></td></tr></table></figure>
<h3 id="2-2-HSET-amp-HGET"><a href="#2-2-HSET-amp-HGET" class="headerlink" title="2.2 HSET&amp;HGET"></a>2.2 HSET&amp;HGET</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help hset</span><br><span class="line"></span><br><span class="line">  HSET key field value</span><br><span class="line">  summary: Set the string value of a hash field</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: hash</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help hget</span><br><span class="line"></span><br><span class="line">  HGET key field</span><br><span class="line">  summary: Get the value of a hash field</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: hash</span><br></pre></td></tr></table></figure>
<p>HSET：将哈希表 <code>key</code> 中的域 <code>field</code> 的值设为 <code>value</code> 。</p>
<ul>
<li><p>如果 <code>key</code> 不存在，一个新的哈希表被创建并进行 HSET 操作。</p>
</li>
<li><p>如果域 <code>field</code> 已经存在于哈希表中，旧值将被覆盖。</p>
</li>
</ul>
<p>HGET：返回哈希表 <code>key</code> 中给定域 <code>field</code> 的值。</p>
<ul>
<li>当给定域不存在或是给定 <code>key</code> 不存在时，返回 <code>nil</code> 。</li>
</ul>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将yeyangshu name赋值yeyangshu</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HSET yeyangshu name yeyangshu</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HGET yeyangshu name</span><br><span class="line"><span class="string">&quot;yeyangshu&quot;</span></span><br><span class="line"><span class="comment"># 将yeyangshu name覆盖赋值yeyang</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HSET yeyangshu name yeyang</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HGET yeyangshu name</span><br><span class="line"><span class="string">&quot;yeyang&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取不存在的域</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HGET yeyangshu age</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<h3 id="2-3-HMSET-amp-HMGET"><a href="#2-3-HMSET-amp-HMGET" class="headerlink" title="2.3 HMSET&amp;HMGET"></a>2.3 HMSET&amp;HMGET</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help hmset</span><br><span class="line"></span><br><span class="line">  HMSET key field value [field value ...]</span><br><span class="line">  summary: Set multiple hash fields to multiple values</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: hash</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help hmget</span><br><span class="line"></span><br><span class="line">  HMGET key field [field ...]</span><br><span class="line">  summary: Get the values of all the given hash fields</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: hash</span><br></pre></td></tr></table></figure>
<p>HMSET：同时将多个 <code>field-value</code> (域-值)对设置到哈希表 <code>key</code> 中。</p>
<ul>
<li>此命令会覆盖哈希表中已存在的域。</li>
</ul>
<p>HMGET：返回哈希表 <code>key</code> 中，一个或多个给定域的值。</p>
<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HMSET sean age 20 address beijing</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; HMGET sean name</span><br><span class="line">&quot;yeyangshu&quot;</span><br><span class="line">127.0.0.1:6379&gt; HMGET sean name age address</span><br><span class="line">1) &quot;yeyangshu&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">3) &quot;beijing&quot;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-HGETALL"><a href="#2-4-HGETALL" class="headerlink" title="2.4 HGETALL"></a>2.4 HGETALL</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help hgetall</span><br><span class="line"></span><br><span class="line">  HGETALL key</span><br><span class="line">  summary: Get all the fields and values in a hash</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: hash</span><br></pre></td></tr></table></figure>
<p>HGETALL：返回哈希表 <code>key</code> 中，所有的域和值。</p>
<ul>
<li>在返回值里，紧跟每个域名(field name)之后是域的值(value)，所以返回值的长度是哈希表大小的两倍。</li>
</ul>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HGETALL sean</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;yeyangshu&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;address&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-HKEYS-amp-HVALS"><a href="#2-5-HKEYS-amp-HVALS" class="headerlink" title="2.5 HKEYS&amp;HVALS"></a>2.5 HKEYS&amp;HVALS</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help hkeys</span><br><span class="line"></span><br><span class="line">  HKEYS key</span><br><span class="line">  summary: Get all the fields in a hash</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: hash</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help hvals</span><br><span class="line"></span><br><span class="line">  HVALS key</span><br><span class="line">  summary: Get all the values in a hash</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: hash</span><br></pre></td></tr></table></figure>
<p>HKEYS：返回哈希表 <code>key</code> 中的所有域。</p>
<p>HVALS：返回哈希表 <code>key</code> 中所有域的值。</p>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HKEYS sean</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;address&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HVALS sean</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;yeyangshu&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;beijing&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-6-HINCRBY-amp-HINCRBYFLOAT"><a href="#2-6-HINCRBY-amp-HINCRBYFLOAT" class="headerlink" title="2.6 HINCRBY&amp;HINCRBYFLOAT"></a>2.6 HINCRBY&amp;HINCRBYFLOAT</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help hincrby</span><br><span class="line"></span><br><span class="line">  HINCRBY key field increment</span><br><span class="line">  summary: Increment the integer value of a hash field by the given number</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: hash</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help hincrbyfloat</span><br><span class="line"></span><br><span class="line">  HINCRBYFLOAT key field increment</span><br><span class="line">  summary: Increment the float value of a hash field by the given amount</span><br><span class="line">  since: 2.6.0</span><br><span class="line">  group: hash</span><br></pre></td></tr></table></figure>
<p>HINCRBY：为哈希表 <code>key</code> 中的域 <code>field</code> 的值加上增量 <code>increment</code> 。</p>
<ul>
<li>增量也可以为负数，相当于对给定域进行减法操作。</li>
</ul>
<p>HINCRBYFLOAT：为哈希表 <code>key</code> 中的域 <code>field</code> 加上浮点数增量 <code>increment</code> 。</p>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HINCRBYFLOAT sean age <span class="number">0.5</span></span><br><span class="line"><span class="string">&quot;20.5&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HGET sean age</span><br><span class="line"><span class="string">&quot;20.5&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HINCRBYFLOAT sean age <span class="literal">-1</span></span><br><span class="line"><span class="string">&quot;19.5&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Hashes使用场景"><a href="#3-Hashes使用场景" class="headerlink" title="3 Hashes使用场景"></a>3 Hashes使用场景</h2><ol>
<li>Redis是内存的数据库，所有对值的操作都是非常快的，一般的商品详情页都会有很多字段信息，如果客户端请求这么多数据，每一个数据都需要请求一次数据库，可以使用Redis hashes，将所有的信息进行整合，数据整合，调用次数会变低。</li>
<li>数据都会变化，比如微博的个人关注、点赞或者商品详情页的浏览次数、被收藏的次数，数据不仅要被查询，还要进行计算，hash还支持数值计算。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 基本数据类型 Lists</title>
    <url>/2020/12/26/Redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-Lists/</url>
    <content><![CDATA[<h1 id="Redis-Lists"><a href="#Redis-Lists" class="headerlink" title="Redis Lists"></a>Redis Lists</h1><h2 id="1-Lists简介"><a href="#1-Lists简介" class="headerlink" title="1 Lists简介"></a>1 Lists简介</h2><a id="more"></a>

<p>官网：</p>
<p>Redis lists基于Linked Lists实现。这意味着即使在一个list中有数百万个元素，在头部或尾部添加一个元素的操作，其时间复杂度也是常数级别的。用LPUSH 命令在十个元素的list头部添加新元素，和在千万元素list头部添加新元素的速度相同。</p>
<p>那么，坏消息是什么？在数组实现的list中利用索引访问元素的速度极快，而同样的操作在linked list实现的list上没有那么快。</p>
<p>Redis Lists用linked list实现的原因是：对于数据库系统来说，至关重要的特性是：能非常快的在很大的列表上添加元素。另一个重要因素是，正如你将要看到的：Redis lists能在常数时间取得常数长度。</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200707204400692.png" alt="image-20200707204400692"></p>
<h2 id="2-List命令"><a href="#2-List命令" class="headerlink" title="2 List命令"></a>2 List命令</h2><h3 id="2-1-help-list"><a href="#2-1-help-list" class="headerlink" title="2.1 help @list"></a>2.1 help @list</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @list</span><br><span class="line"></span><br><span class="line">  BLPOP key [key ...] timeout</span><br><span class="line">  summary: Remove and get the first element in a list, or block until one is available</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  BRPOP key [key ...] timeout</span><br><span class="line">  summary: Remove and get the last element in a list, or block until one is available</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  BRPOPLPUSH source destination timeout</span><br><span class="line">  summary: Pop a value from a list, push it to another list and return it; or block until one is available</span><br><span class="line">  since: 2.2.0</span><br><span class="line"></span><br><span class="line">  LINDEX key index</span><br><span class="line">  summary: Get an element from a list by its index</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  LINSERT key BEFORE|AFTER pivot value</span><br><span class="line">  summary: Insert an element before or after another element in a list</span><br><span class="line">  since: 2.2.0</span><br><span class="line"></span><br><span class="line">  LLEN key</span><br><span class="line">  summary: Get the length of a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  LPOP key</span><br><span class="line">  summary: Remove and get the first element in a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  LPUSH key value [value ...]</span><br><span class="line">  summary: Prepend one or multiple values to a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  LPUSHX key value</span><br><span class="line">  summary: Prepend a value to a list, only if the list exists</span><br><span class="line">  since: 2.2.0</span><br><span class="line"></span><br><span class="line">  LRANGE key start stop</span><br><span class="line">  summary: Get a range of elements from a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  LREM key count value</span><br><span class="line">  summary: Remove elements from a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  LSET key index value</span><br><span class="line">  summary: Set the value of an element in a list by its index</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  LTRIM key start stop</span><br><span class="line">  summary: Trim a list to the specified range</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  RPOP key</span><br><span class="line">  summary: Remove and get the last element in a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  RPOPLPUSH source destination</span><br><span class="line">  summary: Remove the last element in a list, prepend it to another list and return it</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  RPUSH key value [value ...]</span><br><span class="line">  summary: Append one or multiple values to a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  RPUSHX key value</span><br><span class="line">  summary: Append a value to a list, only if the list exists</span><br><span class="line">  since: 2.2.0</span><br></pre></td></tr></table></figure>
<h3 id="2-2-LPUSH-amp-RPUSH-amp-LPOP-amp-RPOP"><a href="#2-2-LPUSH-amp-RPUSH-amp-LPOP-amp-RPOP" class="headerlink" title="2.2 LPUSH&amp;RPUSH&amp;LPOP&amp;RPOP"></a>2.2 LPUSH&amp;RPUSH&amp;LPOP&amp;RPOP</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help lpush</span><br><span class="line"></span><br><span class="line">  LPUSH key value [value ...]</span><br><span class="line">  summary: Prepend one or multiple values to a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: list</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help rpush</span><br><span class="line"></span><br><span class="line">  RPUSH key value [value ...]</span><br><span class="line">  summary: Append one or multiple values to a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: list</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help lpop</span><br><span class="line"></span><br><span class="line">  LPOP key</span><br><span class="line">  summary: Remove and get the first element in a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: list</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help rpop</span><br><span class="line"></span><br><span class="line">  RPOP key</span><br><span class="line">  summary: Remove and get the last element in a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: list</span><br></pre></td></tr></table></figure>
<p>LPUSH：将一个或多个值 <code>value</code> 插入到列表 <code>key</code> 的表头</p>
<ul>
<li>如果有多个 <code>value</code> 值，那么各个 <code>value</code> 值按从左到右的顺序依次插入到表头</li>
</ul>
<p>RPUSH：将一个或多个值 <code>value</code> 插入到列表 <code>key</code> 的表尾(最右边)。</p>
<ul>
<li>如果有多个 <code>value</code> 值，那么各个 <code>value</code> 值按从左到右的顺序依次插入到表尾</li>
</ul>
<p>LPOP：移除并返回列表 <code>key</code> 的头元素。</p>
<p>RPOP：移除并返回列表 <code>key</code> 的尾元素。</p>
<p><strong>可以实现两种数据结构：</strong></p>
<ul>
<li><strong>栈：同向命令实现，LPUSH+LPOP</strong></li>
<li><strong>队列：反向命令实现，LPUSH+RPOP</strong></li>
</ul>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此时链表排列顺序为 f e d c b a</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LPUSH k1 a b c d e f</span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"><span class="comment"># 此时链表排列顺序为 a b c d e f</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; RPUSH k2 a b c d e f</span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"><span class="comment"># 后进先出，栈</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LPOP k1</span><br><span class="line"><span class="string">&quot;f&quot;</span></span><br><span class="line"><span class="comment"># 先进先出，队列</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; RPOP k1</span><br><span class="line"><span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-LRANGE"><a href="#2-3-LRANGE" class="headerlink" title="2.3 LRANGE"></a>2.3 LRANGE</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help lrange</span><br><span class="line"></span><br><span class="line">  LRANGE key start stop</span><br><span class="line">  summary: Get a range of elements from a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: list</span><br></pre></td></tr></table></figure>
<p>LRANGE：返回列表 <code>key</code> 中指定区间内的元素，区间以偏移量 <code>start</code> 和 <code>stop</code> 指定。可以使用正负索引。</p>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此时链表排列顺序为 f e d c b a</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LPUSH k1 a b c d e f</span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LRANGE k1 <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;f&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;e&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时链表排列顺序为 a b c d e f</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; RPUSH k2 a b c d e f</span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LRANGE k2 <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;e&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;f&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-4-LINDEX-amp-LSET"><a href="#2-4-LINDEX-amp-LSET" class="headerlink" title="2.4 LINDEX&amp;LSET"></a>2.4 LINDEX&amp;LSET</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help lindex</span><br><span class="line"></span><br><span class="line">  LINDEX key index</span><br><span class="line">  summary: Get an element from a list by its index</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: list</span><br><span class="line">  </span><br><span class="line">127.0.0.1:6379&gt; help lset</span><br><span class="line"></span><br><span class="line">  LSET key index value</span><br><span class="line">  summary: Set the value of an element in a list by its index</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: list</span><br></pre></td></tr></table></figure>
<p>LINDEX：返回列表 <code>key</code> 中，下标为 <code>index</code> 的元素。将列表 <code>key</code> 下标为 <code>index</code> 的元素的值设置为 <code>value</code> 。</p>
<p>LSET：将列表 <code>key</code> 下标为 <code>index</code> 的元素的值设置为 <code>value</code> 。</p>
<ul>
<li>当 <code>index</code> 参数超出范围，或对一个空列表( <code>key</code> 不存在)进行 LSET 时，返回一个错误。</li>
</ul>
<p><strong>可以实现的数据结构</strong></p>
<ul>
<li><strong>数组：LINDEX+LSET，都是对下标进行操作</strong></li>
</ul>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此时链表排列顺序为 f(0) e(1) d(2) c(3) b(4) a(5)</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LPUSH k1 a b c d e f</span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"><span class="comment"># 取下标为2的元素</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LINDEX k1 <span class="number">2</span></span><br><span class="line"><span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="comment"># 取列表最后一位元素</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LINDEX k1 <span class="literal">-1</span></span><br><span class="line"><span class="string">&quot;a&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时链表排列顺序为 f(0) e(1) d(2) c(3) b(4) a(5)</span></span><br><span class="line"><span class="comment"># 设置下标为3的元素的值为X</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LSET k1 <span class="number">3</span> X</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LRANGE k1 <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;f&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;e&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;X&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-LREM-amp-LINSERT"><a href="#2-5-LREM-amp-LINSERT" class="headerlink" title="2.5 LREM&amp;LINSERT"></a>2.5 LREM&amp;LINSERT</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help lrem</span><br><span class="line"></span><br><span class="line">  LREM key count value</span><br><span class="line">  summary: Remove elements from a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: list</span><br><span class="line">  </span><br><span class="line">127.0.0.1:6379&gt; help linsert</span><br><span class="line"></span><br><span class="line">  LINSERT key BEFORE|AFTER pivot value</span><br><span class="line">  summary: Insert an element before or after another element in a list</span><br><span class="line">  since: 2.2.0</span><br><span class="line">  group: list</span><br></pre></td></tr></table></figure>
<p>LREM：根据参数 <code>count</code> 的值，移除列表中与参数 <code>value</code> 相等的元素。</p>
<p><code>count</code> 的值可以是以下几种：</p>
<ul>
<li><code>count &gt; 0</code> : 从表头开始向表尾搜索，移除与 <code>value</code> 相等的元素，数量为 <code>count</code> 。</li>
<li><code>count &lt; 0</code> : 从表尾开始向表头搜索，移除与 <code>value</code> 相等的元素，数量为 <code>count</code> 的绝对值。</li>
<li><code>count = 0</code> : 移除表中所有与 <code>value</code> 相等的值。</li>
</ul>
<p>LINSERT：将值 <code>value</code> 插入到列表 <code>key</code> 当中，位于值 <code>pivot</code> 之前或之后。</p>
<ul>
<li><p>当 <code>pivot</code> 不存在于列表 <code>key</code> 时，不执行任何操作。</p>
</li>
<li><p>当 <code>key</code> 不存在时， <code>key</code> 被视为空列表，不执行任何操作。</p>
</li>
<li><p>如果 <code>key</code> 不是列表类型，返回一个错误。</p>
</li>
</ul>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此时链表排列顺序为 7 a 6 e 5 a 4 c 3 b 2 a 1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LPUSH k3 <span class="number">1</span> a <span class="number">2</span> b <span class="number">3</span> c <span class="number">4</span> a <span class="number">5</span> e <span class="number">6</span> a <span class="number">7</span></span><br><span class="line">(integer) <span class="number">13</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LRANGE k3 <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"> <span class="number">1</span>) <span class="string">&quot;7&quot;</span></span><br><span class="line"> <span class="number">2</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"> <span class="number">3</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"> <span class="number">4</span>) <span class="string">&quot;e&quot;</span></span><br><span class="line"> <span class="number">5</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"> <span class="number">6</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"> <span class="number">7</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"> <span class="number">8</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"> <span class="number">9</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">10</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">11</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">12</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">13</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除链表元素，count&gt;0，从表头开始向表尾开始移除</span></span><br><span class="line"><span class="comment"># 此时链表排列顺序为 7 6 e 5 4 c 3 b 2 a 1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LREM k3 <span class="number">2</span> a</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LRANGE k3 <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"> <span class="number">1</span>) <span class="string">&quot;7&quot;</span></span><br><span class="line"> <span class="number">2</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"> <span class="number">3</span>) <span class="string">&quot;e&quot;</span></span><br><span class="line"> <span class="number">4</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"> <span class="number">5</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"> <span class="number">6</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"> <span class="number">7</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"> <span class="number">8</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"> <span class="number">9</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">10</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">11</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加链表元素</span></span><br><span class="line"><span class="comment"># 在元素6后面添加a，此时链表排列顺序为 7 6 a e 5 4 c 3 b 2 a 1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LINSERT k3 after <span class="number">6</span> a</span><br><span class="line">(integer) <span class="number">12</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LRANGE k3 <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"> <span class="number">1</span>) <span class="string">&quot;7&quot;</span></span><br><span class="line"> <span class="number">2</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"> <span class="number">3</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"> <span class="number">4</span>) <span class="string">&quot;e&quot;</span></span><br><span class="line"> <span class="number">5</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"> <span class="number">6</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"> <span class="number">7</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"> <span class="number">8</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"> <span class="number">9</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">10</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">11</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">12</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="comment"># 在元素3前面添加a，此时链表排列顺序为 7 6 a e 5 4 c a 3 b 2 a 1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LINSERT k3 before <span class="number">3</span> a</span><br><span class="line">(integer) <span class="number">13</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LRANGE k3 <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"> <span class="number">1</span>) <span class="string">&quot;7&quot;</span></span><br><span class="line"> <span class="number">2</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"> <span class="number">3</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"> <span class="number">4</span>) <span class="string">&quot;e&quot;</span></span><br><span class="line"> <span class="number">5</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"> <span class="number">6</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"> <span class="number">7</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"> <span class="number">8</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"> <span class="number">9</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">10</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">11</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">12</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">13</span>) <span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-6-LLEN"><a href="#2-6-LLEN" class="headerlink" title="2.6 LLEN"></a>2.6 LLEN</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help llen</span><br><span class="line"></span><br><span class="line">  LLEN key</span><br><span class="line">  summary: Get the length of a list</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: list</span><br></pre></td></tr></table></figure>
<p>LLEN：返回列表 <code>key</code> 的长度。</p>
<ul>
<li><p>如果 <code>key</code> 不存在，则 <code>key</code> 被解释为一个空列表，返回 <code>0</code> .</p>
</li>
<li><p>如果 <code>key</code> 不是列表类型，返回一个错误。</p>
</li>
</ul>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LRANGE k3 <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"> <span class="number">1</span>) <span class="string">&quot;7&quot;</span></span><br><span class="line"> <span class="number">2</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"> <span class="number">3</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"> <span class="number">4</span>) <span class="string">&quot;e&quot;</span></span><br><span class="line"> <span class="number">5</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"> <span class="number">6</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"> <span class="number">7</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"> <span class="number">8</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"> <span class="number">9</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">10</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">11</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">12</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">13</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="comment"># 返回k3的元素长度</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LLEN k3</span><br><span class="line">(integer) <span class="number">13</span></span><br></pre></td></tr></table></figure>
<h3 id="2-7-LTRIM"><a href="#2-7-LTRIM" class="headerlink" title="2.7 LTRIM"></a>2.7 LTRIM</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help ltrim</span><br><span class="line"></span><br><span class="line">  LTRIM key start stop</span><br><span class="line">  summary: Trim a list to the specified range</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: list</span><br></pre></td></tr></table></figure>
<p>LTRIM：对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</p>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LPUSH k1 <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></span><br><span class="line">(integer) <span class="number">9</span></span><br><span class="line"><span class="comment"># 此时链表排列顺序为 8(0) 7(1) 6(2) 5(3) 4(4) 3(5) 2(6) 1(7) 0(8)</span></span><br><span class="line"><span class="comment"># 将下标不在2-6的元素删除</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LTRIM k1 <span class="number">2</span> <span class="number">6</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LRANGE k1 <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;2&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-8-BLPOP-amp-BRPOP"><a href="#2-8-BLPOP-amp-BRPOP" class="headerlink" title="2.8 BLPOP&amp;BRPOP"></a>2.8 BLPOP&amp;BRPOP</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help blpop</span><br><span class="line"></span><br><span class="line">  BLPOP key [key ...] timeout</span><br><span class="line">  summary: Remove and get the first element in a list, or block until one is available</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: list</span><br><span class="line">  </span><br><span class="line">127.0.0.1:6379&gt; help brpop</span><br><span class="line"></span><br><span class="line">  BRPOP key [key ...] timeout</span><br><span class="line">  summary: Remove and get the last element in a list, or block until one is available</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: list</span><br></pre></td></tr></table></figure>
<p>BLPOP：列表的阻塞式(blocking)弹出原语，超时参数 <code>timeout</code> 接受一个以秒为单位的数字作为值。超时参数设为 <code>0</code> 表示阻塞时间可以无限期延长(block indefinitely) 。</p>
<ul>
<li><p>它是 LPOP 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BLPOP 命令阻塞，直到等待超时或发现可弹出元素为止。</p>
</li>
<li><p>当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的头元素。</p>
</li>
<li><p>如果所有给定 key 都不存在或包含空列表，那么 BLPOP 命令将阻塞连接，直到等待超时，或有另一个客户端对给定 key 的任意一个执行 LPUSH 或 RPUSH 命令为止。</p>
</li>
</ul>
<p>可以实现的数据结构：</p>
<ul>
<li><strong>阻塞、单播队列，FIFO：BLPOP</strong></li>
</ul>
<p>案例：</p>
<p>client1阻塞等待：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 无限期阻塞</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; BLPOP b1 <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>client2阻塞等待:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 无限期阻塞</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; BLPOP b1 <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>client3</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># client3向b1添加&quot;hello&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; RPUSH b1 hello</span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>此时client1接收到值</p>
<img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200707220037491.png"  align="left"/>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; BLPOP b1 <span class="number">0</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;b1&quot;</span>                          <span class="comment"># 这里被 push 的是 b1</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;hello&quot;</span>            			 <span class="comment"># 被弹出的值</span></span><br><span class="line">(<span class="number">26.97</span>s)                         <span class="comment"># 等待的秒数</span></span><br></pre></td></tr></table></figure>
<p>此时client2还在阻塞</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 无限期阻塞</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; BLPOP b1 <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>client3再向b1添加值</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># client3向b1添加&quot;world&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; RPUSH b1 world</span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>此时client2</p>
<img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200707220218395.png"  align="left"/>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; BLPOP b1 <span class="number">0</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;b1&quot;</span>                          <span class="comment"># 这里被 push 的是 b1</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;world&quot;</span>            			 <span class="comment"># 被弹出的值</span></span><br><span class="line">(<span class="number">35.33</span>s)                         <span class="comment"># 等待的秒数</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Lists应用场景"><a href="#3-Lists应用场景" class="headerlink" title="3 Lists应用场景"></a>3 Lists应用场景</h2><p>官网：</p>
<p>正如你可以从上面的例子中猜到的，list可被用来实现聊天系统。还可以作为不同进程间传递消息的队列。关键是，你可以每次都以原先添加的顺序访问数据。这不需要任何SQL ORDER BY 操作，将会非常快，也会很容易扩展到百万级别元素的规模。</p>
<p>例如在评级系统中，比如社会化新闻网站 reddit.com，你可以把每个新提交的链接添加到一个list，用LRANGE可简单的对结果分页。</p>
<p>在博客引擎实现中，你可为每篇日志设置一个list，在该list中推入博客评论，等等。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 基本数据类型 Sets</title>
    <url>/2020/12/26/Redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-Sets/</url>
    <content><![CDATA[<h1 id="Redis-Sets"><a href="#Redis-Sets" class="headerlink" title="Redis Sets"></a>Redis Sets</h1><h2 id="1-Sets简介"><a href="#1-Sets简介" class="headerlink" title="1 Sets简介"></a>1 Sets简介</h2><a id="more"></a>

<p>Redis Set 是 String 的无序排列。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p>
<p>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p>
<p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>
<h2 id="2-Sets命令"><a href="#2-Sets命令" class="headerlink" title="2 Sets命令"></a>2 Sets命令</h2><h3 id="2-1-help-set"><a href="#2-1-help-set" class="headerlink" title="2.1 help @set"></a>2.1 help @set</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @set</span><br><span class="line"></span><br><span class="line">  SADD key member [member ...]</span><br><span class="line">  summary: Add one or more members to a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SCARD key</span><br><span class="line">  summary: Get the number of members in a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SDIFF key [key ...]</span><br><span class="line">  summary: Subtract multiple sets</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SDIFFSTORE destination key [key ...]</span><br><span class="line">  summary: Subtract multiple sets and store the resulting set in a key</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SINTER key [key ...]</span><br><span class="line">  summary: Intersect multiple sets</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SINTERSTORE destination key [key ...]</span><br><span class="line">  summary: Intersect multiple sets and store the resulting set in a key</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SISMEMBER key member</span><br><span class="line">  summary: Determine if a given value is a member of a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SMEMBERS key</span><br><span class="line">  summary: Get all the members in a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SMOVE source destination member</span><br><span class="line">  summary: Move a member from one set to another</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SPOP key [count]</span><br><span class="line">  summary: Remove and return one or multiple random members from a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SRANDMEMBER key [count]</span><br><span class="line">  summary: Get one or multiple random members from a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SREM key member [member ...]</span><br><span class="line">  summary: Remove one or more members from a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SSCAN key cursor [MATCH pattern] [COUNT count]</span><br><span class="line">  summary: Incrementally iterate Set elements</span><br><span class="line">  since: 2.8.0</span><br><span class="line"></span><br><span class="line">  SUNION key [key ...]</span><br><span class="line">  summary: Add multiple sets</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SUNIONSTORE destination key [key ...]</span><br><span class="line">  summary: Add multiple sets and store the resulting set in a key</span><br><span class="line">  since: 1.0.0</span><br></pre></td></tr></table></figure>
<h3 id="2-2-SADD-amp-SMEMBERS"><a href="#2-2-SADD-amp-SMEMBERS" class="headerlink" title="2.2 SADD&amp;SMEMBERS"></a>2.2 SADD&amp;SMEMBERS</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help sadd</span><br><span class="line"></span><br><span class="line">  SADD key member [member ...]</span><br><span class="line">  summary: Add one or more members to a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: set</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help smembers</span><br><span class="line"></span><br><span class="line">  SMEMBERS key</span><br><span class="line">  summary: Get all the members in a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: set</span><br></pre></td></tr></table></figure>
<p>SADD：将一个或多个 <code>member</code> 元素加入到集合 <code>key</code> 当中，已经存在于集合的 <code>member</code> 元素将被忽略。</p>
<ul>
<li><p>假如 <code>key</code> 不存在，则创建一个只包含 <code>member</code> 元素作成员的集合。</p>
</li>
<li><p>当 <code>key</code> 不是集合类型时，返回一个错误。</p>
</li>
</ul>
<p>SMEMBERS：返回集合 <code>key</code> 中的所有成员。</p>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 向k1添加重复元素</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SADD k1 sean tom peter tom ooxx ooxx</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="comment"># k1取出所有元素</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SMEMBERS k1</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;ooxx&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;peter&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;tom&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;sean&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-SREM"><a href="#2-3-SREM" class="headerlink" title="2.3 SREM"></a>2.3 SREM</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help srem</span><br><span class="line"></span><br><span class="line">  SREM key member [member ...]</span><br><span class="line">  summary: Remove one or more members from a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: set</span><br></pre></td></tr></table></figure>
<p>SREM：移除集合 <code>key</code> 中的一个或多个 <code>member</code> 元素，不存在的 <code>member</code> 元素会被忽略。</p>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># k1取出所有元素</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SMEMBERS k1</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;ooxx&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;peter&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;tom&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;sean&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SREM k1 ooxx</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SMEMBERS k1</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;tom&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;sean&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;peter&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-4-SINTER-amp-SUNION-amp-SDIFF"><a href="#2-4-SINTER-amp-SUNION-amp-SDIFF" class="headerlink" title="2.4 SINTER&amp;SUNION&amp;SDIFF"></a>2.4 SINTER&amp;SUNION&amp;SDIFF</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help sinter</span><br><span class="line"></span><br><span class="line">  SINTER key [key ...]</span><br><span class="line">  summary: Intersect multiple sets</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: set</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help sinterstore</span><br><span class="line"></span><br><span class="line">  SINTERSTORE destination key [key ...]</span><br><span class="line">  summary: Intersect multiple sets and store the resulting set in a key</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: set</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help sunion</span><br><span class="line"></span><br><span class="line">  SUNION key [key ...]</span><br><span class="line">  summary: Add multiple sets</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: set</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help sdiff</span><br><span class="line"></span><br><span class="line">  SDIFF key [key ...]</span><br><span class="line">  summary: Subtract multiple sets</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: set</span><br></pre></td></tr></table></figure>
<p>SINTER：返回一个集合的全部成员，该集合是所有给定集合的交集。</p>
<p>SINTERSTORE：这个命令类似于 SINTER 命令，但它将结果保存到 <code>destination</code> 集合，而不是简单地返回结果集。</p>
<ul>
<li><p>如果 <code>destination</code> 集合已经存在，则将其覆盖。</p>
</li>
<li><p><code>destination</code> 可以是 <code>key</code> 本身。</p>
</li>
</ul>
<p>SUNION：返回一个集合的全部成员，该集合是所有给定集合的并集。</p>
<p>SUNIONSTORE：这个命令类似于 SUNION 命令，但它将结果保存到 <code>destination</code> 集合，而不是简单地返回结果集。</p>
<ul>
<li><p>如果 <code>destination</code> 已经存在，则将其覆盖。</p>
</li>
<li><p><code>-destination</code> 可以是 <code>key</code> 本身。</p>
</li>
</ul>
<p>SDIFF：返回一个集合的全部成员，该集合是所有给定集合之间的差集。</p>
<p>SDIFFSTORE：这个命令的作用和 SDIFF 类似，但它将结果保存到 <code>destination</code> 集合，而不是简单地返回结果集。</p>
<ul>
<li><p>如果 <code>destination</code> 集合已经存在，则将其覆盖。</p>
</li>
<li><p><code>destination</code> 可以是 <code>key</code> 本身。</p>
</li>
</ul>
<p>案例：</p>
<p>交集</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SADD k2 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SADD k3 <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"><span class="comment"># k3与k3交集</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SINTER k2 k3</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将交集结果存入dest</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SINTERSTORE dest k2 k3</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SMEMBERS dest</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;6&quot;</span></span><br></pre></td></tr></table></figure>
<p>并集</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SUNION k2 k3</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"><span class="number">7</span>) <span class="string">&quot;7&quot;</span></span><br><span class="line"><span class="number">8</span>) <span class="string">&quot;8&quot;</span></span><br></pre></td></tr></table></figure>
<p>差集</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SDIFF k2 k3</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SDIFF k3 k2</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;7&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;8&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-SRANDMEMBER-amp-SPOP"><a href="#2-5-SRANDMEMBER-amp-SPOP" class="headerlink" title="2.5 SRANDMEMBER&amp;SPOP"></a>2.5 SRANDMEMBER&amp;SPOP</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help srandmember</span><br><span class="line"></span><br><span class="line">  SRANDMEMBER key [count]</span><br><span class="line">  summary: Get one or multiple random members from a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: set</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help spop</span><br><span class="line"></span><br><span class="line">  SPOP key [count]</span><br><span class="line">  summary: Remove and return one or multiple random members from a set</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: set</span><br></pre></td></tr></table></figure>
<p>SRANDMEMBER：如果命令执行时，只提供了 <code>key</code> 参数，那么返回集合中的一个随机元素。</p>
<p>从 Redis 2.6 版本开始， SRANDMEMBER 命令接受可选的 <code>count</code> 参数：</p>
<ul>
<li>如果 <code>count</code> 为正数，且小于集合基数，那么命令返回一个包含 <code>count</code> 个元素的数组，数组中的元素<strong>各不相同</strong>。如果 <code>count</code> 大于等于集合基数，那么返回整个集合。</li>
<li>如果 <code>count</code> 为负数，那么命令返回一个数组，数组中的元素<strong>可能会重复出现多次</strong>，而数组的长度为 <code>count</code> 的绝对值。</li>
</ul>
<p>SPOP：移除并返回集合中的一个随机元素。</p>
<p>案例：</p>
<p>SRANDMEMBER</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SADD k2 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"><span class="comment"># count正数：取出一个去重的结果集（不能超过已有集）</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SRANDMEMBER k2 <span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="comment"># count负数：取出一个带重复的结果集</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SRANDMEMBER k2 <span class="literal">-3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"><span class="comment"># count为0，不返回</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SRANDMEMBER k2 <span class="number">0</span></span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SRANDMEMBER k2 <span class="number">10</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SRANDMEMBER k2 <span class="literal">-10</span></span><br><span class="line"> <span class="number">1</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"> <span class="number">2</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"> <span class="number">3</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"> <span class="number">4</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"> <span class="number">5</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"> <span class="number">6</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"> <span class="number">7</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"> <span class="number">8</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"> <span class="number">9</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">10</span>) <span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure>
<p>SPOP</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SPOP k2 <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SPOP k2 <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SPOP k2 <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;6&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SPOP k2 <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SPOP k2 <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SPOP k2 <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SPOP k2 <span class="number">1</span></span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure>
<h2 id="3-Sets使用场景"><a href="#3-Sets使用场景" class="headerlink" title="3 Sets使用场景"></a>3 Sets使用场景</h2><ol>
<li><p>随机抽奖，一次出结果</p>
<p>情景一 人多奖品少：3个奖品，10个人抽奖，抽3个并且没有重复，使用<code>SRANDMEMBER key 3</code></p>
<p>情景二 人少奖品多：10个奖品，3个人抽奖，抽10个可以有重复，使用<code>SRANDMEMBER key -10</code></p>
</li>
<li><p>随机抽奖，一次一个</p>
<p>奖品分为一、二、三等奖，每次只抽一个人，SPOP key 1</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 基本数据类型 Sorted Sets</title>
    <url>/2020/12/26/Redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-Sorted-Sets/</url>
    <content><![CDATA[<h1 id="Redis-Sorted-Sets"><a href="#Redis-Sorted-Sets" class="headerlink" title="Redis Sorted Sets"></a>Redis Sorted Sets</h1><h2 id="1-Sorted-Sets简介"><a href="#1-Sorted-Sets简介" class="headerlink" title="1 Sorted Sets简介"></a>1 Sorted Sets简介</h2><a id="more"></a>

<p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。</p>
<p>不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>有序集合的成员是唯一的,但分数(score)却可以重复。</p>
<p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>
<h2 id="2-Sorted-Sets命令"><a href="#2-Sorted-Sets命令" class="headerlink" title="2 Sorted Sets命令"></a>2 Sorted Sets命令</h2><h3 id="2-1-help-sorted-set"><a href="#2-1-help-sorted-set" class="headerlink" title="2.1 help @sorted_set"></a>2.1 help @sorted_set</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @sorted_set</span><br><span class="line"></span><br><span class="line">  ZADD key [NX|XX] [CH] [INCR] score member [score member ...]</span><br><span class="line">  summary: Add one or more members to a sorted set, or update its score if it already exists</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  ZCARD key</span><br><span class="line">  summary: Get the number of members in a sorted set</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  ZCOUNT key min max</span><br><span class="line">  summary: Count the members in a sorted set with scores within the given values</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  ZINCRBY key increment member</span><br><span class="line">  summary: Increment the score of a member in a sorted set</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]</span><br><span class="line">  summary: Intersect multiple sorted sets and store the resulting sorted set in a new key</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  ZLEXCOUNT key min max</span><br><span class="line">  summary: Count the number of members in a sorted set between a given lexicographical range</span><br><span class="line">  since: 2.8.9</span><br><span class="line"></span><br><span class="line">  ZRANGE key start stop [WITHSCORES]</span><br><span class="line">  summary: Return a range of members in a sorted set, by index</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  ZRANGEBYLEX key min max [LIMIT offset count]</span><br><span class="line">  summary: Return a range of members in a sorted set, by lexicographical range</span><br><span class="line">  since: 2.8.9</span><br><span class="line"></span><br><span class="line">  ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br><span class="line">  summary: Return a range of members in a sorted set, by score</span><br><span class="line">  since: 1.0.5</span><br><span class="line"></span><br><span class="line">  ZRANK key member</span><br><span class="line">  summary: Determine the index of a member in a sorted set</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  ZREM key member [member ...]</span><br><span class="line">  summary: Remove one or more members from a sorted set</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  ZREMRANGEBYLEX key min max</span><br><span class="line">  summary: Remove all members in a sorted set between the given lexicographical range</span><br><span class="line">  since: 2.8.9</span><br><span class="line"></span><br><span class="line">  ZREMRANGEBYRANK key start stop</span><br><span class="line">  summary: Remove all members in a sorted set within the given indexes</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  ZREMRANGEBYSCORE key min max</span><br><span class="line">  summary: Remove all members in a sorted set within the given scores</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  ZREVRANGE key start stop [WITHSCORES]</span><br><span class="line">  summary: Return a range of members in a sorted set, by index, with scores ordered from high to low</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  ZREVRANGEBYLEX key max min [LIMIT offset count]</span><br><span class="line">  summary: Return a range of members in a sorted set, by lexicographical range, ordered from higher to lower strings.</span><br><span class="line">  since: 2.8.9</span><br><span class="line"></span><br><span class="line">  ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</span><br><span class="line">  summary: Return a range of members in a sorted set, by score, with scores ordered from high to low</span><br><span class="line">  since: 2.2.0</span><br><span class="line"></span><br><span class="line">  ZREVRANK key member</span><br><span class="line">  summary: Determine the index of a member in a sorted set, with scores ordered from high to low</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  ZSCAN key cursor [MATCH pattern] [COUNT count]</span><br><span class="line">  summary: Incrementally iterate sorted sets elements and associated scores</span><br><span class="line">  since: 2.8.0</span><br><span class="line"></span><br><span class="line">  ZSCORE key member</span><br><span class="line">  summary: Get the score associated with the given member in a sorted set</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]</span><br><span class="line">  summary: Add multiple sorted sets and store the resulting sorted set in a new key</span><br><span class="line">  since: 2.0.0</span><br></pre></td></tr></table></figure>
<h3 id="2-2-ZADD"><a href="#2-2-ZADD" class="headerlink" title="2.2 ZADD"></a>2.2 ZADD</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help zadd</span><br><span class="line"></span><br><span class="line">  ZADD key [NX|XX] [CH] [INCR] score member [score member ...]</span><br><span class="line">  summary: Add one or more members to a sorted set, or update its score if it already exists</span><br><span class="line">  since: 1.2.0</span><br><span class="line">  group: sorted_set</span><br></pre></td></tr></table></figure>
<p>ZADD：将一个或多个 <code>member</code> 元素及其 <code>score</code> 值加入到有序集 <code>key</code> 当中。</p>
<ul>
<li>如果某个 <code>member</code> 已经是有序集的成员，那么更新这个 <code>member</code> 的 <code>score</code> 值，并通过重新插入这个 <code>member</code> 元素，来保证该 <code>member</code> 在正确的位置上。</li>
<li><code>score</code> 值可以是整数值或双精度浮点数。</li>
</ul>
<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># apple 8，banana 2，orange 3</span><br><span class="line">127.0.0.1:6379&gt; ZADD k1 8 apple 2 banana 3 orange</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>
<h3 id="2-3-ZRANGE-amp-ZRANGEBYSCORE-amp-ZREVRANGE"><a href="#2-3-ZRANGE-amp-ZRANGEBYSCORE-amp-ZREVRANGE" class="headerlink" title="2.3 ZRANGE&amp;ZRANGEBYSCORE&amp;ZREVRANGE"></a>2.3 ZRANGE&amp;ZRANGEBYSCORE&amp;ZREVRANGE</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help zrange</span><br><span class="line"></span><br><span class="line">  ZRANGE key start stop [WITHSCORES]</span><br><span class="line">  summary: Return a range of members in a sorted set, by index</span><br><span class="line">  since: 1.2.0</span><br><span class="line">  group: sorted_set</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help zrangebyscore</span><br><span class="line"></span><br><span class="line">  ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br><span class="line">  summary: Return a range of members in a sorted set, by score</span><br><span class="line">  since: 1.0.5</span><br><span class="line">  group: sorted_set</span><br></pre></td></tr></table></figure>
<p><strong>取值相关命令</strong></p>
<p>ZRANGE：返回有序集 <code>key</code> 中，指定区间内的成员。</p>
<ul>
<li>其中成员的位置按 <code>score</code> 值递增(从小到大)来排序。</li>
<li>具有相同 <code>score</code> 值的成员按字典序来排列。</li>
<li>可以通过使用 <code>WITHSCORES</code> 选项，来让成员和它的 <code>score</code> 值一并返回，返回列表以 <code>value1,score1, ..., valueN,scoreN</code> 的格式表示。</li>
</ul>
<p>ZRANGEBYSCORE：返回有序集 <code>key</code> 中，所有 <code>score</code> 值介于 <code>min</code> 和 <code>max</code> 之间(包括等于 <code>min</code> 或 <code>max</code> )的成员。有序集成员按 <code>score</code> 值递增(从小到大)次序排列。</p>
<ul>
<li>具有相同 <code>score</code> 值的成员按字典序来排列(该属性是有序集提供的，不需要额外的计算)。</li>
<li>可选的 <code>WITHSCORES</code> 参数决定结果集是单单返回有序集的成员，还是将有序集成员及其 <code>score</code> 值一起返回。</li>
</ul>
<p>ZREVRANGE：ZREVRANGE返回有序集 <code>key</code> 中，指定区间内的成员。</p>
<ul>
<li>其中成员的位置按 <code>score</code> 值递减(从大到小)来排列。</li>
<li>具有相同 <code>score</code> 值的成员按字典序的逆序EVRANGE 命令的其他方面和 ZRANGE 命令一样。</li>
</ul>
<p>ZREVRANGEBYSCORE：返回有序集 <code>key</code> 中， <code>score</code> 值介于 <code>max</code> 和 <code>min</code> 之间(默认包括等于 <code>max</code> 或 <code>min</code> )的所有的成员。有序集成员按 <code>score</code> 值递减(从大到小)的次序排列。</p>
<ul>
<li>具有相同 <code>score</code> 值的成员按字典序的逆序排列。</li>
<li>除了成员按 <code>score</code> 值递减的次序排列这一点外，ZREVRANGEBYSCORE 命令的其他方面和ZRANGEBYSCORE命令一样。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ZRANGE 按照 score 正序排列</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE k1 0 -1</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;orange&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line"># 使用 WITHSCORES，成员和 score 一起返回</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE k1 0 -1 withscores</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;orange&quot;</span><br><span class="line">4) &quot;3&quot;</span><br><span class="line">5) &quot;apple&quot;</span><br><span class="line">6) &quot;8&quot;</span><br><span class="line"># 使用下标</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE k1 -2 -1</span><br><span class="line">1) &quot;orange&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line"></span><br><span class="line"># 返回score 3~8区间的值</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE k1 3 8</span><br><span class="line">1) &quot;orange&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line"></span><br><span class="line"># ZRANGE 按照 score 逆序排列</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE k1 0 1</span><br><span class="line">1) &quot;apple&quot;</span><br><span class="line">2) &quot;orange&quot;</span><br><span class="line"># ZREVRANGEBYSCORE 逆序排列</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGEBYSCORE k1 8 3</span><br><span class="line">1) &quot;apple&quot;</span><br><span class="line">2) &quot;orange&quot;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-ZSCORE"><a href="#2-4-ZSCORE" class="headerlink" title="2.4 ZSCORE"></a>2.4 ZSCORE</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help zscore</span><br><span class="line"></span><br><span class="line">  ZSCORE key member</span><br><span class="line">  summary: Get the score associated with the given member in a sorted set</span><br><span class="line">  since: 1.2.0</span><br><span class="line">  group: sorted_set</span><br></pre></td></tr></table></figure>
<p>ZSCORE：返回有序集 <code>key</code> 中，成员 <code>member</code> 的 <code>score</code> 值。</p>
<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZSCORE k1 apple</span><br><span class="line">&quot;8&quot;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-ZRANK-amp-ZREVRANK"><a href="#2-5-ZRANK-amp-ZREVRANK" class="headerlink" title="2.5 ZRANK&amp;ZREVRANK"></a>2.5 ZRANK&amp;ZREVRANK</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help zrank</span><br><span class="line"></span><br><span class="line">  ZRANK key member</span><br><span class="line">  summary: Determine the index of a member in a sorted set</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: sorted_set</span><br></pre></td></tr></table></figure>
<p>ZRANK：返回有序集 <code>key</code> 中成员 <code>member</code> 的排名。其中有序集成员按 <code>score</code> 值递增(从小到大)顺序排列。</p>
<p>ZREVRANK：返回有序集 <code>key</code> 中成员 <code>member</code> 的排名。其中有序集成员按 <code>score</code> 值递减(从大到小)排序。</p>
<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZRANK k1 apple</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>
<h3 id="2-6-ZINCRBY"><a href="#2-6-ZINCRBY" class="headerlink" title="2.6 ZINCRBY"></a>2.6 ZINCRBY</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help zincrby</span><br><span class="line"></span><br><span class="line">  ZINCRBY key increment member</span><br><span class="line">  summary: Increment the score of a member in a sorted set</span><br><span class="line">  since: 1.2.0</span><br><span class="line">  group: sorted_set</span><br></pre></td></tr></table></figure>
<p>ZINCRBY：为有序集 <code>key</code> 的成员 <code>member</code> 的 <code>score</code> 值加上增量 <code>increment</code> 。</p>
<ul>
<li>可以通过传递一个负数值 <code>increment</code> ，让 <code>score</code> 减去相应的值，比如 <code>ZINCRBY key -5 member</code> ，就是让 <code>member</code> 的 <code>score</code> 值减去 <code>5</code> 。</li>
</ul>
<p>算数运算</p>
<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZINCRBY k1 2.5 banana</span><br><span class="line">&quot;4.5&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE k1 0 -1 withscores</span><br><span class="line">1) &quot;orange&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;banana&quot;</span><br><span class="line">4) &quot;4.5&quot;</span><br><span class="line">5) &quot;apple&quot;</span><br><span class="line">6) &quot;8&quot;</span><br></pre></td></tr></table></figure>
<h3 id="2-7-ZUNIONSTORE-amp-ZINTERSTORE"><a href="#2-7-ZUNIONSTORE-amp-ZINTERSTORE" class="headerlink" title="2.7 ZUNIONSTORE&amp;ZINTERSTORE"></a>2.7 ZUNIONSTORE&amp;<strong>ZINTERSTORE</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help zunionstore</span><br><span class="line"></span><br><span class="line">  ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]</span><br><span class="line">  summary: Add multiple sorted sets and store the resulting sorted set in a new key</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: sorted_set</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help zinterstore</span><br><span class="line"></span><br><span class="line">  ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]</span><br><span class="line">  summary: Intersect multiple sorted sets and store the resulting sorted set in a new key</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: sorted_set</span><br></pre></td></tr></table></figure>
<p>ZUNIONSTORE：计算给定的一个或多个有序集的并集，其中给定 <code>key</code> 的数量必须以 <code>numkeys</code> 参数指定，并将该并集(结果集)储存到 <code>destination</code> 。</p>
<ul>
<li><p>默认情况下，结果集中某个成员的 <code>score</code> 值是所有给定集下该成员 <code>score</code> 值之和 。</p>
</li>
<li><p><strong>WEIGHTS</strong></p>
<p>使用 <code>WEIGHTS</code> 选项，你可以为 <em>每个</em> 给定有序集 <em>分别</em> 指定一个乘法因子(multiplication factor)，每个给定有序集的所有成员的 <code>score</code> 值在传递给聚合函数(aggregation function)之前都要先乘以该有序集的因子。</p>
<p>如果没有指定 <code>WEIGHTS</code> 选项，乘法因子默认设置为 <code>1</code> 。</p>
</li>
<li><p><strong>AGGREGATE</strong></p>
<p>使用 <code>AGGREGATE</code> 选项，你可以指定并集的结果集的聚合方式。</p>
<p>默认使用的参数 <code>SUM</code> ，可以将所有集合中某个成员的 <code>score</code> 值之 <em>和</em> 作为结果集中该成员的 <code>score</code> 值；使用参数 <code>MIN</code> ，可以将所有集合中某个成员的 <em>最小</em> <code>score</code> 值作为结果集中该成员的 <code>score</code> 值；而参数 <code>MAX</code> 则是将所有集合中某个成员的最大 <code>score</code> 值作为结果集中该成员的 <code>score</code> 值。</p>
</li>
</ul>
<p>ZINTERSTORE ：计算给定的一个或多个有序集的交集，其中给定 <code>key</code> 的数量必须以 <code>numkeys</code> 参数指定，并将该交集(结果集)储存到 <code>destination</code> 。</p>
<ul>
<li>默认情况下，结果集中某个成员的 <code>score</code> 值是所有给定集下该成员 <code>score</code> 值之和.</li>
</ul>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设有两个学科的考试分数</span></span><br><span class="line"><span class="comment"># 第一科分数</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZADD k1 <span class="number">80</span> tom <span class="number">60</span> sean <span class="number">70</span> baby</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="comment"># 第二科分数</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZADD k2 <span class="number">60</span> tom <span class="number">100</span> sean <span class="number">40</span> peter</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="comment"># numkeys为2，k1和k2进行整合</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZUNIONSTORE unkey <span class="number">2</span> k1 k2</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="comment"># 查看整合后的分值,默认SUM相加，正序排列</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZRANGE unkey <span class="number">0</span> <span class="literal">-1</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;peter&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;40&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;baby&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;70&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;tom&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;140&quot;</span></span><br><span class="line"><span class="number">7</span>) <span class="string">&quot;sean&quot;</span></span><br><span class="line"><span class="number">8</span>) <span class="string">&quot;160&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试权重，k1权重为1，k2权重为0.5</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZUNIONSTORE unkey1 <span class="number">2</span> k1 k2 WEIGHTS <span class="number">1</span> <span class="number">0.5</span></span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="comment"># 例如sean分数：60+100*0.5=110</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZRANGE unkey1 <span class="number">0</span> <span class="literal">-1</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;peter&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;baby&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;70&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;sean&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;110&quot;</span></span><br><span class="line"><span class="number">7</span>) <span class="string">&quot;tom&quot;</span></span><br><span class="line"><span class="number">8</span>) <span class="string">&quot;110&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试聚合，使用max</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZUNIONSTORE unkey2 <span class="number">2</span> k1 k2 aggregate max</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="comment"># 返回k1、k2分数最大值</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZRANGE unkey2 <span class="number">0</span> <span class="literal">-1</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;peter&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;40&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;baby&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;70&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;tom&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;80&quot;</span></span><br><span class="line"><span class="number">7</span>) <span class="string">&quot;sean&quot;</span></span><br><span class="line"><span class="number">8</span>) <span class="string">&quot;100&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 并集测试，不存在的值直接删掉</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZINTERSTORE interkey <span class="number">2</span> k1 k2</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZRANGE interkey <span class="number">0</span> <span class="literal">-1</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;tom&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;140&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;sean&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;160&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Sorted-Sets使用场景"><a href="#3-Sorted-Sets使用场景" class="headerlink" title="3 Sorted Sets使用场景"></a>3 Sorted Sets使用场景</h2><p>歌曲排行榜前十名</p>
<p>歌曲排行榜，第一天上线，所有的歌曲得分值都是0，排行榜按什么排名？可能是播放量、下载数、点播量其中一个，是正序还是倒序的？</p>
<p>可以使用Redis的ZINCYBY，某一首歌播放了一次，就加1，也可以非常快的使用ZRANGE&amp;ZREVRANGE正序或倒序排序。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 序列化器</title>
    <url>/2020/12/26/Redis-%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/</url>
    <content><![CDATA[<h1 id="Redis-序列化器"><a href="#Redis-序列化器" class="headerlink" title="Redis 序列化器"></a>Redis 序列化器</h1><a id="more"></a>

<p>从框架的角度来看，Redis 中存储的数据仅为字节。尽管 Redis 本身支持各种类型，但在大多数情况下，它们是指数据的存储方式，而不是其表示的内容。是否将信息转换为字符串或其他对象由用户自己决定。</p>
<p>Spring Data 中，Redis 可以通过<code>org.springframework.data.redis.serializer</code> 包处理用户（自定义）类型和原始数据之间的转换（反之亦然）。</p>
<p>该软件包包含两种类型的序列化器，顾名思义，它们负责序列化过程：</p>
<ul>
<li>基于的两路串行器的<code>RedisSerializer</code>。</li>
<li>使用 <code>RedisElementReader</code> 和 <code>RedisElementWriter</code> 的元素读取器和元素写入器。</li>
</ul>
<p>两者之间的主要区别在于，<code>RedisSerializer</code> 序列化为 <code>byte[]</code>，而 readers 和 writers 序列化为<code>ByteBuffer</code>。</p>
<p>接口的截图：</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201226225711767.png" alt="image-20201226225711767"></p>
<p>Spring Data Redis 的序列化器提供了多种实现方式：</p>
<ul>
<li>GenericToStringSerializer：使用 Spring 转换服务进行序列化。</li>
<li>GenericJackson2JsonRedisSerializer：将对象序列化为 Json</li>
<li>Jackson2JsonRedisSerializer：使用 Jackson2，将对象序列化为 Json。</li>
<li>JdkSerializationRedisSerializer：使用 Java 序列化，<code>RedisCache</code> 和 <code>RedisTemplate</code> 默认使用此方式。</li>
<li>OxmSerializer：使用 Spring O/X 映射的编排器和解排器实现序列化，用于 XML 序列化。</li>
<li>StringRedisSerializer：序列化 String 类型的 key 和 value。</li>
</ul>
<p>存储格式不仅限于 values，也可以无限制地用于 keys, values 或者 hashes。</p>
<h2 id="1-默认序列化器"><a href="#1-默认序列化器" class="headerlink" title="1 默认序列化器"></a>1 默认序列化器</h2><p> <code>RedisTemplate</code> 默认使用 <code>JdkSerializationRedisSerializer</code>，<code>StringRedisTemplate </code> 默认使用 <code>StringRedisSerializer</code></p>
<h2 id="2-自定义序列化器"><a href="#2-自定义序列化器" class="headerlink" title="2 自定义序列化器"></a>2 自定义序列化器</h2><p>如果在实际项目中上述序列化器中没有符合需求的序列化器，或者不使用默认的序列化器，那么可以自定义序列化器。</p>
<p>例如，使用  <code>RedisTemplate</code>  时，希望 key 是 String 类型，而 value 是 自定义的 Person 类且序列化为 JSON，就可以自定义 key 和 value 的序列化器。</p>
<p>配置代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Person&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory cf)</span></span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Person&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(cf);</span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        redisTemplate.setValueSerializer(<span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(Person.class));</span><br><span class="line">        <span class="keyword">return</span>  redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 持久化</title>
    <url>/2020/12/27/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h1><a id="more"></a>

<p>以下文档来自于Redis中文官网：<a href="http://redis.cn/topics/persistence.html">http://redis.cn/topics/persistence.html</a></p>
<h2 id="1-Redis持久化方式"><a href="#1-Redis持久化方式" class="headerlink" title="1 Redis持久化方式"></a>1 Redis持久化方式</h2><p>Redis是内存的数据库，掉电易失，所以需要数据需要持久化。</p>
<p>Redis提供了不同级别的持久化方式：</p>
<ul>
<li>RDB：在指定的时间间隔能对你的数据进行快照存储。</li>
<li>AOF：记录每次对服务器的写操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF 命令以 Redis 协议追加保存每次的写操作到文件的末尾，Redis 还能对 AOF 文件进行后台重写，使得 AOF 的体积不至于过大。</li>
<li>也可以同时开启两种持久化方式，在这种情况下，当 Redis 重启的时候会有限载入 AOF 文件来恢复原始的数据，因为通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整</li>
</ul>
<h2 id="2-RDB（Redis-DataBase）"><a href="#2-RDB（Redis-DataBase）" class="headerlink" title="2 RDB（Redis DataBase）"></a>2 RDB（Redis DataBase）</h2><h3 id="2-1-RDB-优点"><a href="#2-1-RDB-优点" class="headerlink" title="2.1 RDB 优点"></a>2.1 RDB 优点</h3><ul>
<li>RDB 是一个非常紧凑的文件，它保存了某个时间点的数据集，非常适用于数据集的备份，比如可以在每个小时保存一下过去 24 小时内的数据，同时每天保存过去 30 天的数据，这样即使出了问题也可以根据需求恢复到不同版本的数据集。</li>
<li>RDB 是一个紧凑的单一文件，很方便传送到另一个远端数据中心，非常适用于灾难恢复。</li>
<li>RDB 在保存文件时父进程唯一需要做的就是 fork 出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他 IO 操作，所以 RDB 持久化方式可以最大化 Redis 性能。</li>
<li>与 AOF 相比，在恢复大的数据集的时候，RDB 方式会更快一些。</li>
</ul>
<h3 id="2-2-RDB-缺点"><a href="#2-2-RDB-缺点" class="headerlink" title="2.2 RDB 缺点"></a>2.2 RDB 缺点</h3><ul>
<li>如果你希望在 Redis 意外停止工作（例如电源中断）的情况下丢失的数据最少的话，那么 RDB 不适合你。虽然你可以配置不同的 save 时间点（例如每隔 5 分钟并且对数据集有 100 个写的操作），Redis 要完整的保存整个数据集是一个比较繁重的工作，你通常会每隔 5 分钟或者更久做一次完整的保存，万一在 Redis 意外宕机，你可能会丢失几分钟的数据。</li>
<li>RDB 需要经常 fork 子进程来保存数据集到硬盘上，当数据集比较大的时候，fork 的过程是非常耗时的，可能会导致 Redis 在一些毫秒级内不能响应客户端的请求。如果数据集巨大并且 CPU 性能不是很好的情况下，这种情况会持续 1 秒，AOF 也需要 fork，但是你可以调节重写日志文件的频率来提高数据集的耐久度。</li>
</ul>
<p>总结：</p>
<ul>
<li>不支持拉链，只会有一个 dump.rdb。</li>
<li>容易丢失数据，时点与时点之间的窗口数据容易丢失。</li>
</ul>
<h3 id="2-3-RDB-工作原理"><a href="#2-3-RDB-工作原理" class="headerlink" title="2.3 RDB 工作原理"></a>2.3 RDB 工作原理</h3><p>当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作:</p>
<ul>
<li>Redis 调用 forks。同时拥有父进程和子进程。</li>
<li>子进程将数据集写入到一个临时 RDB 文件中。</li>
<li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</li>
</ul>
<p>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益。</p>
<h3 id="2-4-RDB配置方式"><a href="#2-4-RDB配置方式" class="headerlink" title="2.4 RDB配置方式"></a>2.4 RDB配置方式</h3><ol>
<li><p>手动 <code>SAVE</code>：适合关机维护时使用</p>
</li>
<li><p>手动 <code>BGSAVE</code>：fork()，创建子进程</p>
</li>
<li><p>配置文件方式 <code>BGSAVE</code> 规则：注意，使用 save 标识，触发 bsave</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">################################ SNAPSHOTTING  ################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Save the DB on disk:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   save &lt;seconds&gt; &lt;changes&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   Will save the DB if both the given number of seconds and the given</span></span><br><span class="line"><span class="comment">#   number of write operations against the DB occurred.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   In the example below the behaviour will be to save:</span></span><br><span class="line"><span class="comment">#   after 900 sec (15 min) if at least 1 key changed</span></span><br><span class="line"><span class="comment">#   after 300 sec (5 min) if at least 10 keys changed</span></span><br><span class="line"><span class="comment">#   after 60 sec if at least 10000 keys changed</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   <span class="doctag">Note:</span> you can disable saving completely by commenting out all &quot;save&quot; lines.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   It is also possible to remove all the previously configured save</span></span><br><span class="line"><span class="comment">#   points by adding a save directive with a single empty string argument</span></span><br><span class="line"><span class="comment">#   like in the following example:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   save &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">save</span> <span class="string">900 1</span></span><br><span class="line"><span class="attr">save</span> <span class="string">300 10</span></span><br><span class="line"><span class="attr">save</span> <span class="string">60 10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># By default Redis will stop accepting writes if RDB snapshots are enabled</span></span><br><span class="line"><span class="comment"># (at least one save point) and the latest background save failed.</span></span><br><span class="line"><span class="comment"># This will make the user aware (in a hard way) that data is not persisting</span></span><br><span class="line"><span class="comment"># on disk properly, otherwise chances are that no one will notice and some</span></span><br><span class="line"><span class="comment"># disaster will happen.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If the background saving process will start working again Redis will</span></span><br><span class="line"><span class="comment"># automatically allow writes again.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># However if you have setup your proper monitoring of the Redis server</span></span><br><span class="line"><span class="comment"># and persistence, you may want to disable this feature so that Redis will</span></span><br><span class="line"><span class="comment"># continue to work as usual even if there are problems with disk,</span></span><br><span class="line"><span class="comment"># permissions, and so forth.</span></span><br><span class="line"><span class="meta">stop-writes-on-bgsave-error</span> <span class="string">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Compress string objects using LZF when dump .rdb databases?</span></span><br><span class="line"><span class="comment"># For default that&#x27;s set to &#x27;yes&#x27; as it&#x27;s almost always a win.</span></span><br><span class="line"><span class="comment"># If you want to save some CPU in the saving child set it to &#x27;no&#x27; but</span></span><br><span class="line"><span class="comment"># the dataset will likely be bigger if you have compressible values or keys.</span></span><br><span class="line"><span class="attr">rdbcompression</span> <span class="string">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Since version 5 of RDB a CRC64 checksum is placed at the end of the file.</span></span><br><span class="line"><span class="comment"># This makes the format more resistant to corruption but there is a performance</span></span><br><span class="line"><span class="comment"># hit to pay (around 10%) when saving and loading RDB files, so you can disable it</span></span><br><span class="line"><span class="comment"># for maximum performances.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># RDB files created with checksum disabled have a checksum of zero that will</span></span><br><span class="line"><span class="comment"># tell the loading code to skip the check.</span></span><br><span class="line"><span class="attr">rdbchecksum</span> <span class="string">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The filename where to dump the DB</span></span><br><span class="line"><span class="attr">dbfilename</span> <span class="string">dump.rdb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The working directory.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The DB will be written inside this directory, with the filename specified</span></span><br><span class="line"><span class="comment"># above using the &#x27;dbfilename&#x27; configuration directive.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The Append Only File will also be created inside this directory.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that you must specify a directory here, not a file name.</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">./</span></span><br><span class="line"><span class="attr">----------------------------------------------------------------------------------</span></span><br><span class="line"><span class="attr">save</span> <span class="string">900 1</span></span><br><span class="line"><span class="attr">save</span> <span class="string">300 10</span></span><br><span class="line"><span class="attr">save</span> <span class="string">60 10000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dbfilename</span> <span class="string">dump.rdb</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">/var/lib/redis/6379 </span></span><br></pre></td></tr></table></figure>
<h2 id="3-AOF（Append-Only-File）"><a href="#3-AOF（Append-Only-File）" class="headerlink" title="3 AOF（Append Only File）"></a>3 AOF（Append Only File）</h2></li>
</ol>
<h4 id="3-1-AOF-优点"><a href="#3-1-AOF-优点" class="headerlink" title="3.1 AOF 优点"></a>3.1 AOF 优点</h4><ul>
<li><p>使用AOF会让Redis更加耐久：你可以使用不同的fsync策略；无fsync，每秒fsync，每次写的时候fsync，使用默认的每秒fsync策略，Redis的性能依旧很好（fsync是由后台线程进行处理的，主线程会尽力处理客户端请求），一旦出现故障，你最多丢失1秒的数据</p>
</li>
<li><p>AOF 文件是一个只进行追加的日志文件，所以不需要写入 seek，即使由于某些原因（磁盘空间已满，写的过程宕机等待）未执行完整的写入命令，你可可以使用  <code>redis-check-aof</code>  工具修复这些问题。</p>
</li>
<li><p>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写：重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。整个重写操作时绝对安全的，因为 Redis 在创建 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</p>
<ul>
<li>AOF 文件有序地保存了对数据库执行的所有写入操作，这些写入操作以 Redis 协议的格式保存，因此 AOF 文件的内容非常容易被人读懂，对文件进行分析（parse）也很轻松。导出（export）AOF 文件也非常简单：举个例子，如果你不小心执行了 FLUSHALL 命令，但只要 AOF 文件未被重写，那么只要停止服务器，移除 AOF 文件末尾的 FLUSHALL 命令，并重启 Redis，就可以将数据集恢复到 FLUSHALL 执行之前的状态。</li>
</ul>
</li>
</ul>
<h4 id="3-2-AOF-缺点"><a href="#3-2-AOF-缺点" class="headerlink" title="3.2 AOF 缺点"></a>3.2 AOF 缺点</h4><ul>
<li>相同的数据集，AOF 的体积通常要大于 RDB 文件的体积.</li>
<li>根据所使用的 fsync 策略，AOF 的速度可能慢于 RDB。在一般情况下，每秒的 fsync 的性能依旧非常高，而关闭 fsync 可以让 AOF 的速度和 RDB 一样快，即使在高负荷之下也是如此。不过在处理巨大的写入载入时，RDB可以提供更有保证的最大延迟时间（latency）。</li>
</ul>
<h4 id="3-3-AOF-工作原理"><a href="#3-3-AOF-工作原理" class="headerlink" title="3.3 AOF 工作原理"></a>3.3 AOF 工作原理</h4><p>AOF 重写和 RDB 创建快照一样，都巧妙的利用了写时复制机制：</p>
<ul>
<li>Redis 执行 fork()，现在同时拥有父进程和子进程。</li>
<li>子进程开始将新的 AOF 文件的内容写入到临时文件。</li>
<li>对于所有新执行的写入命令，父进程一边将他们累积到一个内存缓存中，一边将这些改动追加到现有的 AOF 文件的末尾</li>
</ul>
<h4 id="3-4-持久化使用方式"><a href="#3-4-持久化使用方式" class="headerlink" title="3.4 持久化使用方式"></a>3.4 持久化使用方式</h4><p>Redis 配置文件 <code>APPEND ONLY MODE</code> 部分介绍了 AOF 的配置</p>
  <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是否开启AOF，默认关闭（no）</span></span><br><span class="line"><span class="attr">appendonly</span> <span class="string">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 AOF 文件名</span></span><br><span class="line"><span class="attr">appendfilename</span> <span class="string">appendonly.aof</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis支持三种不同的刷写模式：</span></span><br><span class="line"><span class="comment"># appendfsync always #每次收到写命令就立即强制写入磁盘，是最有保证的完全的持久化，但速度也是最慢的，一般不推荐使用。</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">everysec #每秒钟强制写入磁盘一次，在性能和持久化方面做了很好的折中，是受推荐的方式。</span></span><br><span class="line"><span class="comment"># appendfsync no     #完全依赖OS的写入，一般为30秒左右一次，性能最好但是持久化最没有保证，不被推荐。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在日志重写时，不进行命令追加操作，而只是将其放在缓冲区里，避免与命令的追加造成DISK IO上的冲突。</span></span><br><span class="line"><span class="comment">#设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入，默认为no</span></span><br><span class="line"><span class="meta">no-appendfsync-on-rewrite</span> <span class="string">no </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#当前AOF文件大小是上次日志重写得到AOF文件大小的二倍时，自动启动新的日志重写过程。</span></span><br><span class="line"><span class="meta">auto-aof-rewrite-percentage</span> <span class="string">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#当前AOF文件启动新的日志重写过程的最小值，避免刚刚启动Reids时由于文件尺寸较小导致频繁的重写。</span></span><br><span class="line"><span class="meta">auto-aof-rewrite-min-size</span> <span class="string">64mb</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Redis 缓存穿透、缓存击穿、缓存雪崩</title>
    <url>/2020/12/27/Redis-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/</url>
    <content><![CDATA[<h1 id="Redis-缓存穿透、缓存击穿、缓存雪崩"><a href="#Redis-缓存穿透、缓存击穿、缓存雪崩" class="headerlink" title="Redis 缓存穿透、缓存击穿、缓存雪崩"></a>Redis 缓存穿透、缓存击穿、缓存雪崩</h1><a id="more"></a>

<h2 id="1-Redis-缓存穿透"><a href="#1-Redis-缓存穿透" class="headerlink" title="1 Redis 缓存穿透"></a>1 Redis 缓存穿透</h2><h3 id="1-1-什么是缓存穿透？"><a href="#1-1-什么是缓存穿透？" class="headerlink" title="1.1 什么是缓存穿透？"></a>1.1 什么是缓存穿透？</h3><p>缓存穿透是指在高并发场景下并使用 Redis 作为缓存的时候，查询一个 DB 不存在的数据。</p>
<h3 id="1-2-缓存穿透解决方案"><a href="#1-2-缓存穿透解决方案" class="headerlink" title="1.2 缓存穿透解决方案"></a>1.2 缓存穿透解决方案</h3><h4 id="1-2-1-布隆过滤器"><a href="#1-2-1-布隆过滤器" class="headerlink" title="1.2.1 布隆过滤器"></a>1.2.1 布隆过滤器</h4><p>将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。</p>
<h2 id="2-Redis-缓存击穿"><a href="#2-Redis-缓存击穿" class="headerlink" title="2 Redis 缓存击穿"></a>2 Redis 缓存击穿</h2><h3 id="2-1-什么是缓存击穿？"><a href="#2-1-什么是缓存击穿？" class="headerlink" title="2.1 什么是缓存击穿？"></a>2.1 什么是缓存击穿？</h3><p>缓存击穿是指在高并发场景下并使用 Redis 作为缓存的时候，由于 Redis 会清除过期的 key，某个 key 不存在造成所有的并发都访问到数据库，大量的请求可能会瞬间把后端 DB 压垮。</p>
<h3 id="2-2-缓存击穿解决方案"><a href="#2-2-缓存击穿解决方案" class="headerlink" title="2.2 缓存击穿解决方案"></a>2.2 缓存击穿解决方案</h3><h4 id="2-2-1-设置永不过期"><a href="#2-2-1-设置永不过期" class="headerlink" title="2.2.1 设置永不过期"></a>2.2.1 设置永不过期</h4><p>最简单的方法，key 设置不过期就不会产生此问题</p>
<h4 id="2-2-2-使用互斥锁"><a href="#2-2-2-使用互斥锁" class="headerlink" title="2.2.2 使用互斥锁"></a>2.2.2 使用互斥锁</h4><p>使用 Redis 的 <code>SETNX</code>，只有抢到锁的才会去 DB 加载数据，没有抢到锁的等待一段时间。</p>
<h2 id="3-Redis-缓存雪崩"><a href="#3-Redis-缓存雪崩" class="headerlink" title="3 Redis 缓存雪崩"></a>3 Redis 缓存雪崩</h2><h3 id="3-1-什么是缓存雪崩？"><a href="#3-1-什么是缓存雪崩？" class="headerlink" title="3.1 什么是缓存雪崩？"></a>3.1 什么是缓存雪崩？</h3><p>缓存雪崩是指在高并发场景下并使用 Redis 作为缓存的时候，大量的 key 同时失效间接造成大量的请求访问到达 DB。</p>
<h3 id="3-2-缓存雪崩解决方案"><a href="#3-2-缓存雪崩解决方案" class="headerlink" title="3.2  缓存雪崩解决方案"></a>3.2  缓存雪崩解决方案</h3><h4 id="3-2-1-随机过期时间"><a href="#3-2-1-随机过期时间" class="headerlink" title="3.2.1 随机过期时间"></a>3.2.1 随机过期时间</h4><p>如果 Redis 中的数据与时点性无关，可以设置 key 随机过期时间，让缓存失效的时间点尽量均匀。</p>
<h3 id="3-2-2-互斥锁"><a href="#3-2-2-互斥锁" class="headerlink" title="3.2.2 互斥锁"></a>3.2.2 互斥锁</h3><p>如果 Redis 中的数据具有时点性，假设到 0:00 大量的 key 过期，可以对 key 加互斥锁，与缓存击穿类似。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Redis 缓存穿透</tag>
        <tag>Redis 缓存击穿</tag>
        <tag>Redis 缓存雪崩</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot 线程池（一）：使用同步线程池</title>
    <url>/2020/12/21/SpringBoot-%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%90%8C%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="SpringBoot-线程池（一）：使用同步线程池"><a href="#SpringBoot-线程池（一）：使用同步线程池" class="headerlink" title="SpringBoot 线程池（一）：使用同步线程池"></a>SpringBoot 线程池（一）：使用同步线程池</h1><a id="more"></a>
<h2 id="1-创建任务"><a href="#1-创建任务" class="headerlink" title="1 创建任务"></a>1 创建任务</h2><h3 id="1-1-创建同步任务类-SyncTask"><a href="#1-1-创建同步任务类-SyncTask" class="headerlink" title="1.1 创建同步任务类 SyncTask"></a>1.1 创建同步任务类 SyncTask</h3><p>创建同步任务类 <code>SyncTask</code>，添加 <code>@Component</code> 注释</p>
<h3 id="1-2-创建需要执行的任务"><a href="#1-2-创建需要执行的任务" class="headerlink" title="1.2 创建需要执行的任务"></a>1.2 创建需要执行的任务</h3><p>为了测试方便，只打印一行信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：sync execute task...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-创建线程池、任务执行调用方法"><a href="#1-3-创建线程池、任务执行调用方法" class="headerlink" title="1.3 创建线程池、任务执行调用方法"></a>1.3 创建线程池、任务执行调用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 同步任务线程池 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">20</span>, <span class="number">60L</span>,</span><br><span class="line">	TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">50</span>),</span><br><span class="line">	<span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">&quot;sync-task-thread-pool-%d&quot;</span>).build());</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提交任务给线程池</span></span><br><span class="line">    executorService.submit(<span class="keyword">this</span>::sync);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-SyncTask-类完整代码"><a href="#1-4-SyncTask-类完整代码" class="headerlink" title="1.4 SyncTask 类完整代码"></a>1.4 SyncTask 类完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 同步任务线程池 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">20</span>, <span class="number">60L</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">50</span>),</span><br><span class="line">            <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">&quot;sync-task-thread-pool-%d&quot;</span>).build());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：sync execute task...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 提交任务给线程池</span></span><br><span class="line">        executorService.submit(<span class="keyword">this</span>::sync);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-创建单元测试进行测试"><a href="#2-创建单元测试进行测试" class="headerlink" title="2 创建单元测试进行测试"></a>2 创建单元测试进行测试</h2><p>本次使用 <code>JUnit5</code> 进行测试，完整代码如下：</p>
<h3 id="2-1-不使用线程池"><a href="#2-1-不使用线程池" class="headerlink" title="2.1 不使用线程池"></a>2.1 不使用线程池</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudyApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	SyncTask syncTask;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncWithoutThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;start execute task...&quot;</span>);</span><br><span class="line">		<span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">			syncTask.sync();</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;total time：&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印日志结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start execute task...</span><br><span class="line">main：sync execute task...</span><br><span class="line">main：sync execute task...</span><br><span class="line">main：sync execute task...</span><br><span class="line">main：sync execute task...</span><br><span class="line">main：sync execute task...</span><br><span class="line">main：sync execute task...</span><br><span class="line">main：sync execute task...</span><br><span class="line">main：sync execute task...</span><br><span class="line">main：sync execute task...</span><br><span class="line">main：sync execute task...</span><br><span class="line">total time：10117</span><br></pre></td></tr></table></figure>
<h3 id="2-2-使用线程池"><a href="#2-2-使用线程池" class="headerlink" title="2.2 使用线程池"></a>2.2 使用线程池</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudyApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	SyncTask syncTask;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncWithThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;start execute task...&quot;</span>);</span><br><span class="line">		<span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">			syncTask.execute();</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;total time：&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印日志结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start execute task...</span><br><span class="line">sync-task-thread-pool-0：sync execute task...</span><br><span class="line">sync-task-thread-pool-1：sync execute task...</span><br><span class="line">sync-task-thread-pool-2：sync execute task...</span><br><span class="line">sync-task-thread-pool-3：sync execute task...</span><br><span class="line">sync-task-thread-pool-4：sync execute task...</span><br><span class="line">sync-task-thread-pool-5：sync execute task...</span><br><span class="line">sync-task-thread-pool-6：sync execute task...</span><br><span class="line">sync-task-thread-pool-7：sync execute task...</span><br><span class="line">sync-task-thread-pool-8：sync execute task...</span><br><span class="line">total time：2</span><br><span class="line">sync-task-thread-pool-9：sync execute task...</span><br></pre></td></tr></table></figure>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>由上述结果可见：使用线程池执行批量任务速度要快。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot 线程池（二）：使用异步线程池</title>
    <url>/2020/12/21/SpringBoot-%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="SpringBoot-线程池（二）：使用异步线程池"><a href="#SpringBoot-线程池（二）：使用异步线程池" class="headerlink" title="SpringBoot 线程池（二）：使用异步线程池"></a>SpringBoot 线程池（二）：使用异步线程池</h1><a id="more"></a>
<h2 id="1-创建异步线程池配置"><a href="#1-创建异步线程池配置" class="headerlink" title="1 创建异步线程池配置"></a>1 创建异步线程池配置</h2><h3 id="1-1-配置线程池属性"><a href="#1-1-配置线程池属性" class="headerlink" title="1.1 配置线程池属性"></a>1.1 配置线程池属性</h3><p>在 <code>application.properties</code> 配置文件中添加异步线程池的相关属性</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 异步线程池相关属性</span></span><br><span class="line"><span class="meta">asyncThreadPool.corePoolSize</span> = <span class="string">10</span></span><br><span class="line"><span class="meta">asyncThreadPool.maxPoolSize</span> = <span class="string">20</span></span><br><span class="line"><span class="meta">asyncThreadPool.queueCapacity</span> = <span class="string">50</span></span><br><span class="line"><span class="meta">asyncThreadPool.keepAliveSeconds</span> = <span class="string">60</span></span><br><span class="line"><span class="meta">asyncThreadPool.threadNamePrefix</span> = <span class="string">async-task-thread-pool-%d</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-创建线程池配置类"><a href="#1-2-创建线程池配置类" class="headerlink" title="1.2 创建线程池配置类"></a>1.2 创建线程池配置类</h3><p>创建 <code>AsyncConfig</code> 类并添加 <code>@Configuration</code> 注释，完整配置如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步线程池配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;asyncThreadPool.corePoolSize&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;asyncThreadPool.maxPoolSize&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxPoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;asyncThreadPool.queueCapacity&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;asyncThreadPool.keepAliveSeconds&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> keepAliveSeconds;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;asyncThreadPool.threadNamePrefix&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String threadNamePrefix;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">asyncExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor threadPoolTaskExecutor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        threadPoolTaskExecutor.setCorePoolSize(corePoolSize);</span><br><span class="line">        threadPoolTaskExecutor.setMaxPoolSize(maxPoolSize);</span><br><span class="line">        threadPoolTaskExecutor.setQueueCapacity(queueCapacity);</span><br><span class="line">        threadPoolTaskExecutor.setKeepAliveSeconds(keepAliveSeconds);</span><br><span class="line">        threadPoolTaskExecutor.setThreadNamePrefix(threadNamePrefix);</span><br><span class="line">        threadPoolTaskExecutor.initialize();</span><br><span class="line">        <span class="keyword">return</span> threadPoolTaskExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-创建任务"><a href="#2-创建任务" class="headerlink" title="2 创建任务"></a>2 创建任务</h2><h3 id="2-1-创建异步任务类-SyncTask"><a href="#2-1-创建异步任务类-SyncTask" class="headerlink" title="2.1 创建异步任务类 SyncTask"></a>2.1 创建异步任务类 SyncTask</h3><p>创建同步任务类 <code>AsyncTask</code>，添加 <code>@Component</code> 注释</p>
<h3 id="2-2-创建需要执行的任务"><a href="#2-2-创建需要执行的任务" class="headerlink" title="2.2 创建需要执行的任务"></a>2.2 创建需要执行的任务</h3><p>为了测试方便，只打印一行信息，异步任务需要添加 <code>@Async</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Async(&quot;asyncExecutor&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：async execute task...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-SyncTask-类完整代码"><a href="#2-3-SyncTask-类完整代码" class="headerlink" title="2.3  SyncTask 类完整代码"></a>2.3  SyncTask 类完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async(&quot;asyncExecutor&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：async execute task...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-创建单元测试进行测试"><a href="#2-创建单元测试进行测试" class="headerlink" title="2 创建单元测试进行测试"></a>2 创建单元测试进行测试</h2><p>本次使用 <code>JUnit5</code> 进行测试，完整代码如下：</p>
<h3 id="2-1-无返回值"><a href="#2-1-无返回值" class="headerlink" title="2.1 无返回值"></a>2.1 无返回值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudyApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	AsyncTask asyncTask;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncWithThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;start execute task...&quot;</span>);</span><br><span class="line">		<span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 无返回值</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">			asyncTask.execute();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;total time：&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印日志结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start execute task...</span><br><span class="line">total time：5</span><br><span class="line">async-task-thread-pool-1：async execute task...</span><br><span class="line">async-task-thread-pool-10：async execute task...</span><br><span class="line">async-task-thread-pool-8：async execute task...</span><br><span class="line">async-task-thread-pool-6：async execute task...</span><br><span class="line">async-task-thread-pool-5：async execute task...</span><br><span class="line">async-task-thread-pool-7：async execute task...</span><br><span class="line">async-task-thread-pool-4：async execute task...</span><br><span class="line">async-task-thread-pool-9：async execute task...</span><br><span class="line">async-task-thread-pool-3：async execute task...</span><br><span class="line">async-task-thread-pool-2：async execute task...</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>亿级流量网站架构 设计原则</title>
    <url>/2021/01/01/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><a id="more"></a>

<h2 id="1-高并发设计原则"><a href="#1-高并发设计原则" class="headerlink" title="1 高并发设计原则"></a>1 高并发设计原则</h2><h3 id="1-1-无状态"><a href="#1-1-无状态" class="headerlink" title="1.1 无状态"></a>1.1 无状态</h3><p>无状态容易进行水平扩展。</p>
<p>实际生产环境：应用无状态+配置文件有状态</p>
<h3 id="1-2-拆分"><a href="#1-2-拆分" class="headerlink" title="1.2 拆分"></a>1.2 拆分</h3><p>系统拆分几种情况：</p>
<ul>
<li>系统维度：系统功能、业务拆分，比如商品系统、购物陈、结算、订单系统等。</li>
<li>功能维度：对一个系统进行功能再拆分，比如，优惠券系统可以拆分为后台券创建系统、领券系统、用券系统。</li>
<li>读写维度：读量大，使用缓存提升性能；写量大，分库分表。</li>
<li>AOP 维度：比如，商品详情页可以分为 CDN、页面渲染系统。</li>
<li>模块维度：代码（Web、Service、Dao）</li>
</ul>
<h3 id="1-3-服务化"><a href="#1-3-服务化" class="headerlink" title="1.3 服务化"></a>1.3 服务化</h3><p>总结为如下流程：</p>
<p>进程内服务 -&gt; 单机远程服务 -&gt; 集群手动注册服务 -&gt; 自动注册服务和发现服务 -&gt; 服务的分组/隔离/路由 -&gt; 服务治理如限流/黑白名单</p>
<h3 id="1-4-消息队列"><a href="#1-4-消息队列" class="headerlink" title="1.4 消息队列"></a>1.4 消息队列</h3><p>服务解耦（一对多）消费、异步处理、流量削峰/缓冲等。</p>
<h4 id="1-4-1-大流量缓冲"><a href="#1-4-1-大流量缓冲" class="headerlink" title="1.4.1 大流量缓冲"></a>1.4.1 大流量缓冲</h4><p>牺牲强一致性，保证最终一致性</p>
<h4 id="1-4-2-数据校对"><a href="#1-4-2-数据校对" class="headerlink" title="1.4.2 数据校对"></a>1.4.2 数据校对</h4><p>消息异步机制场景下，可能存在消息的丢失，需要考虑进行数据校对和修正数据来保证一致性和完整性。</p>
<h3 id="1-5-数据异构"><a href="#1-5-数据异构" class="headerlink" title="1.5 数据异构"></a>1.5 数据异构</h3><h4 id="1-5-1-数据异构"><a href="#1-5-1-数据异构" class="headerlink" title="1.5.1 数据异构"></a>1.5.1 数据异构</h4><h4 id="1-5-2-数据闭环"><a href="#1-5-2-数据闭环" class="headerlink" title="1.5.2 数据闭环"></a>1.5.2 数据闭环</h4><h3 id="1-6-缓存银弹"><a href="#1-6-缓存银弹" class="headerlink" title="1.6 缓存银弹"></a>1.6 缓存银弹</h3><table>
<thead>
<tr>
<th>流程节点</th>
<th>缓存技术</th>
</tr>
</thead>
<tbody><tr>
<td>客户端</td>
<td>使用浏览器缓存</td>
</tr>
<tr>
<td></td>
<td>客户端缓存</td>
</tr>
<tr>
<td>客户端网络</td>
<td>代理服务器开启缓存</td>
</tr>
<tr>
<td>广域网</td>
<td>使用代理服务器（含 CDN）</td>
</tr>
<tr>
<td></td>
<td>使用镜像服务器</td>
</tr>
<tr>
<td></td>
<td>使用 P2P 技术</td>
</tr>
<tr>
<td>源站及源站网络</td>
<td>使用接入层提供的缓存机制</td>
</tr>
<tr>
<td></td>
<td>使用应用层提供的缓存机制</td>
</tr>
<tr>
<td></td>
<td>使用分布式缓存</td>
</tr>
<tr>
<td></td>
<td>静态化、伪静态化</td>
</tr>
<tr>
<td></td>
<td>使用服务器操作系统提供的缓存机制</td>
</tr>
</tbody></table>
<h4 id="1-6-1-浏览器端缓存"><a href="#1-6-1-浏览器端缓存" class="headerlink" title="1.6.1 浏览器端缓存"></a>1.6.1 浏览器端缓存</h4><p>设置请求的过期时间。如对响应头 Expires、Cahce-control 进行控制。</p>
<p>适用于实时性不太敏感的数据，如商品详情页、商家评分、评价、广告词等。</p>
<h4 id="1-6-2-APP-客户端缓存"><a href="#1-6-2-APP-客户端缓存" class="headerlink" title="1.6.2 APP 客户端缓存"></a>1.6.2 APP 客户端缓存</h4><p>大促前提前下发素材到客户端缓存。</p>
<h4 id="1-6-3-CDN-缓存"><a href="#1-6-3-CDN-缓存" class="headerlink" title="1.6.3 CDN 缓存"></a>1.6.3 CDN 缓存</h4><p>有些页面、活动页、图片等服务推送到离用户最近的 CDN 节点</p>
<ul>
<li>推送机制</li>
<li>拉取机制</li>
</ul>
<h4 id="1-6-4-接入层缓存"><a href="#1-6-4-接入层缓存" class="headerlink" title="1.6.4 接入层缓存"></a>1.6.4 接入层缓存</h4><p>对于没有 CDN 缓存的应用来说，可以使用如 Nginx 搭建一层接入层。</p>
<h4 id="1-6-5-应用层缓存"><a href="#1-6-5-应用层缓存" class="headerlink" title="1.6.5 应用层缓存"></a>1.6.5 应用层缓存</h4><p>使用 Tomcat 时，可以使用堆内缓存/堆外缓存。可以使用 local redis cache 来代替对外缓存；或在接入层使用 share_dict 来将缓存前置，以减少风暴。</p>
<h4 id="1-6-6-分布式缓存"><a href="#1-6-6-分布式缓存" class="headerlink" title="1.6.6 分布式缓存"></a>1.6.6 分布式缓存</h4><p>数据量太大，Redis 单服务器存储不了，可以使用分片机制将流量分散到多台，或直接使用分布式缓存实现。</p>
<h3 id="1-7-并发化"><a href="#1-7-并发化" class="headerlink" title="1.7 并发化"></a>1.7 并发化</h3><h2 id="2-高可用原则"><a href="#2-高可用原则" class="headerlink" title="2 高可用原则"></a>2 高可用原则</h2><h3 id="2-1-降级"><a href="#2-1-降级" class="headerlink" title="2.1 降级"></a>2.1 降级</h3><p>设计降级开关</p>
<h3 id="2-2-限流"><a href="#2-2-限流" class="headerlink" title="2.2 限流"></a>2.2 限流</h3><p>限流的目的是防止恶意请求流量、恶意攻击，或者防止流量超出系统峰值。</p>
<p>思路：</p>
<ol>
<li>恶意请求流量只访问到 cache。</li>
<li>对于穿透到后端应用的流量可以考虑使用 Nginx 的 limit 模块处理。</li>
<li>对于恶意的 IP 可以使用 nginx deny 进行屏蔽。</li>
</ol>
<h3 id="2-3-切流量"><a href="#2-3-切流量" class="headerlink" title="2.3 切流量"></a>2.3 切流量</h3><h3 id="2-4-可回滚"><a href="#2-4-可回滚" class="headerlink" title="2.4 可回滚"></a>2.4 可回滚</h3><h2 id="3-业务设计原则"><a href="#3-业务设计原则" class="headerlink" title="3 业务设计原则"></a>3 业务设计原则</h2><h3 id="3-1-防重设计"><a href="#3-1-防重设计" class="headerlink" title="3.1 防重设计"></a>3.1 防重设计</h3><h3 id="3-2-幂等设计"><a href="#3-2-幂等设计" class="headerlink" title="3.2 幂等设计"></a>3.2 幂等设计</h3><h3 id="3-3-流程可定义"><a href="#3-3-流程可定义" class="headerlink" title="3.3 流程可定义"></a>3.3 流程可定义</h3><h3 id="3-4-状态与状态机"><a href="#3-4-状态与状态机" class="headerlink" title="3.4 状态与状态机"></a>3.4 状态与状态机</h3><h3 id="3-5-后台系统操作可反馈"><a href="#3-5-后台系统操作可反馈" class="headerlink" title="3.5 后台系统操作可反馈"></a>3.5 后台系统操作可反馈</h3><h3 id="3-6-后台系统审批化"><a href="#3-6-后台系统审批化" class="headerlink" title="3.6 后台系统审批化"></a>3.6 后台系统审批化</h3><h3 id="3-7-文档和注释"><a href="#3-7-文档和注释" class="headerlink" title="3.7 文档和注释"></a>3.7 文档和注释</h3>]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>高可用</tag>
        <tag>高并发</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>亿级流量网站架构 高可用 回滚</title>
    <url>/2021/01/02/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E9%AB%98%E5%8F%AF%E7%94%A8-%E5%9B%9E%E6%BB%9A/</url>
    <content><![CDATA[<a id="more"></a>]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>高可用</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>亿级流量网站架构 高可用 负载均衡</title>
    <url>/2021/01/02/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E9%AB%98%E5%8F%AF%E7%94%A8-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<h1 id="负载均衡与反向代理"><a href="#负载均衡与反向代理" class="headerlink" title="负载均衡与反向代理"></a>负载均衡与反向代理</h1><a id="more"></a>

<p>Nginx 一般用于七层负载均衡，其吞吐量有一定的限制。为了提升吞吐量，会在 DNS 和 Nginx 之间引入接入层，如使用 LVS（软件负载均衡器）、F5（硬件负载均衡器）可以做四层负载均衡，即首先 DNS 解析到 LVS</p>
<p>术语：</p>
<p>Nginx：接入层、反向代理服务器、负载均衡器</p>
<p>upstream server：上游服务器，也称为 real server：真实处理业务的服务器</p>
<p>负载均衡关心方面：</p>
<ul>
<li>上游服务器配置</li>
<li>负载均衡算法</li>
<li>失败重试机制</li>
<li>服务器心跳检测</li>
</ul>
<h2 id="1-upstream-配置"><a href="#1-upstream-配置" class="headerlink" title="1 upstream 配置"></a>1 upstream 配置</h2><p>Nginx 配置上游服务器</p>
<p>http 指令下 配置 upstream</p>
<h2 id="2-负载均衡算法"><a href="#2-负载均衡算法" class="headerlink" title="2 负载均衡算法"></a>2 负载均衡算法</h2><p>upstream server：</p>
<ul>
<li>round-robin：轮询</li>
<li>ip_hash：ip 哈希</li>
<li>hash key [consistent]：对 key 哈希或一致性哈希</li>
</ul>
<h2 id="3-失败重试"><a href="#3-失败重试" class="headerlink" title="3 失败重试"></a>3 失败重试</h2><p>配置：upstream server 和 proxy pass</p>
<h2 id="4-健康检查"><a href="#4-健康检查" class="headerlink" title="4 健康检查"></a>4 健康检查</h2><p>Nginx 对上游服务器的健康检查默认采用的是惰性策略，可以集成 nginx_upstream_check_module（<a href="https://github.com/yaoweibin/nginx_upstream_check_module%EF%BC%89">https://github.com/yaoweibin/nginx_upstream_check_module）</a> 模块进行主动健康检查。</p>
<h3 id="4-1-TCP-心跳检查"><a href="#4-1-TCP-心跳检查" class="headerlink" title="4.1 TCP 心跳检查"></a>4.1 TCP 心跳检查</h3><h3 id="4-2-HTTP-心跳检查"><a href="#4-2-HTTP-心跳检查" class="headerlink" title="4.2 HTTP 心跳检查"></a>4.2 HTTP 心跳检查</h3><h2 id="5-其他配置"><a href="#5-其他配置" class="headerlink" title="5 其他配置"></a>5 其他配置</h2><h3 id="5-1-上游服务器域名"><a href="#5-1-上游服务器域名" class="headerlink" title="5.1 上游服务器域名"></a>5.1 上游服务器域名</h3><h3 id="5-2-上游服务器备份"><a href="#5-2-上游服务器备份" class="headerlink" title="5.2 上游服务器备份"></a>5.2 上游服务器备份</h3><h3 id="5-3-上游服务器不可用"><a href="#5-3-上游服务器不可用" class="headerlink" title="5.3 上游服务器不可用"></a>5.3 上游服务器不可用</h3><h2 id="6-长连接"><a href="#6-长连接" class="headerlink" title="6 长连接"></a>6 长连接</h2><p>客户端与 Nginx 的长连接</p>
<p>Nginx 与 上游服务器的长连接：通过 keepalive 指令配置长连接数量。</p>
<h2 id="7-反向代理示例"><a href="#7-反向代理示例" class="headerlink" title="7 反向代理示例"></a>7 反向代理示例</h2><h2 id="8-HTTP-动态负载均衡（七层）"><a href="#8-HTTP-动态负载均衡（七层）" class="headerlink" title="8 HTTP 动态负载均衡（七层）"></a>8 HTTP 动态负载均衡（七层）</h2><p>使用 Consul 将upstream 动态注册到 Nginx 上。</p>
<p>Consul 是一款开源的动态分布式服务与发现系统。</p>
<h3 id="8-1-Consul-Consul-template"><a href="#8-1-Consul-Consul-template" class="headerlink" title="8.1 Consul + Consul-template"></a>8.1 Consul + Consul-template</h3><p>每次配置变更都需要 reload nginx，reload 是有一定的损耗的。</p>
<h3 id="8-2-Consul-OpenRestry"><a href="#8-2-Consul-OpenRestry" class="headerlink" title="8.2 Consul + OpenRestry"></a>8.2 Consul + OpenRestry</h3><p>使用 Consul 注册服务，使用 OpenRestry balancer_by_lua 实现无 reload 动态负载均衡。</p>
<h2 id="9-Nginx-四层负载均衡"><a href="#9-Nginx-四层负载均衡" class="headerlink" title="9 Nginx 四层负载均衡"></a>9 Nginx 四层负载均衡</h2><h3 id="9-1-静态负载均衡"><a href="#9-1-静态负载均衡" class="headerlink" title="9.1 静态负载均衡"></a>9.1 静态负载均衡</h3><p>ngx_stream_core_stream 默认没有启用，安装 Nginx 时，添加 <code>--with-stream</code> 配置参数启用。</p>
<p>可以使用开源的 nginx-stream-upsync-module 实现动态负载均衡。</p>
<h3 id="9-2-动态负载均衡"><a href="#9-2-动态负载均衡" class="headerlink" title="9,2 动态负载均衡"></a>9,2 动态负载均衡</h3><p> nginx-upsync-module，提供了七层动态负载均衡 </p>
]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>高可用</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>亿级流量网站架构 高可用 资源隔离</title>
    <url>/2021/01/02/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E9%AB%98%E5%8F%AF%E7%94%A8-%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB/</url>
    <content><![CDATA[<h1 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h1><a id="more"></a>

<h2 id="1-线程隔离"><a href="#1-线程隔离" class="headerlink" title="1 线程隔离"></a>1 线程隔离</h2><p>线程隔离主要是指线程池隔离，当一种业务的请求处理发生问题时，不会将故障扩散到其它线程池，从而保证其他服务可用。</p>
<h2 id="2-进程隔离"><a href="#2-进程隔离" class="headerlink" title="2 进程隔离"></a>2 进程隔离</h2><p>通过系统拆分为多个子系统来实现物理隔离，使得某一个子系统出现问题时不会影响到其它子系统。</p>
<h2 id="3-集群隔离"><a href="#3-集群隔离" class="headerlink" title="3 集群隔离"></a>3 集群隔离</h2><p>商品服务为秒杀提供单独的服务集群，即为服务分组。</p>
<h2 id="4-机房隔离"><a href="#4-机房隔离" class="headerlink" title="4 机房隔离"></a>4 机房隔离</h2><p>多机房部署，不能跨机房调用。</p>
<h2 id="5-读写隔离"><a href="#5-读写隔离" class="headerlink" title="5 读写隔离"></a>5 读写隔离</h2><p>Redis 主从模式实现读写分离、</p>
<h2 id="6-动静隔离"><a href="#6-动静隔离" class="headerlink" title="6 动静隔离"></a>6 动静隔离</h2><p>静态资源放在 CDN 上。</p>
<h2 id="7-爬虫隔离"><a href="#7-爬虫隔离" class="headerlink" title="7 爬虫隔离"></a>7 爬虫隔离</h2><ol>
<li>限流</li>
<li>爬虫路由到单独的集群上</li>
</ol>
<h2 id="8-热点隔离"><a href="#8-热点隔离" class="headerlink" title="8 热点隔离"></a>8 热点隔离</h2><p>秒杀、抢购属于热点服务，将其作成独立系统或服务进行隔离。</p>
<h2 id="9-资源隔离"><a href="#9-资源隔离" class="headerlink" title="9 资源隔离"></a>9 资源隔离</h2><h2 id="10-使用-Hystrix-实现隔离"><a href="#10-使用-Hystrix-实现隔离" class="headerlink" title="10 使用 Hystrix 实现隔离"></a>10 使用 Hystrix 实现隔离</h2><h2 id="11-基于-Servlet-3-实现请求隔离"><a href="#11-基于-Servlet-3-实现请求隔离" class="headerlink" title="11 基于 Servlet 3 实现请求隔离"></a>11 基于 Servlet 3 实现请求隔离</h2><p>异步 NIO</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>高可用</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>亿级流量网站架构 高可用 超时与重试</title>
    <url>/2021/01/02/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E9%AB%98%E5%8F%AF%E7%94%A8-%E8%B6%85%E6%97%B6%E4%B8%8E%E9%87%8D%E8%AF%95/</url>
    <content><![CDATA[<a id="more"></a>]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>高可用</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>亿级流量网站架构 高可用 降级</title>
    <url>/2021/01/02/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E9%AB%98%E5%8F%AF%E7%94%A8-%E9%99%8D%E7%BA%A7/</url>
    <content><![CDATA[<h1 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h1><a id="more"></a>

<p>当访问量剧增、服务出现问题（如响应时间长或不响应）或非核心服务影响到核心流程的性能时，任然需要保证服务还是可用的，即使有损服务。</p>
<h2 id="1-降级预案"><a href="#1-降级预案" class="headerlink" title="1 降级预案"></a>1 降级预案</h2><p>降级按是否自动化可分为：自动开关降级和人工开关降级</p>
<p>降级按功能可分为：读服务降级和写服务降级</p>
<p>降级按照处于的系统层次可分为：多级降级</p>
<h2 id="2-自动开关降级"><a href="#2-自动开关降级" class="headerlink" title="2 自动开关降级"></a>2 自动开关降级</h2><h3 id="2-1-超时降级"><a href="#2-1-超时降级" class="headerlink" title="2.1 超时降级"></a>2.1 超时降级</h3><h3 id="2-2-统计失败降级"><a href="#2-2-统计失败降级" class="headerlink" title="2.2 统计失败降级"></a>2.2 统计失败降级</h3><h3 id="2-3-故障降级"><a href="#2-3-故障降级" class="headerlink" title="2.3 故障降级"></a>2.3 故障降级</h3><h3 id="2-4-限流降级"><a href="#2-4-限流降级" class="headerlink" title="2.4 限流降级"></a>2.4 限流降级</h3><h2 id="3-人工开关降级"><a href="#3-人工开关降级" class="headerlink" title="3 人工开关降级"></a>3 人工开关降级</h2><h2 id="4-读服务降级"><a href="#4-读服务降级" class="headerlink" title="4 读服务降级"></a>4 读服务降级</h2><h2 id="5-写服务降级"><a href="#5-写服务降级" class="headerlink" title="5 写服务降级"></a>5 写服务降级</h2><h2 id="6-多级降级"><a href="#6-多级降级" class="headerlink" title="6 多级降级"></a>6 多级降级</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>高可用</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>亿级流量网站架构 高可用 限流</title>
    <url>/2021/01/02/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E9%AB%98%E5%8F%AF%E7%94%A8-%E9%99%90%E6%B5%81/</url>
    <content><![CDATA[<h1 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h1><a id="more"></a>

<h2 id="1-限流算法"><a href="#1-限流算法" class="headerlink" title="1 限流算法"></a>1 限流算法</h2><p>常见的限流算法有：令牌桶、漏桶、计数器</p>
<h3 id="1-1-令牌桶算法"><a href="#1-1-令牌桶算法" class="headerlink" title="1.1 令牌桶算法"></a>1.1 令牌桶算法</h3><h3 id="1-2-漏桶算法"><a href="#1-2-漏桶算法" class="headerlink" title="1.2 漏桶算法"></a>1.2 漏桶算法</h3><h2 id="2-应用级限流"><a href="#2-应用级限流" class="headerlink" title="2 应用级限流"></a>2 应用级限流</h2><h3 id="2-1-总并发数-连接-请求数限流"><a href="#2-1-总并发数-连接-请求数限流" class="headerlink" title="2.1 总并发数/连接/请求数限流"></a>2.1 总并发数/连接/请求数限流</h3><p>对于一个应用系统来说，一定会有极限并发数/请求数，即总有一个 TPS/QPS 阈值，如果超过了阈值，则系统就不会响应用户请求或响应变得很慢，因此我们最好进行过载保护，以防止大量请求涌入击垮系统。</p>
<p>Tomcat 的 Connector 配置：</p>
<ul>
<li>acceptCount：</li>
<li>maxConnections：</li>
<li>maxThreads：</li>
</ul>
<p>MySQL、Redis也有类似的限制连接数的配置。</p>
<h3 id="2-2-总资源数限流"><a href="#2-2-总资源数限流" class="headerlink" title="2.2 总资源数限流"></a>2.2 总资源数限流</h3><p>连接池、线程池</p>
<h3 id="2-3-某个接口的总并发-请求数"><a href="#2-3-某个接口的总并发-请求数" class="headerlink" title="2.3 某个接口的总并发/请求数"></a>2.3 某个接口的总并发/请求数</h3><p>如果接口可能会有突发情况，但又担心访问量太大造成崩溃，如抢购业务，那么就需要限制这个接口的总并发/请求数。可以使用 Java 的 AtomicLong 或者 Semaphore 进行限流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (atomic.incrementAndGet() &gt; 限流数) &#123;</span><br><span class="line">        <span class="comment">// 拒绝请求</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理请求</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    atomic.deementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-某个接口的时间窗请求数"><a href="#2-4-某个接口的时间窗请求数" class="headerlink" title="2.4 某个接口的时间窗请求数"></a>2.4 某个接口的时间窗请求数</h3><p>一个时间窗口内的请求数</p>
<p>使用 Guava 的 Cache 存储计数器</p>
<h3 id="2-5-平滑限流某个接口的请求数"><a href="#2-5-平滑限流某个接口的请求数" class="headerlink" title="2.5 平滑限流某个接口的请求数"></a>2.5 平滑限流某个接口的请求数</h3><p>以上的方法不能应对瞬时的请求，从而导致一些问题。</p>
<p>令牌桶和漏桶算法可以整形为平均速率请求。</p>
<p>Guava RateLimiter 提供了令牌桶算法可用于平滑突发限流（SmoothBursty）和平滑预热限流（SmoothWarmingUp）实现。</p>
<h2 id="3-分布式限流"><a href="#3-分布式限流" class="headerlink" title="3 分布式限流"></a>3 分布式限流</h2><p>分布式限流最关键的是要将限流服务原子化，而解决方案可以使用 Redis + Lua 或者 Nginx + Lua 技术实现。</p>
<h3 id="3-1-Redis-Lua"><a href="#3-1-Redis-Lua" class="headerlink" title="3.1 Redis + Lua"></a>3.1 Redis + Lua</h3><h3 id="3-2-Nginx-Lua"><a href="#3-2-Nginx-Lua" class="headerlink" title="3.2 Nginx + Lua"></a>3.2 Nginx + Lua</h3><p><a href="https://github.com/openresty/lua-resty-lock">https://github.com/openresty/lua-resty-lock</a></p>
<h2 id="4-接入层限流"><a href="#4-接入层限流" class="headerlink" title="4 接入层限流"></a>4 接入层限流</h2><h3 id="4-1-ngx-http-limit-conn-module"><a href="#4-1-ngx-http-limit-conn-module" class="headerlink" title="4.1 ngx_http_limit_conn_module"></a>4.1 ngx_http_limit_conn_module</h3><h3 id="4-2-ngx-http-limit-req-module"><a href="#4-2-ngx-http-limit-req-module" class="headerlink" title="4.2 ngx_http_limit_req_module"></a>4.2 ngx_http_limit_req_module</h3>]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>高可用</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>亿级流量网站架构 高并发 HTTP 缓存</title>
    <url>/2021/01/02/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E9%AB%98%E5%B9%B6%E5%8F%91-HTTP-%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h1><a id="more"></a>

<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>浏览器缓存缓存场景</p>
<h2 id="2-HTTP-缓存"><a href="#2-HTTP-缓存" class="headerlink" title="2 HTTP 缓存"></a>2 HTTP 缓存</h2><h3 id="2-1-ETag"><a href="#2-1-ETag" class="headerlink" title="2.1 ETag"></a>2.1 ETag</h3><h3 id="2-2-Last-Modified"><a href="#2-2-Last-Modified" class="headerlink" title="2.2 Last-Modified"></a>2.2 Last-Modified</h3><h2 id="3-HTTPClient-客户端缓存"><a href="#3-HTTPClient-客户端缓存" class="headerlink" title="3 HTTPClient 客户端缓存"></a>3 HTTPClient 客户端缓存</h2><h2 id="4-Nginx-HTTP-缓存设置"><a href="#4-Nginx-HTTP-缓存设置" class="headerlink" title="4 Nginx HTTP 缓存设置"></a>4 Nginx HTTP 缓存设置</h2><h2 id="5-Nginx-代理层缓存"><a href="#5-Nginx-代理层缓存" class="headerlink" title="5 Nginx 代理层缓存"></a>5 Nginx 代理层缓存</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>高并发</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>亿级流量网站架构 高并发 多级缓存</title>
    <url>/2021/01/02/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E9%AB%98%E5%B9%B6%E5%8F%91-%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h1><a id="more"></a>

<p>从架构和提升命中率层面探讨缓存方案</p>
<h2 id="1-多级缓存介绍"><a href="#1-多级缓存介绍" class="headerlink" title="1 多级缓存介绍"></a>1 多级缓存介绍</h2><h2 id="2-如何缓存数据"><a href="#2-如何缓存数据" class="headerlink" title="2 如何缓存数据"></a>2 如何缓存数据</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>高并发</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>亿级流量网站架构 高并发 应用级缓存</title>
    <url>/2021/01/02/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E9%AB%98%E5%B9%B6%E5%8F%91-%E5%BA%94%E7%94%A8%E7%BA%A7%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="应用级缓存"><a href="#应用级缓存" class="headerlink" title="应用级缓存"></a>应用级缓存</h1><a id="more"></a>

<h2 id="1-缓存简介"><a href="#1-缓存简介" class="headerlink" title="1 缓存简介"></a>1 缓存简介</h2><p>缓存工作机制是先从缓存中读取数据，如果没有，再从慢速设备上读取实际数据并同步到缓存。经常读取的数据、频繁访问的数据、热点数据、I/O 瓶颈数据、计算昂贵的数据、服务 5 分钟法则的数据和局部性原理的数据都可以存进缓存。</p>
<blockquote>
<p>I/O 的 5 分钟法则：1987年，Jim Gray 和 Gianfranco Putzolu 推出了著名的5分钟法则，以权衡内存和 I/O 容量，他们的计算将使用内存芯片和磁盘驱动器的适当价格，将永久保存一条记录（或页面）的成本与每次访问该记录（或页面）时执行磁盘 I/O 的成本进行比较。他们的规则的名称是指访问之间的收支平衡时间间隔。如果更频繁地访问记录（或页面），则应将其保存在内存中；否则，它应该保留在磁盘上并在需要时读取。</p>
<p>$BreakEvenIntervalinSeconds = \frac{PagesPerMBofRAM}{PagesPerMBofRAM} * \frac{PricePerDiskDrive}{PricePerMBofRAM}$</p>
<ul>
<li><p>PagesPerMBofRAM：表示内存每兆字节的 Pag e数，如果 page size = 4KB，则该值为 1MB/(4KB/page) = 256 page/MB。</p>
</li>
<li><p>AccessesPerSecondPerDisk：每块磁盘每秒支持的最大 I/O 请求数，如下表所示为 250 Page/ (Second*Disk)。</p>
</li>
<li><p>(PagesPerMBofRAM /AccessesPerSecondPerDisk)：表示 1 兆的空间通过磁盘访问的方式所需要的秒数。256/200 = 1.25(Second*Disk)/MB，表示 1 兆字节需要 1.25 个盘秒来完成（类似工作任务按人月来做单位）。</p>
</li>
<li><p>PricePerDiskDrive：表示一块磁盘的成本，如下表所示为$48/disk。<br>PricePerMBofRAM：表示每兆内存的代价，如下表所示为50/(2048)=0.024$/MB。</p>
</li>
<li><p>PricePerDiskDrive/ PricePerMBofRAM:表示用来买磁盘的钱可以买多少兆内存。48/0.024=2000MB /disk。</p>
</li>
</ul>
<p>详细内容参考：<a href="https://zhuanlan.zhihu.com/p/100626824?utm_source=wechat_timeline">https://zhuanlan.zhihu.com/p/100626824?utm_source=wechat_timeline</a></p>
</blockquote>
<p>案例：CPU 多级缓存</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20210418104732355.png" alt="image-20210418104732355"></p>
<h2 id="2-缓存命中率"><a href="#2-缓存命中率" class="headerlink" title="2 缓存命中率"></a>2 缓存命中率</h2><p>缓存命中率是从缓存中读取数据的次数与总读取次数的比率，命中率越高越好。</p>
<p>$缓存命中率 =  \frac{从缓存中读取次数} {总读取次数（从缓存中读取次数 + 从慢速设备上读取次数）)}$</p>
<h2 id="3-缓存回收策略"><a href="#3-缓存回收策略" class="headerlink" title="3 缓存回收策略"></a>3 缓存回收策略</h2><h3 id="3-1-基于空间"><a href="#3-1-基于空间" class="headerlink" title="3.1 基于空间"></a>3.1 基于空间</h3><p>缓存设置了存储空间，当达到存储空间上限时，按照一定的策略移除数据。</p>
<h3 id="3-2-基于容量"><a href="#3-2-基于容量" class="headerlink" title="3.2 基于容量"></a>3.2 基于容量</h3><p>缓存设置了最大大小，当缓存条目超过最大大小时，按照一定的策略移除旧数据。</p>
<h3 id="3-3-基于时间"><a href="#3-3-基于时间" class="headerlink" title="3.3 基于时间"></a>3.3 基于时间</h3><ul>
<li><p>TTL（Time To Live）：存活期，即缓存数据创建开始直到到期的一个时间段（不管缓存数据有没有被访问到，都将过期）。</p>
</li>
<li><p>TTI（Time To Idle）：空闲期，即缓存数据多久没有被访问后移除缓存的时间。</p>
</li>
</ul>
<h3 id="3-4-基于-Java-对象引用"><a href="#3-4-基于-Java-对象引用" class="headerlink" title="3.4 基于 Java 对象引用"></a>3.4 基于 Java 对象引用</h3><p>只有在没有其他强引用对象引用弱引用/软引用对象时，垃圾回收器才回收该引用。</p>
<ul>
<li><p>软引用：如果一个对象是软引用，当 JVM 堆内存不足时，垃圾回收器将回收软引用对象。<strong>软引用适合做缓存。</strong></p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20210418110909494.png" alt="image-20210418110909494"></p>
</li>
<li><p>弱引用：当垃圾回收器回收内存时，如果发现弱引用，则将它立即回收。案例：ThreadLocal</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20210418110627013.png" alt="image-20210418110627013"></p>
</li>
</ul>
<h3 id="3-5-回收算法"><a href="#3-5-回收算法" class="headerlink" title="3.5 回收算法"></a>3.5 回收算法</h3><p>最常用：LRU</p>
<ul>
<li>FIFO（First In First Out）：先进先出算法，即先放入缓存的先被移除。</li>
<li>LRU（Least Recently Used）：最少使用算法，即上次使用时间距离现在最久的那个被移除。</li>
<li>LFU（Least Frequebtly Used）；最不常用算法，一定时间内使用次数（频率）最少的那个被移除。</li>
</ul>
<h2 id="4-Java-缓存类型"><a href="#4-Java-缓存类型" class="headerlink" title="4 Java 缓存类型"></a>4 Java 缓存类型</h2><h3 id="4-1-堆缓存"><a href="#4-1-堆缓存" class="headerlink" title="4.1 堆缓存"></a>4.1 堆缓存</h3><p>使用  Java 堆来存储缓存对象。</p>
<ul>
<li>优点：没有序列化/反序列化，是最快的缓存。</li>
<li>缺点：缓存数据量很大时，GC 暂停时间会变长，存储容量受限于堆空间大小。</li>
</ul>
<p>一般使用堆缓存存储较热的数据。可以使用 Guava Cache、Ehcache 3.X，MapDB 实现。</p>
<h3 id="4-2-堆外缓存"><a href="#4-2-堆外缓存" class="headerlink" title="4.2 堆外缓存"></a>4.2 堆外缓存</h3><p>即缓存数据存储在堆外内存。</p>
<ul>
<li><p>优点：可以减少 GC 暂停时间（减少 GC 扫描和对象移动），可以支持更大的缓存空间。</p>
</li>
<li><p>缺点：读取数据时需要序列化/反序列化。</p>
</li>
</ul>
<p>可以使用 Ehcache 3.X，MapDB 实现。</p>
<h3 id="4-3-磁盘缓存"><a href="#4-3-磁盘缓存" class="headerlink" title="4.3 磁盘缓存"></a>4.3 磁盘缓存</h3><p>即缓存数据到磁盘上。</p>
<ul>
<li>优点：JVM 重启时数据还是存在的。</li>
<li>缺点：堆外缓存会丢失，需要重新加载。</li>
</ul>
<p>可以使用 Ehcache 3.X，MapDB 实现。</p>
<h3 id="4-4-分布式缓存"><a href="#4-4-分布式缓存" class="headerlink" title="4.4 分布式缓存"></a>4.4 分布式缓存</h3><p>多 JVM 实例会存在两个问题：</p>
<ol>
<li>单机容量问题</li>
<li>资源一致性问题</li>
<li>缓存不命中时，需要回源到 DB/服务 请求多变问题。</li>
</ol>
<p>可以使用分布式缓存解决。</p>
<p>可以使用 ehcache-clustered（配合 Terracotta server）实现 Java 进程间分布式缓存，也可以使用 Redis 实现分布式缓存。</p>
<p>两种模式如下：</p>
<ul>
<li>单机时：存储最热的数据到堆缓存，相对较热的数据到堆外缓存，不热的数据到磁盘缓存。</li>
<li>集群时：存储最热的数据到堆缓存，相对较热的数据到堆外缓存，全量数据到分布式缓存。</li>
</ul>
<h2 id="5-应用级缓存实例"><a href="#5-应用级缓存实例" class="headerlink" title="5 应用级缓存实例"></a>5 应用级缓存实例</h2><p>暂略。</p>
<h2 id="6-缓存使用模式实践"><a href="#6-缓存使用模式实践" class="headerlink" title="6 缓存使用模式实践"></a>6 缓存使用模式实践</h2><p>缓存使用模式/模板：</p>
<ul>
<li>Cache-Aside</li>
<li>Cache-As-SoR</li>
</ul>
<p><a href="https://yeyangshu.top/2021/01/06/%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/">点击查看对应文章</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>高并发</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>亿级流量网站架构 高并发 异步并发</title>
    <url>/2021/01/02/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E9%AB%98%E5%B9%B6%E5%8F%91-%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h1 id="异步并发实战"><a href="#异步并发实战" class="headerlink" title="异步并发实战"></a>异步并发实战</h1><a id="more"></a>

<h2 id="1-同步阻塞调用"><a href="#1-同步阻塞调用" class="headerlink" title="1 同步阻塞调用"></a>1 同步阻塞调用</h2><h2 id="2-异步-Future"><a href="#2-异步-Future" class="headerlink" title="2 异步 Future"></a>2 异步 Future</h2><h2 id="3-异步-Callback"><a href="#3-异步-Callback" class="headerlink" title="3 异步 Callback"></a>3 异步 Callback</h2><h2 id="4-异步编排-CompletableFuture"><a href="#4-异步编排-CompletableFuture" class="headerlink" title="4 异步编排 CompletableFuture"></a>4 异步编排 CompletableFuture</h2><h2 id="5-异步-Web-服务实现"><a href="#5-异步-Web-服务实现" class="headerlink" title="5 异步 Web 服务实现"></a>5 异步 Web 服务实现</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>高并发</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>亿级流量网站架构 高并发 线程池连接池</title>
    <url>/2021/01/02/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E9%AB%98%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>高并发</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>亿级流量网站架构 高并发 扩容</title>
    <url>/2021/01/02/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E9%AB%98%E5%B9%B6%E5%8F%91-%E6%89%A9%E5%AE%B9/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>高并发</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>亿级流量网站架构 高并发 队列</title>
    <url>/2021/01/02/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E9%AB%98%E5%B9%B6%E5%8F%91-%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>高并发</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>使用ThreadLocal创建线程上下文</title>
    <url>/2020/12/26/%E4%BD%BF%E7%94%A8ThreadLocal%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<h1 id="使用ThreadLocal创建线程上下文"><a href="#使用ThreadLocal创建线程上下文" class="headerlink" title="使用ThreadLocal创建线程上下文"></a>使用ThreadLocal创建线程上下文</h1><a id="more"></a>

<h2 id="1-定义上下文接口"><a href="#1-定义上下文接口" class="headerlink" title="1 定义上下文接口"></a>1 定义上下文接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加属性</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(String key, Object object)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得属性</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">get</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-定义上下文实现类"><a href="#2-定义上下文实现类" class="headerlink" title="2 定义上下文实现类"></a>2 定义上下文实现类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskThreadContext</span> <span class="keyword">implements</span> <span class="title">ThreadContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 订单id */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> orderId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 任务开始执行时间 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> startTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** task context map */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; taskContextMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String key, Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == taskContextMap) &#123;</span><br><span class="line">            taskContextMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        taskContextMap.put(key, object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == taskContextMap) &#123;</span><br><span class="line">            taskContextMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> taskContextMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrderId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderId</span><span class="params">(<span class="keyword">int</span> orderId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderId = orderId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getStartTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStartTime</span><span class="params">(<span class="keyword">long</span> startTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.startTime = startTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-定义ThreadContext持有类"><a href="#3-定义ThreadContext持有类" class="headerlink" title="3 定义ThreadContext持有类"></a>3 定义ThreadContext持有类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskContextHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** task context threadLocal */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ThreadContext&gt; TASK_CONTEXT = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadContext <span class="title">getTaskContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (TASK_CONTEXT.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            TASK_CONTEXT.set(<span class="keyword">new</span> TaskThreadContext());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> TASK_CONTEXT.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setTaskContext</span><span class="params">(ThreadContext taskContext)</span> </span>&#123;</span><br><span class="line">        TASK_CONTEXT.set(taskContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String key, Object param)</span> </span>&#123;</span><br><span class="line">        getTaskContext().add(key, param);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getTaskContext().get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4 测试"></a>4 测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程t1</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 添加上下文</span></span><br><span class="line">            TaskThreadContext context = <span class="keyword">new</span> TaskThreadContext();</span><br><span class="line">            context.setOrderId(<span class="number">1</span>);</span><br><span class="line">            TaskContextHolder.setTaskContext(context);</span><br><span class="line">            <span class="comment">// 添加普通属性</span></span><br><span class="line">            TaskContextHolder.add(<span class="string">&quot;t1&quot;</span>, <span class="string">&quot;Hello t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">            TaskThreadContext taskContext = (TaskThreadContext) TaskContextHolder.getTaskContext();</span><br><span class="line">            System.out.println(<span class="string">&quot;t1 order id：&quot;</span> + taskContext.getOrderId());</span><br><span class="line">            System.out.println(<span class="string">&quot;t1：&quot;</span> + TaskContextHolder.get(<span class="string">&quot;t1&quot;</span>));</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程t2</span></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 添加上下文</span></span><br><span class="line">            TaskThreadContext context = <span class="keyword">new</span> TaskThreadContext();</span><br><span class="line">            context.setOrderId(<span class="number">2</span>);</span><br><span class="line">            TaskContextHolder.setTaskContext(context);</span><br><span class="line">            <span class="comment">// 添加普通属性</span></span><br><span class="line">            TaskContextHolder.add(<span class="string">&quot;t2&quot;</span>, <span class="string">&quot;Hello t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">            TaskThreadContext taskContext = (TaskThreadContext) TaskContextHolder.getTaskContext();</span><br><span class="line">            System.out.println(<span class="string">&quot;t2 order id：&quot;</span> + taskContext.getOrderId());</span><br><span class="line">            System.out.println(<span class="string">&quot;t2：&quot;</span> + TaskContextHolder.get(<span class="string">&quot;t2&quot;</span>));</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t1 order id：1</span><br><span class="line">t1：Hello t1</span><br><span class="line">t2 order id：2</span><br><span class="line">t2：Hello t2</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>ThreadLocal</tag>
        <tag>上下文</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式 ID</title>
    <url>/2021/01/02/%E5%88%86%E5%B8%83%E5%BC%8F-ID/</url>
    <content><![CDATA[<h1 id="分布式-ID"><a href="#分布式-ID" class="headerlink" title="分布式 ID"></a>分布式 ID</h1><a id="more"></a>

<h2 id="1-基于UUID"><a href="#1-基于UUID" class="headerlink" title="1 基于UUID"></a>1 基于UUID</h2><h3 id="1-1-UUID简介"><a href="#1-1-UUID简介" class="headerlink" title="1.1 UUID简介"></a>1.1 UUID简介</h3><h3 id="1-2-UUID生成策略"><a href="#1-2-UUID生成策略" class="headerlink" title="1.2 UUID生成策略"></a>1.2 UUID生成策略</h3><p>基于时间的UUID</p>
<p>DCE安全的UUID</p>
<p>基于名字的UUID（MD5）</p>
<p>随机的UUID</p>
<p>基于名字的UUID（SHA1）</p>
<h2 id="2-基于DB数据库多种模式（自增主键、segment）"><a href="#2-基于DB数据库多种模式（自增主键、segment）" class="headerlink" title="2 基于DB数据库多种模式（自增主键、segment）"></a>2 基于DB数据库多种模式（自增主键、segment）</h2><h2 id="3-基于Redis"><a href="#3-基于Redis" class="headerlink" title="3 基于Redis"></a>3 基于Redis</h2><p>因为 Redis 是单线程的，天然没有资源争用问题，可以采用 incr 命令，实现 ID 的原子性自增。</p>
<p>但是因为 Redis 的数据数据备份 RDB，会存在漏掉数据的可能，所以理论上存在已使用的 ID 再次被使用，所以备份方式可以加上 AOF 方式，这样的话效果有所损耗。</p>
<h2 id="4-基于ZK、ETCD"><a href="#4-基于ZK、ETCD" class="headerlink" title="4 基于ZK、ETCD"></a>4 基于ZK、ETCD</h2><h2 id="5-基于SnowFlake"><a href="#5-基于SnowFlake" class="headerlink" title="5 基于SnowFlake"></a>5 基于SnowFlake</h2><h2 id="6-美团Leaf（DB-Segment、zk-SnowFlake）"><a href="#6-美团Leaf（DB-Segment、zk-SnowFlake）" class="headerlink" title="6 美团Leaf（DB-Segment、zk+SnowFlake）"></a>6 美团Leaf（DB-Segment、zk+SnowFlake）</h2><h2 id="7-百度uuid-generator"><a href="#7-百度uuid-generator" class="headerlink" title="7 百度uuid-generator()"></a>7 百度uuid-generator()</h2>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>分布式 ID</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事物</title>
    <url>/2021/01/02/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E7%89%A9/</url>
    <content><![CDATA[<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><a id="more"></a>

<h2 id="1-数据库事物-ACID"><a href="#1-数据库事物-ACID" class="headerlink" title="1 数据库事物 ACID"></a>1 数据库事物 ACID</h2><h2 id="2-2PC"><a href="#2-2PC" class="headerlink" title="2 2PC"></a>2 2PC</h2><h2 id="3-3PC"><a href="#3-3PC" class="headerlink" title="3 3PC"></a>3 3PC</h2><h2 id="4-消息表"><a href="#4-消息表" class="headerlink" title="4 消息表"></a>4 消息表</h2><h2 id="5-TCC"><a href="#5-TCC" class="headerlink" title="5 TCC"></a>5 TCC</h2>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>分布式事物</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式锁</title>
    <url>/2021/01/02/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><a id="more"></a>

<h2 id="1-数据库锁"><a href="#1-数据库锁" class="headerlink" title="1 数据库锁"></a>1 数据库锁</h2><p>阻塞式加锁，适合并发量不高的小项目。</p>
<p>数据库创建一个锁表，添加唯一索引，通过操作该表的数据来实现。获得锁的时候在表中添加一条记录，释放锁的时候就删除这条记录，如果有多个请求同时提交到数据库的话，数据库可以保证只有一个操作可以成功，可以认为操作成功的那个请求获得了锁。</p>
<p>存在以下几个问题</p>
<ul>
<li>锁没有过期时间；</li>
<li>只能是非阻塞锁，插入失败直接报错，无法重试；</li>
<li>不可重入，已经获得锁的进程也必须重新获取锁。</li>
</ul>
<h2 id="2-单机-Redis-锁"><a href="#2-单机-Redis-锁" class="headerlink" title="2 单机 Redis 锁"></a>2 单机 Redis 锁</h2><h3 id="2-1-SETNX"><a href="#2-1-SETNX" class="headerlink" title="2.1 SETNX"></a>2.1 SETNX</h3><p>使用 SETNX（set if not exist）指令插入一个键值对，如果 Key 已经存在，那么会返回 false，否则插入成功并返回 true。</p>
<p>可以使用 EXPIRE 指令为一个键值对设置一个过期时间，从而避免了数据库唯一索引实现方式中释放锁失败的问题。</p>
<h3 id="2-2-Redisson"><a href="#2-2-Redisson" class="headerlink" title="2.2 Redisson"></a>2.2 Redisson</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成key</span></span><br><span class="line">String lock = <span class="string">&quot;order_&quot;</span> + (orderId + <span class="string">&quot;&quot;</span>);</span><br><span class="line">RLock rlock = redisson.getLock(lock.intern());</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 此代码默认 设置key 超时时间30秒，过10秒，再延时</span></span><br><span class="line">    rlock.lock();</span><br><span class="line">    <span class="comment">// 业务代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    rlock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-多机-Redis-Redlock"><a href="#3-多机-Redis-Redlock" class="headerlink" title="3 多机 Redis Redlock"></a>3 多机 Redis Redlock</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成redis key</span></span><br><span class="line">String key = (RedisKeyConstant.GRAB_LOCK_ORDER_KEY_PRE + orderId).intern();</span><br><span class="line"></span><br><span class="line">RLock rLock1 = redisson1.getLock(key);</span><br><span class="line">RLock rLock2 = redisson2.getLock(key);</span><br><span class="line">RLock rLock3 = redisson3.getLock(key);</span><br><span class="line">RedissonRedLock redissonRedLock = <span class="keyword">new</span> RedissonRedLock(rLock1, rLock2, rLock3);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// redissson代码默认设置key超时时间30秒，过10秒再延时</span></span><br><span class="line">    redissonRedLock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;  <span class="keyword">finally</span> &#123;</span><br><span class="line">    redissonRedLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-Zookeeper-有序临时节点"><a href="#4-Zookeeper-有序临时节点" class="headerlink" title="4 Zookeeper 有序临时节点"></a>4 Zookeeper 有序临时节点</h2>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存和数据一致性</title>
    <url>/2021/01/06/%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    <content><![CDATA[<h1 id="缓存和数据一致性"><a href="#缓存和数据一致性" class="headerlink" title="缓存和数据一致性"></a>缓存和数据一致性</h1><a id="more"></a>

<p>名词解释：</p>
<ul>
<li>SoR（system of record）：记录系统，数据源，即实际存储原始数据的系统。</li>
<li>Cache：缓存，SoR 的快照数据。</li>
<li>回源：回到数据源头获取数据。</li>
</ul>
<h2 id="1-Cache-Aside"><a href="#1-Cache-Aside" class="headerlink" title="1 Cache Aside"></a>1 Cache Aside</h2><p>业务代码围绕着 Cache 写，由业务代码直接维护缓存。</p>
<ol>
<li><p>读场景</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 先从缓存中读取数据</span></span><br><span class="line">value = cache.get(key);</span><br><span class="line"><span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.1 如果缓存没有命中，则回源到SoR中获取源数据</span></span><br><span class="line">	value = loadFromSoR(key);</span><br><span class="line">    <span class="comment">// 2.2 将数据放入缓存，下次即可从缓存中获取数据 </span></span><br><span class="line">    cache.put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>写场景</p>
<ul>
<li><p>先将数据写入 SoR，写入成功后立即将数据同步写入缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 先将数据写入SoR</span></span><br><span class="line">writeToSoR(key, value);</span><br><span class="line"><span class="comment">// 2 写入成功后立即将数据同步写入缓存</span></span><br><span class="line">cache.put(key, value);</span><br></pre></td></tr></table></figure></li>
<li><p>先将数据写入 SoR，写入成功后将缓存数据过期，下次读取时再加载缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 先将数据写入SoR</span></span><br><span class="line">writeToSoR(key, value);</span><br><span class="line"><span class="comment">// 2 失效缓存，下次读取时再加载缓存</span></span><br><span class="line">cache.invalidate(key)</span><br></pre></td></tr></table></figure>
<p>并发更新时，缓存不一致怎么办？</p>
</li>
<li><p>如果是用户维度的数据（如订单数据、用户数据），这种几率非常小，因为并发的情况很少，可以不要考虑这个问题</p>
</li>
<li><p>如果是商品这种基础数据，可以考虑使用 canal 订阅 Binlog，来进行增量更新分布式缓存，这样不会存在缓存数据不一致的情况。但是缓存更新会存在延迟。</p>
</li>
<li><p>读服务场景，可以考虑使用一致性哈希，将相同的操作负载均衡到同一个实例，从而减少并发几率。或者设置比较短的过期时间。</p>
</li>
</ul>
</li>
</ol>
<h2 id="2-Cache-As-SoR"><a href="#2-Cache-As-SoR" class="headerlink" title="2 Cache-As-SoR"></a>2 Cache-As-SoR</h2><p>把 Cache 看做 SoR（数据库），所有操作只对 Cache 进行，然后 Cache 再委托给 SoR 进行真实的读/写。</p>
<p>有三种实现：Read-Through、Write-Through、Write-Behind</p>
<h3 id="2-1-Read-Through"><a href="#2-1-Read-Through" class="headerlink" title="2.1 Read-Through"></a>2.1 Read-Through</h3><p>Read-Through，业务代码首先调用 Cache，如果 Cache 不命中由 Cache 回源到 SoR，而不是业务代码，即由 Cache 读 SoR。</p>
<h3 id="2-2-Write-Through"><a href="#2-2-Write-Through" class="headerlink" title="2.2 Write-Through"></a>2.2 Write-Through</h3><p>Write-Through，被称为穿透写模式/只写模式。业务代码首先调用 Cache 写（新增/修改）数据，然后由 Cache 负责写数据和写 SoR，而不是业务代码。</p>
<h3 id="2-3-Write-Behind"><a href="#2-3-Write-Behind" class="headerlink" title="2.3 Write-Behind"></a>2.3 Write-Behind</h3><p>Write-behind，也叫 Write-Back，回写模式。Write-Behind 不同于 Write-Through 的是，Write-Through 是异步写。异步之后可以实现批量写、合并写、延时写和限流。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>项目启动加载配置类型数据至内存</title>
    <url>/2020/12/25/%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E8%87%B3%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h1 id="项目启动加载配置类型数据至内存"><a href="#项目启动加载配置类型数据至内存" class="headerlink" title="项目启动加载配置类型数据至内存"></a>项目启动加载配置类型数据至内存</h1><a id="more"></a>

<p>一般数据分类</p>
<ul>
<li>流水型数据</li>
<li>状态型数据</li>
<li>配置型数据。</li>
</ul>
<p>对于配置型数据而言，改动不是很频繁，可以在项目启动的时候直接加载到内存，避免需要数据时去查询数据库，造成不必要的IO消耗。<br>配置类型的数据可以在数据库中存储，也可以托管至github。<br>下图是启动时加载数据的原理图：<br><img src="https://img2020.cnblogs.com/blog/2029601/202012/2029601-20201219215901828-1492959658.png"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Redis 基本数据类型 String</title>
    <url>/2020/12/26/Redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-String/</url>
    <content><![CDATA[<h1 id="Redis-Strings"><a href="#Redis-Strings" class="headerlink" title="Redis Strings"></a>Redis Strings</h1><h2 id="1-Strings-简介"><a href="#1-Strings-简介" class="headerlink" title="1 Strings 简介"></a>1 Strings 简介</h2><p>官网：</p>
<p>这是最简单Redis类型。如果你只用这种类型，Redis就像一个可以持久化的memcached服务器</p>
<a id="more"></a>

<h2 id="2-String-命令"><a href="#2-String-命令" class="headerlink" title="2 String 命令"></a>2 String 命令</h2><h3 id="2-1-help-string"><a href="#2-1-help-string" class="headerlink" title="2.1 help @string"></a>2.1 help @string</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help @string</span><br><span class="line"></span><br><span class="line">  APPEND key value</span><br><span class="line">  summary: Append a value to a key</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  BITCOUNT key [start end]</span><br><span class="line">  summary: Count set bits in a string</span><br><span class="line">  since: 2.6.0</span><br><span class="line"></span><br><span class="line">  BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]</span><br><span class="line">  summary: Perform arbitrary bitfield integer operations on strings</span><br><span class="line">  since: 3.2.0</span><br><span class="line"></span><br><span class="line">  BITOP operation destkey key [key ...]</span><br><span class="line">  summary: Perform bitwise operations between strings</span><br><span class="line">  since: 2.6.0</span><br><span class="line"></span><br><span class="line">  BITPOS key bit [start] [end]</span><br><span class="line">  summary: Find first bit set or clear in a string</span><br><span class="line">  since: 2.8.7</span><br><span class="line"></span><br><span class="line">  DECR key</span><br><span class="line">  summary: Decrement the integer value of a key by one</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  DECRBY key decrement</span><br><span class="line">  summary: Decrement the integer value of a key by the given number</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  GET key</span><br><span class="line">  summary: Get the value of a key</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  GETBIT key offset</span><br><span class="line">  summary: Returns the bit value at offset in the string value stored at key</span><br><span class="line">  since: 2.2.0</span><br><span class="line"></span><br><span class="line">  GETRANGE key start end</span><br><span class="line">  summary: Get a substring of the string stored at a key</span><br><span class="line">  since: 2.4.0</span><br><span class="line"></span><br><span class="line">  GETSET key value</span><br><span class="line">  summary: Set the string value of a key and return its old value</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  INCR key</span><br><span class="line">  summary: Increment the integer value of a key by one</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  INCRBY key increment</span><br><span class="line">  summary: Increment the integer value of a key by the given amount</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  INCRBYFLOAT key increment</span><br><span class="line">  summary: Increment the float value of a key by the given amount</span><br><span class="line">  since: 2.6.0</span><br><span class="line"></span><br><span class="line">  MGET key [key ...]</span><br><span class="line">  summary: Get the values of all the given keys</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  MSET key value [key value ...]</span><br><span class="line">  summary: Set multiple keys to multiple values</span><br><span class="line">  since: 1.0.1</span><br><span class="line"></span><br><span class="line">  MSETNX key value [key value ...]</span><br><span class="line">  summary: Set multiple keys to multiple values, only if none of the keys exist</span><br><span class="line">  since: 1.0.1</span><br><span class="line"></span><br><span class="line">  PSETEX key milliseconds value</span><br><span class="line">  summary: Set the value and expiration in milliseconds of a key</span><br><span class="line">  since: 2.6.0</span><br><span class="line"></span><br><span class="line">  SET key value [expiration EX seconds|PX milliseconds] [NX|XX]</span><br><span class="line">  summary: Set the string value of a key</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SETBIT key offset value</span><br><span class="line">  summary: Sets or clears the bit at offset in the string value stored at key</span><br><span class="line">  since: 2.2.0</span><br><span class="line"></span><br><span class="line">  SETEX key seconds value</span><br><span class="line">  summary: Set the value and expiration of a key</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  SETNX key value</span><br><span class="line">  summary: Set the value of a key, only if the key does not exist</span><br><span class="line">  since: 1.0.0</span><br><span class="line"></span><br><span class="line">  SETRANGE key offset value</span><br><span class="line">  summary: Overwrite part of a string at key starting at the specified offset</span><br><span class="line">  since: 2.2.0</span><br><span class="line"></span><br><span class="line">  STRLEN key</span><br><span class="line">  summary: Get the length of the value stored in a key</span><br><span class="line">  since: 2.2.0</span><br></pre></td></tr></table></figure>
<h3 id="2-2-Strings字符串操作命令详解"><a href="#2-2-Strings字符串操作命令详解" class="headerlink" title="2.2 Strings字符串操作命令详解"></a>2.2 Strings字符串操作命令详解</h3><h4 id="2-2-1-SET-amp-GET"><a href="#2-2-1-SET-amp-GET" class="headerlink" title="2.2.1 SET&amp;GET"></a>2.2.1 SET&amp;GET</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help set</span><br><span class="line"></span><br><span class="line">  SET key value [EX seconds] [PX milliseconds] [NX|XX]</span><br><span class="line">  summary: Set the string value of a key</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: string</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help get</span><br><span class="line"></span><br><span class="line">  GET key</span><br><span class="line">  summary: Get the value of a key</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>通常用SET command 和 GET command来设置和获取字符串值，值可以是任何种类的字符串（包括二进制数据）</p>
<ul>
<li><p>EX：过期时间</p>
</li>
<li><p>PX：时间单位</p>
</li>
<li><p>NX ：key未创建时则创建，已经创建时不创建。</p>
<p>用处：分布式锁，一堆人都想删一个文件，很多链接对单线程redis操作，谁成功就拿到锁，其余人失败</p>
</li>
<li><p>XX：只能更新，key存在时更新，key不存在时不能更新</p>
</li>
</ul>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span>测试</span></span><br><span class="line">127.0.0.1:6379&gt; set k1 hello</span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash"> get测试</span></span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;hello&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> nx测试</span></span><br><span class="line">127.0.0.1:6379&gt; set k1 ooxx nx</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;hello&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> xx测试</span></span><br><span class="line">127.0.0.1:6379&gt; set k2 hello xx</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<h4 id="2-2-2-MSET-amp-MGET"><a href="#2-2-2-MSET-amp-MGET" class="headerlink" title="2.2.2 MSET&amp;MGET"></a>2.2.2 MSET&amp;MGET</h4><p>同时设置一个或多个 key-value 对。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help mset</span><br><span class="line"></span><br><span class="line">  MSET key value [key value ...]</span><br><span class="line">  summary: Set multiple keys to multiple values</span><br><span class="line">  since: 1.0.1</span><br><span class="line">  group: string</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; help mget</span><br><span class="line"></span><br><span class="line">  MGET key [key ...]</span><br><span class="line">  summary: Get the values of all the given keys</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置[k3,a]，[k4,b]</span></span><br><span class="line">127.0.0.1:6379&gt; mset k3 a k4 b</span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取k3，k4的value</span></span><br><span class="line">127.0.0.1:6379&gt; mget k3 k4</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-3-APPEND"><a href="#2-2-3-APPEND" class="headerlink" title="2.2.3 APPEND"></a>2.2.3 APPEND</h4><p>如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help append</span><br><span class="line"></span><br><span class="line">  APPEND key value</span><br><span class="line">  summary: Append a value to a key</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; append k1 &quot; world&quot;</span><br><span class="line">(integer) 11</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;hello world&quot;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-4-GETRANGE-amp-SETRANGE"><a href="#2-2-4-GETRANGE-amp-SETRANGE" class="headerlink" title="2.2.4 GETRANGE&amp;SETRANGE"></a>2.2.4 GETRANGE&amp;SETRANGE</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help getrange</span><br><span class="line"></span><br><span class="line">  GETRANGE key start end</span><br><span class="line">  summary: Get a substring of the string stored at a key</span><br><span class="line">  since: 2.4.0</span><br><span class="line">  group: string</span><br><span class="line">  </span><br><span class="line">127.0.0.1:6379&gt; help setrange</span><br><span class="line"></span><br><span class="line">  SETRANGE key offset value</span><br><span class="line">  summary: Overwrite part of a string at key starting at the specified offset</span><br><span class="line">  since: 2.2.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>GETRANGE：获取存储在指定 key 中字符串的子字符串。字符串的截取范围由 start 和 end 两个偏移量决定(包括 start 和 end 在内)。</p>
<p>SETRANGE：用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 此时k1 value=<span class="string">&quot;hello world&quot;</span></span></span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;hello world&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取子字符串<span class="string">&quot;world&quot;</span></span></span><br><span class="line">127.0.0.1:6379&gt; GETRANGE k1 6 10</span><br><span class="line">&quot;world&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 逆向索引取值</span></span><br><span class="line">127.0.0.1:6379&gt; GETRANGE k1 6 -1</span><br><span class="line">&quot;world&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 正向索引取值</span></span><br><span class="line">127.0.0.1:6379&gt; GETRANGE k1 0 -1</span><br><span class="line">&quot;hello world&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> SETRANGE</span></span><br><span class="line">127.0.0.1:6379&gt; SETRANGE k1 6 yeyangshu</span><br><span class="line">(integer) 15</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;hello yeyangshu&quot;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-5-STRLEN"><a href="#2-2-5-STRLEN" class="headerlink" title="2.2.5 STRLEN"></a>2.2.5 STRLEN</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help strlen</span><br><span class="line"></span><br><span class="line">  STRLEN key</span><br><span class="line">  summary: Get the length of the value stored in a key</span><br><span class="line">  since: 2.2.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>获取指定 key 所储存的字符串值的长度。当 key 储存的不是字符串值时，返回一个错误。</p>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;hello yeyangshu&quot;</span><br><span class="line">127.0.0.1:6379&gt; STRLEN k1</span><br><span class="line">(integer) 15</span><br></pre></td></tr></table></figure>
<h4 id="2-2-6-GETSET"><a href="#2-2-6-GETSET" class="headerlink" title="2.2.6 GETSET"></a>2.2.6 GETSET</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help getset</span><br><span class="line"></span><br><span class="line">  GETSET key value</span><br><span class="line">  summary: Set the string value of a key and return its old value</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>设置指定 key 的值，并返回 key 的旧值。</p>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GET k1</span><br><span class="line">&quot;100&quot;</span><br><span class="line">127.0.0.1:6379&gt; GETSET k1 200</span><br><span class="line">&quot;100&quot;</span><br><span class="line">127.0.0.1:6379&gt; GET k1</span><br><span class="line">&quot;200&quot;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-7-MSETNX"><a href="#2-2-7-MSETNX" class="headerlink" title="2.2.7 MSETNX"></a>2.2.7 MSETNX</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help MSETNX</span><br><span class="line"></span><br><span class="line">  MSETNX key value [key value ...]</span><br><span class="line">  summary: Set multiple keys to multiple values, only if none of the keys exist</span><br><span class="line">  since: 1.0.1</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都<strong>不存在</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置k1、k2的值</span></span><br><span class="line">127.0.0.1:6379&gt; MSETNX k1 a k2 b</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; MGET k1 k2</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置k2、k3的值，k2已经存在整体返回失败</span></span><br><span class="line">127.0.0.1:6379&gt; MSETNX k2 c k3 d</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>
<h3 id="2-3-Strings数值操作命令详解"><a href="#2-3-Strings数值操作命令详解" class="headerlink" title="2.3 Strings数值操作命令详解"></a>2.3 Strings数值操作命令详解</h3><h4 id="2-3-1-INCR-amp-DECR"><a href="#2-3-1-INCR-amp-DECR" class="headerlink" title="2.3.1 INCR&amp;DECR"></a>2.3.1 INCR&amp;DECR</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help incr</span><br><span class="line"></span><br><span class="line">  INCR key</span><br><span class="line">  summary: Increment the integer value of a key by one</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: string</span><br><span class="line">  </span><br><span class="line">127.0.0.1:6379&gt; help decr</span><br><span class="line"></span><br><span class="line">  DECR key</span><br><span class="line">  summary: Decrement the integer value of a key by one</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>INCR：将 key 中储存的数字值增一。</p>
<ul>
<li>如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作。</li>
<li>如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</li>
</ul>
<p>DECR：将 key 中储存的数字值减一。</p>
<ul>
<li><p>如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECR 操作。</p>
</li>
<li><p>如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</p>
</li>
</ul>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> k1原值99</span></span><br><span class="line">127.0.0.1:6379&gt; INCR k1</span><br><span class="line">(integer) 100</span><br><span class="line">127.0.0.1:6379&gt; GET k1</span><br><span class="line">&quot;100&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 不存在k6这个key</span></span><br><span class="line">127.0.0.1:6379&gt; incr k6</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get k6</span><br><span class="line">&quot;1&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> k1原值100</span></span><br><span class="line">127.0.0.1:6379&gt; DECR k1</span><br><span class="line">(integer) 99</span><br><span class="line"><span class="meta">#</span><span class="bash"> 不存在k7这个key</span></span><br><span class="line">127.0.0.1:6379&gt; DECR k7</span><br><span class="line">(integer) -1</span><br></pre></td></tr></table></figure>
<h4 id="2-3-2-INCRBY-amp-DECRBY"><a href="#2-3-2-INCRBY-amp-DECRBY" class="headerlink" title="2.3.2 INCRBY&amp;DECRBY"></a>2.3.2 INCRBY&amp;DECRBY</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help incrby</span><br><span class="line"></span><br><span class="line">  INCRBY key increment</span><br><span class="line">  summary: Increment the integer value of a key by the given amount</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: string</span><br><span class="line">  </span><br><span class="line">127.0.0.1:6379&gt; help decrby</span><br><span class="line"></span><br><span class="line">  DECRBY key decrement</span><br><span class="line">  summary: Decrement the integer value of a key by the given number</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>INCRBY：将 key 中储存的数字加上指定的增量值。</p>
<ul>
<li><p>如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCRBY 命令。</p>
</li>
<li><p>如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</p>
</li>
</ul>
<p>DECRBY：将 key 所储存的值减去指定的减量值。</p>
<ul>
<li><p>如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECRBY 操作。</p>
</li>
<li><p>如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</p>
</li>
</ul>
<p>案例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GET k1</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; INCRBY k1 <span class="number">10</span></span><br><span class="line">(integer) <span class="number">11</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GET k1</span><br><span class="line"><span class="string">&quot;11&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; DECRBY k1 <span class="number">10</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GET k1</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-3-3-INCRBYFLOAT"><a href="#2-3-3-INCRBYFLOAT" class="headerlink" title="2.3.3 INCRBYFLOAT"></a>2.3.3 INCRBYFLOAT</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help incrbyfloat</span><br><span class="line"></span><br><span class="line">  INCRBYFLOAT key increment</span><br><span class="line">  summary: Increment the float value of a key by the given amount</span><br><span class="line">  since: 2.6.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>INCRBYFLOAT：为 key 中所储存的值加上指定的浮点数增量值。</p>
<ul>
<li>如果 key 不存在，那么 INCRBYFLOAT 会先将 key 的值设为 0 ，再执行加法操作</li>
</ul>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GET k1</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; INCRBYFLOAT k1 1.1</span><br><span class="line">&quot;2.1&quot;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-Strings位图操作命令详解"><a href="#2-4-Strings位图操作命令详解" class="headerlink" title="2.4 Strings位图操作命令详解"></a>2.4 Strings位图操作命令详解</h3><h4 id="2-4-1-SETBIT"><a href="#2-4-1-SETBIT" class="headerlink" title="2.4.1 SETBIT"></a>2.4.1 SETBIT</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help setbit</span><br><span class="line"></span><br><span class="line">  SETBIT key offset value</span><br><span class="line">  summary: Sets or clears the bit at offset in the string value stored at key</span><br><span class="line">  since: 2.2.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</p>
<p><strong>注意：是二进制位上的偏移，非字节数组</strong></p>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 一个字节有八个二进制位，二进制的值只有0和1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将k1二进制位的第2位变为1，00000000 -&gt; 01000000</span></span><br><span class="line">127.0.0.1:6379&gt; SETBIT k1 1 1</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> k1长度为一个字节</span></span><br><span class="line">127.0.0.1:6379&gt; STRLEN k1</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 01000000在ASCII码中代表<span class="string">&#x27;@&#x27;</span></span></span><br><span class="line">127.0.0.1:6379&gt; GET k1</span><br><span class="line">&quot;@&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将k1二进制位的第8位变为1，01000000 -&gt; 01000001</span></span><br><span class="line">127.0.0.1:6379&gt; SETBIT k1 7 1</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时还没有超过8位，k1长度为1个字节</span></span><br><span class="line">127.0.0.1:6379&gt; STRLEN k1</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 01000001在ASCII码中代表<span class="string">&#x27;@&#x27;</span></span></span><br><span class="line">127.0.0.1:6379&gt; GET k1</span><br><span class="line">&quot;A&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将k1二进制位的第10位变为1，01000001 -&gt; 01000001 01000000</span></span><br><span class="line">127.0.0.1:6379&gt; SETBIT k1 9 1</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时已经超过8位，k1长度为2个字节</span></span><br><span class="line">127.0.0.1:6379&gt; STRLEN k1</span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 01000001 01000000在ASCII码中代表<span class="string">&#x27;A@&#x27;</span></span></span><br><span class="line">127.0.0.1:6379&gt; GET k1</span><br><span class="line">&quot;A@&quot;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-2-BITPOS"><a href="#2-4-2-BITPOS" class="headerlink" title="2.4.2 BITPOS"></a>2.4.2 BITPOS</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help bitpos</span><br><span class="line"></span><br><span class="line">  BITPOS key bit [start] [end]</span><br><span class="line">  summary: Find first bit set or clear in a string</span><br><span class="line">  since: 2.8.7</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>二进制位<code>1</code>在第几个字节和第几个字节之间最开始的位置</p>
<p><strong>注意：是字节，不是二进制位</strong></p>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 01000001 01000000</span></span><br><span class="line">127.0.0.1:6379&gt; GET k1</span><br><span class="line">&quot;A@&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在第一个字节中寻找二进制位为1的第一个位置，结果：下标为1的位置</span></span><br><span class="line">127.0.0.1:6379&gt; BITPOS k1 1 0 0</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在第二个字节中寻找二进制位为1的第一个位置，结果：下标为9的位置</span></span><br><span class="line">127.0.0.1:6379&gt; BITPOS k1 1 1 1</span><br><span class="line">(integer) 9</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在第一、二个字节中寻找二进制位为1的第一个位置，结果：下标为1的位置</span></span><br><span class="line">127.0.0.1:6379&gt; BITPOS k1 1 0 1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<h4 id="2-4-3-BITCOUNT"><a href="#2-4-3-BITCOUNT" class="headerlink" title="2.4.3 BITCOUNT"></a>2.4.3 BITCOUNT</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help bitcount</span><br><span class="line"></span><br><span class="line">  BITCOUNT key [start end]</span><br><span class="line">  summary: Count set bits in a string</span><br><span class="line">  since: 2.6.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>计算给定字符串中，被设置为 <code>1</code> 的比特位的数量。</p>
<ul>
<li><p>一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 <code>start</code> 或 <code>end</code> 参数，可以让计数只在特定的位上进行。</p>
</li>
<li><p>不存在的 <code>key</code> 被当成是空字符串来处理，因此对一个不存在的 <code>key</code> 进行 <code>BITCOUNT</code> 操作，结果为 <code>0</code> 。</p>
</li>
</ul>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 01000001 01000000</span></span><br><span class="line">127.0.0.1:6379&gt; GET k1</span><br><span class="line">&quot;A@&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在第一个字节中计算二进制位为1的数量，结果：2</span></span><br><span class="line">127.0.0.1:6379&gt; BITCOUNT k1 0 0</span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在第二个字节中计算二进制位为1的数量，结果：1</span></span><br><span class="line">127.0.0.1:6379&gt; BITCOUNT k1 1 1 </span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在第一、二个字节中计算二进制位为1的数量，结果：3</span></span><br><span class="line">127.0.0.1:6379&gt; BITCOUNT k1 0 1 </span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>
<h4 id="2-4-4-BITOP"><a href="#2-4-4-BITOP" class="headerlink" title="2.4.4 BITOP"></a>2.4.4 BITOP</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; help bitop</span><br><span class="line"></span><br><span class="line">  BITOP operation destkey key [key ...]</span><br><span class="line">  summary: Perform bitwise operations between strings</span><br><span class="line">  since: 2.6.0</span><br><span class="line">  group: string</span><br></pre></td></tr></table></figure>
<p>对一个或多个保存二进制位的字符串 <code>key</code> 进行位元操作，并将结果保存到 <code>destkey</code> 上。</p>
<p><code>operation</code> 可以是 <code>AND</code> 、 <code>OR</code> 、 <code>NOT</code> 、 <code>XOR</code> 这四种操作中的任意一种：</p>
<ul>
<li><code>BITOP AND destkey key [key ...]</code> ，对一个或多个 <code>key</code> 求逻辑并，并将结果保存到 <code>destkey</code> 。</li>
<li><code>BITOP OR destkey key [key ...]</code> ，对一个或多个 <code>key</code> 求逻辑或，并将结果保存到 <code>destkey</code> 。</li>
<li><code>BITOP XOR destkey key [key ...]</code> ，对一个或多个 <code>key</code> 求逻辑异或，并将结果保存到 <code>destkey</code> 。</li>
<li><code>BITOP NOT destkey key</code> ，对给定 <code>key</code> 求逻辑非，并将结果保存到 <code>destkey</code> 。</li>
</ul>
<p>除了 <code>NOT</code> 操作之外，其他操作都可以接受一个或多个 <code>key</code> 作为输入。</p>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SETBIT k1 1 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT k1 7 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;A&quot;</span><br><span class="line">127.0.0.1:6379&gt; SETBIT k2 1 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT k2 6 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">&quot;B&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 按位与计算k1、k2</span></span><br><span class="line">127.0.0.1:6379&gt; bitop and andkey k1 k2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get andkey</span><br><span class="line">&quot;@&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 按位或计算k1、k2</span></span><br><span class="line">127.0.0.1:6379&gt; bitop or orkey k1 k2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get orkey</span><br><span class="line">&quot;C&quot;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-String应用场景"><a href="#2-3-String应用场景" class="headerlink" title="2.3 String应用场景"></a>2.3 String应用场景</h2><h3 id="2-3-1-字符串"><a href="#2-3-1-字符串" class="headerlink" title="2.3.1 字符串"></a>2.3.1 字符串</h3><h3 id="2-3-2-数值"><a href="#2-3-2-数值" class="headerlink" title="2.3.2 数值"></a>2.3.2 数值</h3><h3 id="2-3-3-bitmap"><a href="#2-3-3-bitmap" class="headerlink" title="2.3.3 bitmap"></a>2.3.3 bitmap</h3><h4 id="2-3-3-1-用户系统，统计用户登陆天数，且窗口随机"><a href="#2-3-3-1-用户系统，统计用户登陆天数，且窗口随机" class="headerlink" title="2.3.3.1 用户系统，统计用户登陆天数，且窗口随机"></a>2.3.3.1 用户系统，统计用户登陆天数，且窗口随机</h4><p>公司的用户系统，统计未来用户的登陆天数，且窗口随机。比如说在电商的公司当中，统计双十一前一周和后一周用户的登陆天数。</p>
<ol>
<li><p>解决方案一：MySQL数据库</p>
<p>使用MySQL数据库，创建一张用户登录表，用户每次登录可以产生一行记录，登记登陆时间。</p>
<p>问题：</p>
<ul>
<li>关系型数据库表与表之间会有主外键或者关联，关联的 <code>id</code> 可能3、4个字节</li>
<li>成本复杂度，每张表每行需要存储一个日期，登陆时间，日期也需要至少4个字节</li>
</ul>
<p>一个用户的一笔登录就需要消耗8个字节，电商可能有几十万人，每人一年至少登陆200天，这张表的数据量可能非常大；随机窗口进行查询的时候，需要遍历所有的数据，成本非常高！</p>
</li>
<li><p>解决方案二：Redis数据库</p>
<p>成本计算，两个固定的数值，第一个固定的数值就是一年的天数，365或者366，假设一年400天，如果每一天从左向右对应一个二进制位，第一个二进制位代表第一天，第二个二进制位代表第二天，一共400个二进制位，400(位)/ 8=50(字节)，使用50个字节可以记录一个用户全年365天的登录状态。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yeyangshu第2天登录</span></span><br><span class="line">127.0.0.1:6379&gt; SETBIT yeyangshu 1 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> yeyangshu第8天登录</span></span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT yeyangshu 7 1</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> yeyangshu第365天登录</span></span><br><span class="line">127.0.0.1:6379&gt; SETBIT yeyangshu 364 1</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 计算总共占用的空间</span></span><br><span class="line">127.0.0.1:6379&gt; STRLEN yeyangshu</span><br><span class="line">(integer) 46</span><br></pre></td></tr></table></figure>
<p>统计最后两周用户登录的天数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 统计最后两周yeyangshu登陆天数</span></span><br><span class="line">127.0.0.1:6379&gt; BITCOUNT yeyangshu -2 -1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<p>优点：CPU对二进制位的计算速度是最快的，关系型数据库需要从磁盘读取文件，第一个会产生IO，第二个读取磁盘之后，需要将数据解码再参与计算，而且不是二进制位的计算</p>
</li>
</ol>
<h4 id="2-3-3-2-电商做活动，该准备多少礼物"><a href="#2-3-3-2-电商做活动，该准备多少礼物" class="headerlink" title="2.3.3.2 电商做活动，该准备多少礼物"></a>2.3.3.2 电商做活动，该准备多少礼物</h4><p>电商做活动，当天登陆就送礼物，准备多少礼物？假设电商有2亿用户，活动当天登录送礼物，每个人只能送一件，请问库存需要准备多少礼物？</p>
<p>电商里面有一个基本常识，用户分为僵尸用户、冷热用户（忠诚用户）。</p>
<p>过往一年中或同比去年的时间范围内或上一个月窗口内，网站有1亿活跃用户或100万活跃用户经常登录，其实根本不是2亿用户，所以最终的目标是活跃用户。</p>
<p>这也是需要经常做的一个统计：活跃用户统计。活跃用户统计的本质是什么？比如说1号到3号，1号里面有多少人，2号里面有多少人并且还需要去重，如何去设计？</p>
<p>需求综上：活跃用户统计，随机窗口，连续登录并且去重。</p>
<p>Redis做法</p>
<p>日期作为key，20200101，用户id映射到二进制位上。假设小明的id是10，小李的id是1000，二进制位1代表登录，二进制位0代表未登录，假设第一天只有小明登录了，<code>setbit 20200101 10 1</code>，第二天小明和小李都登陆了，<code>setbit 20200102 1000 1</code>，计算1号和2号的活跃用户。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> SETBIT date OFFSET id</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1号小明登录</span></span><br><span class="line">127.0.0.1:6379&gt; SETBIT 20200101 10 1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2号小明登录</span></span><br><span class="line">127.0.0.1:6379&gt; SETBIT 20200102 10 1</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2号小李登录</span></span><br><span class="line">127.0.0.1:6379&gt; SETBIT 20200102 1000 1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或运算，参加运算的两个对象，一个为1，其值为1，目的是统计这两天的登录人数</span></span><br><span class="line">127.0.0.1:6379&gt; BITOP or destkey 20200101 20200102</span><br><span class="line">(integer) 126</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> BITCOUNT计算出活跃人数</span></span><br><span class="line">127.0.0.1:6379&gt; BITCOUNT destkey 0 -1</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka可靠性探究</title>
    <url>/2021/04/19/Kafka%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<h1 id="可靠性探究"><a href="#可靠性探究" class="headerlink" title="可靠性探究"></a>可靠性探究</h1><a id="more"></a>

<h2 id="1-副本剖析"><a href="#1-副本剖析" class="headerlink" title="1 副本剖析"></a>1 副本剖析</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>深入理解Kafka：核心设计与实践原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka应用</title>
    <url>/2021/04/19/Kafka%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>深入理解Kafka：核心设计与实践原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka深入客户端</title>
    <url>/2021/04/19/Kafka%E6%B7%B1%E5%85%A5%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>深入理解Kafka：核心设计与实践原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka深入服务器</title>
    <url>/2021/04/19/Kafka%E6%B7%B1%E5%85%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h1 id="深入服务器"><a href="#深入服务器" class="headerlink" title="深入服务器"></a>深入服务器</h1><a id="more"></a>

<h2 id="1-协议设计"><a href="#1-协议设计" class="headerlink" title="1 协议设计"></a>1 协议设计</h2><p>Kafka自定义了一组基于TCP的二进制协议，只要遵守这组协议的格式，就可以向Kafka发送消息，也可以从Kafka中拉取消息，或者做一些其他的事情，比如提交消费位移等。</p>
<p>每种协议类型都有对应的请求（Request）和响应（Response），它们都遵守特定的协议模式。</p>
<p>协议请求头中包含 4 个域（Field）：</p>
<ul>
<li>api_key</li>
<li>api_version</li>
<li>correlation_id</li>
<li>client_id</li>
</ul>
<p>每种类型的 Response 也包含相同结构的协议响应头（ResponseHeader）和不同结构的响应体（ResponseBody）</p>
<p>协议响应头中只有一个域：</p>
<ul>
<li>correlation_id</li>
</ul>
<h2 id="2-时间轮"><a href="#2-时间轮" class="headerlink" title="2 时间轮"></a>2 时间轮</h2><p>Kafka中存在大量的延时操作，比如延时生产、延时拉取和延时删除等。Kafka基于时间轮的概念自定义实现了一个用于延时功能的定时器（SystemTimer）实现延时的功能。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>深入理解Kafka：核心设计与实践原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka监控</title>
    <url>/2021/04/19/Kafka%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>深入理解Kafka：核心设计与实践原理</tag>
      </tags>
  </entry>
  <entry>
    <title>代码大全-不常见的控制结构</title>
    <url>/2021/04/20/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8-%E4%B8%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>软件构建</tag>
        <tag>代码大全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka高级应用</title>
    <url>/2021/04/19/Kafka%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>深入理解Kafka：核心设计与实践原理</tag>
      </tags>
  </entry>
  <entry>
    <title>代码大全-不常见的数据类型</title>
    <url>/2021/04/20/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8-%E4%B8%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>软件构建</tag>
        <tag>代码大全</tag>
      </tags>
  </entry>
  <entry>
    <title>代码大全-伪代码编写过程</title>
    <url>/2021/04/20/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8-%E4%BC%AA%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>软件构建</tag>
        <tag>代码大全</tag>
      </tags>
  </entry>
  <entry>
    <title>代码大全-使用变量的一般事项</title>
    <url>/2021/04/20/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8-%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F%E7%9A%84%E4%B8%80%E8%88%AC%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>软件构建</tag>
        <tag>代码大全</tag>
      </tags>
  </entry>
  <entry>
    <title>代码大全-使用条件语句</title>
    <url>/2021/04/20/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8-%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>软件构建</tag>
        <tag>代码大全</tag>
      </tags>
  </entry>
  <entry>
    <title>代码大全-变量名的力量</title>
    <url>/2021/04/20/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8-%E5%8F%98%E9%87%8F%E5%90%8D%E7%9A%84%E5%8A%9B%E9%87%8F/</url>
    <content><![CDATA[<h1 id="变量名的力量"><a href="#变量名的力量" class="headerlink" title="变量名的力量"></a>变量名的力量</h1><p>本章主要适用于为变量、对象和基本数据命名，也适用于为类、包、文件以及其他的编程实体命名。</p>
<h2 id="1-选择好变量名的注意事项"><a href="#1-选择好变量名的注意事项" class="headerlink" title="1 选择好变量名的注意事项"></a>1 选择好变量名的注意事项</h2><p>变量和变量名是不同的东西，本质而言却是同一事物。变量的好与坏在很大程度上取决于它的命名的好坏。在给变量命名的时候需要小心谨慎。</p>
<p>一个不良变量名的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 糟糕的变量名</span></span><br><span class="line">x = x - xx;</span><br><span class="line">xxx = fido + salesTax(fido);</span><br><span class="line">x = x + lateFee(x1, x) + xxx;</span><br><span class="line">x = x + insertest(x1, x);</span><br></pre></td></tr></table></figure>
<p>上面的代码是基于一项余额和一组新开销来计算顾客的支付总额。</p>
<p>下面是这些代码的另一种写法。它可以使上述问题回答起来非常用意容易：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  良好的变量名</span></span><br><span class="line">balance  = balance -lastPayment;</span><br><span class="line">monthlyTotal = newPerchases + salesTax(newPerchases);</span><br><span class="line">balance = balance + lateFee(customId, balance) + monthlyTotal;</span><br><span class="line">balance = balance + insertest(customId, balance);</span><br></pre></td></tr></table></figure>
<p>一个号的变量名应该是可读的、易记的和恰如其分的、</p>
<h3 id="1-1-最重要的命名注意事项"><a href="#1-1-最重要的命名注意事项" class="headerlink" title="1.1 最重要的命名注意事项"></a>1.1 最重要的命名注意事项</h3><p>为变量命名时最重要的考虑事项是，改名字要完全、准确地描述出该变量所代表的事物。获得好名字的一种实用技巧就是用文字表达变量所代表的是什么。通常，对变量的描述就是最佳的变量名。</p>
<p>好的命名有两个特征：</p>
<ul>
<li>容易理解，不需要解释就可以读懂他们。</li>
<li>名字尽可能的明确</li>
</ul>
<h3 id="1-2-以问题为导向"><a href="#1-2-以问题为导向" class="headerlink" title="1.2 以问题为导向"></a>1.2 以问题为导向</h3><p>一个好记的名字反映的通常都是问题，而不是解决方案。一个好名字通常表达的是“什么”（what），而不是“如何”（how）。</p>
<h3 id="1-3-最适当的名字长度"><a href="#1-3-最适当的名字长度" class="headerlink" title="1.3 最适当的名字长度"></a>1.3 最适当的名字长度</h3><p>变量名的平均长度在 10 到 16 个字符之间的时候，程序调试所花费的气力是最小的。如果你发现了更短的名字，那么你需要认真检查，确保这些名字含义足够清晰。</p>
<h3 id="1-4-作用于对变量名的影响"><a href="#1-4-作用于对变量名的影响" class="headerlink" title="1.4 作用于对变量名的影响"></a>1.4 作用于对变量名的影响</h3><p>较长的名字适用于很少用到的变量或者全局变量，而较短的名字适用于局部变量或者循环变量。</p>
<h3 id="1-5-变量名中的计算值限定词"><a href="#1-5-变量名中的计算值限定词" class="headerlink" title="1.5 变量名中的计算值限定词"></a>1.5 变量名中的计算值限定词</h3><p>很多程序都有表示计算结果的变量：总额、平均值、最大值等等。如果你要用</p>
<h3 id="1-6-变量名的常用对仗词"><a href="#1-6-变量名的常用对仗词" class="headerlink" title="1.6 变量名的常用对仗词"></a>1.6 变量名的常用对仗词</h3><h2 id="2-为特定类型的数据命名"><a href="#2-为特定类型的数据命名" class="headerlink" title="2 为特定类型的数据命名"></a>2 为特定类型的数据命名</h2><h3 id="2-1-为循环下标命名"><a href="#2-1-为循环下标命名" class="headerlink" title="2.1 为循环下标命名"></a>2.1 为循环下标命名</h3><h4 id="2-1-1-约定俗称的下标-i、j-和-k"><a href="#2-1-1-约定俗称的下标-i、j-和-k" class="headerlink" title="2.1.1 约定俗称的下标 i、j 和 k"></a>2.1.1 约定俗称的下标 i、j 和 k</h4><p>循环是一种极为常见的计算机编程特征。i、j 和 k 这些名字都是约定俗称的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java示例：简单的循环变量名</span></span><br><span class="line"><span class="keyword">for</span> (i = firstItem; i &lt; lastItem; i++) &#123;</span><br><span class="line">    data[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-2-在循环外使用变量名"><a href="#2-1-2-在循环外使用变量名" class="headerlink" title="2.1.2 在循环外使用变量名"></a>2.1.2 在循环外使用变量名</h4><p>如果一个变量名要在循环之外使用，那么就应该为它取一个比 i、j 或 k 更有意义的名字。 例子：如果你在文件中读取记录，并且需要记下所有读取记录的数量，那么类似 <code>recordCount</code> 这样的名字就很合适。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java示例：描述性较好的循环变量名</span></span><br><span class="line"><span class="comment">// 读取记录的数量</span></span><br><span class="line">recordCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (moreScores()) &#123;</span><br><span class="line">    score[recordCount] = GetNextScore();</span><br><span class="line">    <span class="comment">// 增加读取记录的数量</span></span><br><span class="line">    recordCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继续使用读取记录的数量</span></span><br><span class="line"><span class="comment">// lines using recordCount.</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="2-1-3-循环的嵌套"><a href="#2-1-3-循环的嵌套" class="headerlink" title="2.1.3 循环的嵌套"></a>2.1.3 循环的嵌套</h4><p>导致循环变长的常见原因之一是出现循环的嵌套使用。如果你使用了多个嵌套的循环，那么就应该给循环变量赋予更长的名字以提高可读性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java示例：循环嵌套中的好循环变量名</span></span><br><span class="line"><span class="keyword">for</span> (teamIndex = <span class="number">0</span>; teamIndex &lt; teamCount; teamIndex++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (eventIndex = <span class="number">0</span>; eventIndex &lt; eventCount[teamIndex]; eventIndex++) &#123;</span><br><span class="line">        score[teamIndex][eventIndex] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>谨慎地为循环下标命名可以避免下标串话，同时这也使得数据访问变得更加清晰：<code>score[teamIndex][eventIndex]</code> 要比 <code>score[i][j]</code> 给出的信息更多。</p>
<h4 id="2-1-4-一定要用-i、j-和-k"><a href="#2-1-4-一定要用-i、j-和-k" class="headerlink" title="2.1.4 一定要用 i、j 和 k"></a>2.1.4 一定要用 i、j 和 k</h4><p>如果你一定要用 i、j 和 k，那么不要把它们用于简单循环下标之外的任何场景。</p>
<h4 id="2-1-4-一定要用-i、j-和-k-1"><a href="#2-1-4-一定要用-i、j-和-k-1" class="headerlink" title="2.1.4 一定要用 i、j 和 k"></a>2.1.4 一定要用 i、j 和 k</h4><h3 id="2-2-为状态变量命名"><a href="#2-2-为状态变量命名" class="headerlink" title="2.2 为状态变量命名"></a>2.2 为状态变量命名</h3><p>为状态变量取一个比 <code>flag</code> 更好的名字，最好把标记（flag）看做状态变量，标记的名字中不应该含有 flag，为了清楚起见，标记应该使用枚举、具名变量，或用作具名常量的全局变量来对其赋值，而且其值应该与上面这些变量做比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 含义模糊的标记</span></span><br><span class="line"><span class="keyword">if</span> (flag) &#123;...&#125;</span><br><span class="line"><span class="keyword">if</span> (statusFlag) &#123;...&#125;</span><br><span class="line"><span class="keyword">if</span> (printFlag) &#123;...&#125;</span><br><span class="line"><span class="keyword">if</span> (computeFlag) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更好地使用状态变量</span></span><br><span class="line"><span class="keyword">if</span> (dataReday) &#123;...&#125;</span><br><span class="line"><span class="keyword">if</span> (characterType) &#123;...&#125;</span><br><span class="line"><span class="keyword">if</span> (reportType) &#123;...&#125;</span><br><span class="line"><span class="keyword">if</span> (recalcNeeded) &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>如果你发现自己需要猜测的某段代码的含义的时候，就应该考虑为变量重新命名。</p>
<h3 id="2-3-为临时变量命名"><a href="#2-3-为临时变量命名" class="headerlink" title="2.3 为临时变量命名"></a>2.3 为临时变量命名</h3><p>临时变量存储计算机的中间结果，作为临时占位符，以及存储内务管理值。它们常被赋予 temp、x或者一些模糊且缺乏描述性的名字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不提供信息的“临时”变量名，名字temp丝毫没有反映变量的功能</span></span><br><span class="line">temp = sqrt(b ^ <span class="number">2</span> - <span class="number">4</span> * a *c);</span><br><span class="line">root[<span class="number">0</span>] = (-b + temp) / (<span class="number">2</span> * a);</span><br><span class="line">root[<span class="number">1</span>] = (-b - temp) / (<span class="number">2</span> * a);</span><br><span class="line"></span><br><span class="line"><span class="comment">//用真正的变量替代“临时”变量，名字temp丝毫没有反映变量的功能</span></span><br><span class="line">discriminant = sqrt(b ^ <span class="number">2</span> - <span class="number">4</span> * a *c);</span><br><span class="line">root[<span class="number">0</span>] = (-b + discriminant) / (<span class="number">2</span> * a);</span><br><span class="line">root[<span class="number">1</span>] = (-b - discriminant) / (<span class="number">2</span> * a);</span><br></pre></td></tr></table></figure>
<h3 id="2-4-为布尔变量命名"><a href="#2-4-为布尔变量命名" class="headerlink" title="2.4 为布尔变量命名"></a>2.4 为布尔变量命名</h3><p><strong>谨记典型的布尔变量名</strong></p>
<ul>
<li>done：用 done 表示某件事已经完成。这一变量可用于表示循环结束或者一些其他操作已完成。</li>
<li>error：用 error 表示有错误发生</li>
<li>found：用 found 表表明某个值已经找到了</li>
<li>success 或 ok：用 success（ok）来表明某一项操作是否成功</li>
</ul>
<p><strong>给布尔变量赋予隐含“真/假”含义的名字</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 糟糕的布尔变量名，没有明确true或false</span></span><br><span class="line"><span class="keyword">boolean</span> status;</span><br><span class="line"><span class="keyword">boolean</span> sourceFile;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更好的效果</span></span><br><span class="line"><span class="keyword">boolean</span> statusOK;</span><br><span class="line"><span class="keyword">boolean</span> sourceFileAvalible;</span><br><span class="line"><span class="keyword">boolean</span> sourceFileFound;</span><br></pre></td></tr></table></figure>
<p>不建议在布尔变量名前加 Is。降低简单逻辑表达式的可读性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if (isFound) 的可读性要略差于 if (found)</span></span><br><span class="line"><span class="keyword">if</span> (isFound) &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> (found) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用肯定的布尔变量名</strong></p>
<h3 id="2-5-为枚举类型命名"><a href="#2-5-为枚举类型命名" class="headerlink" title="2.5 为枚举类型命名"></a>2.5 为枚举类型命名</h3><p>在使用枚举类型的时候，可以通过使用组前缀，如<code>Color_</code>，<code>Plant_ </code>或者<code>Month_</code>来明确表示该类型的成员都属于一个组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Public Enum Color &#123;</span><br><span class="line">    Color_Red,</span><br><span class="line">    Color_Green,</span><br><span class="line">    Color_Blue；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Public Enum Plant &#123;</span><br><span class="line">    Plant_Earth,</span><br><span class="line">    Plant_Mars,</span><br><span class="line">    Plant_Venus；</span><br><span class="line">&#125;</span><br><span class="line">Public Enum Month &#123;</span><br><span class="line">    Month_January,</span><br><span class="line">    Month_Fanruary,</span><br><span class="line">    Month_December；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-命名规则的力量"><a href="#3-命名规则的力量" class="headerlink" title="3 命名规则的力量"></a>3 命名规则的力量</h2><h2 id="4-非正式命名规则"><a href="#4-非正式命名规则" class="headerlink" title="4 非正式命名规则"></a>4 非正式命名规则</h2><h2 id="5-标准前缀"><a href="#5-标准前缀" class="headerlink" title="5 标准前缀"></a>5 标准前缀</h2><h2 id="6-创建具备可读性的短名字"><a href="#6-创建具备可读性的短名字" class="headerlink" title="6 创建具备可读性的短名字"></a>6 创建具备可读性的短名字</h2><h2 id="7-应该避免的名字"><a href="#7-应该避免的名字" class="headerlink" title="7 应该避免的名字"></a>7 应该避免的名字</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>软件构建</tag>
        <tag>代码大全</tag>
      </tags>
  </entry>
  <entry>
    <title>代码大全-可以工作的类</title>
    <url>/2021/04/20/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8-%E5%8F%AF%E4%BB%A5%E5%B7%A5%E4%BD%9C%E7%9A%84%E7%B1%BB/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>软件构建</tag>
        <tag>代码大全</tag>
      </tags>
  </entry>
  <entry>
    <title>代码大全-基本数据类型</title>
    <url>/2021/04/20/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>软件构建</tag>
        <tag>代码大全</tag>
      </tags>
  </entry>
  <entry>
    <title>代码大全-组织直线型代码</title>
    <url>/2021/04/20/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8-%E7%BB%84%E7%BB%87%E7%9B%B4%E7%BA%BF%E5%9E%8B%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>软件构建</tag>
        <tag>代码大全</tag>
      </tags>
  </entry>
  <entry>
    <title>代码大全-控制循环</title>
    <url>/2021/04/20/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8-%E6%8E%A7%E5%88%B6%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>软件构建</tag>
        <tag>代码大全</tag>
      </tags>
  </entry>
  <entry>
    <title>代码大全-表驱动法</title>
    <url>/2021/04/20/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8-%E8%A1%A8%E9%A9%B1%E5%8A%A8%E6%B3%95/</url>
    <content><![CDATA[<h1 id="表驱动法"><a href="#表驱动法" class="headerlink" title="表驱动法"></a>表驱动法</h1><a id="more"></a>

<p>表驱动法是一种编程模式—从表里面查找信息而不使用逻辑语句（if 和 case）。</p>
<p>事实上，凡是能通过逻辑语句来选择的事物，都可以通过查表来选择。</p>
<h2 id="1-表驱动法使用总则"><a href="#1-表驱动法使用总则" class="headerlink" title="1 表驱动法使用总则"></a>1 表驱动法使用总则</h2><p>在适当的情况下，采用表驱动法，所生成的代码会比复杂逻辑代码更简单、更容易修改，而且效率更高。</p>
<h3 id="1-1-使用表驱动法的两个问题"><a href="#1-1-使用表驱动法的两个问题" class="headerlink" title="1.1 使用表驱动法的两个问题"></a>1.1 使用表驱动法的两个问题</h3><h4 id="1-1-1-问题一：怎样从表中查询条目？"><a href="#1-1-1-问题一：怎样从表中查询条目？" class="headerlink" title="1.1.1 问题一：怎样从表中查询条目？"></a>1.1.1 问题一：怎样从表中查询条目？</h4><p>表查询记录的方法列表：</p>
<ul>
<li>直接方法</li>
<li>索引方法</li>
<li>阶梯方法</li>
</ul>
<h4 id="1-1-2-问题二：在表里存些什么？"><a href="#1-1-2-问题二：在表里存些什么？" class="headerlink" title="1.1.2 问题二：在表里存些什么？"></a>1.1.2 问题二：在表里存些什么？</h4><ul>
<li>存数据</li>
<li>存动作</li>
<li>在某些语言中，存对实现该动作的子程序的引用</li>
</ul>
<h2 id="2-直接访问表"><a href="#2-直接访问表" class="headerlink" title="2 直接访问表"></a>2 直接访问表</h2><p>直接访问表代替了更为复杂的逻辑控制结构，无须绕很多复杂的圈子就能在表中找到比想要的信息。</p>
<h3 id="2-1-案例一：一个月中的天数"><a href="#2-1-案例一：一个月中的天数" class="headerlink" title="2.1 案例一：一个月中的天数"></a>2.1 案例一：一个月中的天数</h3><p>如果你需要计算每个月中的天数，笨方法是写一个大的 if 语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java示例：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaysInMonth</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> month = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> days = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (month == <span class="number">1</span>) &#123;</span><br><span class="line">            days = <span class="number">31</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (month == <span class="number">2</span>) &#123;</span><br><span class="line">            days = <span class="number">28</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (month == <span class="number">3</span>) &#123;</span><br><span class="line">            days = <span class="number">31</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (month == <span class="number">4</span>) &#123;</span><br><span class="line">            days = <span class="number">30</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (month == <span class="number">5</span>) &#123;</span><br><span class="line">            days = <span class="number">31</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (month == <span class="number">6</span>) &#123;</span><br><span class="line">            days = <span class="number">30</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (month == <span class="number">7</span>) &#123;</span><br><span class="line">            days = <span class="number">31</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (month == <span class="number">8</span>) &#123;</span><br><span class="line">            days = <span class="number">31</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (month == <span class="number">9</span>) &#123;</span><br><span class="line">            days = <span class="number">30</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (month == <span class="number">10</span>) &#123;</span><br><span class="line">            days = <span class="number">31</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (month == <span class="number">11</span>) &#123;</span><br><span class="line">            days = <span class="number">30</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (month == <span class="number">12</span>) &#123;</span><br><span class="line">            days = <span class="number">31</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(days);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 31</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更简单的、更容易修改的方法是把这些数据存到一张表里面。无须写很长的 if 语句，只需要一条简单的数组访问语句就可以。</p>
<p>重点代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java示例：确定各月天数的优雅做法</span></span><br><span class="line"><span class="keyword">int</span>[] daysPerMonth = &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>修改后代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaysInMonth</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 2000年，闰年</span></span><br><span class="line">        System.out.println(daysPerMonthInYear(<span class="number">2</span>, <span class="number">2000</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2001年，非闰年</span></span><br><span class="line">        System.out.println(daysPerMonthInYear(<span class="number">2</span>, <span class="number">2001</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算某年某月份的天数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> month 月份</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> year 年</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 天数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">daysPerMonthInYear</span><span class="params">(<span class="keyword">int</span> month, <span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每月天数表</span></span><br><span class="line">        <span class="keyword">int</span>[] daysPerMonth = &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> days;</span><br><span class="line">        days = daysPerMonth[month - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> == month) &#123;</span><br><span class="line">            days += isLeapYear(year);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> days;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否是闰年</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> year 年份</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 闰年：1，非闰年：0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">isLeapYear</span><span class="params">(<span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((year % <span class="number">4</span> == <span class="number">0</span>) &amp;&amp; (year % <span class="number">400</span>) != <span class="number">0</span> || (year % <span class="number">400</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-实例二：保险费率"><a href="#2-2-实例二：保险费率" class="headerlink" title="2.2 实例二：保险费率"></a>2.2 实例二：保险费率</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java示例</span></span><br><span class="line"><span class="comment">// 1 判断性别</span></span><br><span class="line"><span class="keyword">if</span> (gender == Gender.Famale) &#123;</span><br><span class="line">    <span class="comment">// 2 判断婚姻状态</span></span><br><span class="line">    <span class="keyword">if</span> (maratalStatus == MaratalStatus.Single) &#123;</span><br><span class="line">        <span class="comment">// 3 判断吸烟状态</span></span><br><span class="line">        <span class="keyword">if</span> (smokingStatus == SmokingStatus.NonSmoking) &#123;</span><br><span class="line">            <span class="comment">// 4 判断年龄</span></span><br><span class="line">            <span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">                rate = <span class="number">200.00</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (age == <span class="number">18</span>) &#123;</span><br><span class="line">                rate = <span class="number">250.00</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (age == <span class="number">19</span>) &#123;</span><br><span class="line">                rate = <span class="number">300.00</span></span><br><span class="line">                    <span class="comment">// ......</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (age &gt; <span class="number">65</span>) &#123;</span><br><span class="line">                rate = <span class="number">450</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">                rate = <span class="number">200.00</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (age == <span class="number">18</span>) &#123;</span><br><span class="line">                rate = <span class="number">250.00</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (age == <span class="number">19</span>) &#123;</span><br><span class="line">                rate = <span class="number">300.00</span></span><br><span class="line">                    <span class="comment">// ......</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (age &gt; <span class="number">65</span>) &#123;</span><br><span class="line">                rate = <span class="number">450</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maratalStatus == MaratalStatus.Married) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (gender == Gender.Famale) &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更好的做法</p>
<h2 id="3-索引访问表"><a href="#3-索引访问表" class="headerlink" title="3 索引访问表"></a>3 索引访问表</h2><h2 id="4-阶梯访问表"><a href="#4-阶梯访问表" class="headerlink" title="4 阶梯访问表"></a>4 阶梯访问表</h2><h2 id="5-表查询的其他示例"><a href="#5-表查询的其他示例" class="headerlink" title="5 表查询的其他示例"></a>5 表查询的其他示例</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>软件构建</tag>
        <tag>代码大全</tag>
      </tags>
  </entry>
  <entry>
    <title>代码大全-防御式编程</title>
    <url>/2021/04/20/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8-%E9%98%B2%E5%BE%A1%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>软件构建</tag>
        <tag>代码大全</tag>
      </tags>
  </entry>
  <entry>
    <title>代码大全-高质量的子程序</title>
    <url>/2021/04/20/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8-%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E5%AD%90%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="高质量的子程序"><a href="#高质量的子程序" class="headerlink" title="高质量的子程序"></a>高质量的子程序</h1><p>什么是子程序？</p>
<p>子程序是为实现一个特定目的而编写的一个可被调用的方法或过程。Java中为方法（method）。</p>
<h2 id="1-创建子程序的正当理由"><a href="#1-创建子程序的正当理由" class="headerlink" title="1 创建子程序的正当理由"></a>1 创建子程序的正当理由</h2><h3 id="1-1-降低复杂度"><a href="#1-1-降低复杂度" class="headerlink" title="1.1 降低复杂度"></a>1.1 降低复杂度</h3><p>可以通过创建子程序来隐藏一些信息，可以直接调用该子程序而无需了解其内部工作细节。</p>
<h3 id="1-2-引入中间、易懂的抽象"><a href="#1-2-引入中间、易懂的抽象" class="headerlink" title="1.2 引入中间、易懂的抽象"></a>1.2 引入中间、易懂的抽象</h3><p>把一段代码放入一个名字恰当的子程序内，时说明这段代码用意最好的方法之一。</p>
<p>修改前：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node = node.next;</span><br><span class="line">        leafName = node.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    leafName = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">leafName = GetLeafNode(node);</span><br></pre></td></tr></table></figure>
<p>取一个好名字就足够证明它的用意了。</p>
<h3 id="1-3-避免代码重复"><a href="#1-3-避免代码重复" class="headerlink" title="1.3 避免代码重复"></a>1.3 避免代码重复</h3><p>如果在两段子程序内编写相似的代码，应该把两段子程序中的重复代码提取出来，有两种方法：</p>
<ul>
<li>将其中相同的部分放入一个基类，然后把两段程序中的差异代码放入派生类中。</li>
<li>把相同的代码放入新的子程序中，再让其余的代码来调用这个子程序。</li>
</ul>
<p>与代码重复出现相比，让相同的代码只出现一次可以节约空间。代码改动起来也更方便，只需要在一处修改即可。</p>
<h3 id="1-4-支持子类化"><a href="#1-4-支持子类化" class="headerlink" title="1.4 支持子类化"></a>1.4 支持子类化</h3><h3 id="1-5-隐藏顺序"><a href="#1-5-隐藏顺序" class="headerlink" title="1.5 隐藏顺序"></a>1.5 隐藏顺序</h3><p>把处理事件的顺序隐藏起来是个好主意。</p>
<p>案例：</p>
<ol>
<li>一个程序通常都是先从用户那里读取数据，然后再从文件中读取辅助数据，那么，无论是从用户那里读取数据的子程序（方法）还是从文件中读取数据的子程序（方法），都<strong>不应该依赖</strong>另一个程序是否已执行。</li>
<li>假设写了两行代码，先读取栈顶的数值，然后减少 <code>stackTop</code> 变量的值。你应该把这两行代码放到一个叫 <code>popStack()</code> 的子程序（方法）中。从而将这两行代码所必须执行的顺序隐藏起来。</li>
</ol>
<h3 id="1-6-提高可移植性"><a href="#1-6-提高可移植性" class="headerlink" title="1.6 提高可移植性"></a>1.6 提高可移植性</h3><h3 id="1-7-简化复杂的布尔判断"><a href="#1-7-简化复杂的布尔判断" class="headerlink" title="1.7 简化复杂的布尔判断"></a>1.7 简化复杂的布尔判断</h3><p>为了理解程序的流程，通常没有必要去研究那些复杂的布尔判断细节。应该把这些判断放入到函数中，以提高代码的可读性：</p>
<ol>
<li>可以把判断的细节放到一边；</li>
<li>一个具有描述性的函数名字可以概括出该判断的目的。</li>
</ol>
<h3 id="1-8-似乎过于简单而没有必要写成子程序的操作（额外说明）"><a href="#1-8-似乎过于简单而没有必要写成子程序的操作（额外说明）" class="headerlink" title="1.8 似乎过于简单而没有必要写成子程序的操作（额外说明）"></a>1.8 似乎过于简单而没有必要写成子程序的操作（额外说明）</h3><p>编写有效的子程序时，一个最大的心理障碍是不情愿为了一个简单目的而编写一个简单子程序。</p>
<h4 id="1-8-1-提高可读性"><a href="#1-8-1-提高可读性" class="headerlink" title="1.8.1 提高可读性"></a>1.8.1 提高可读性</h4><p>小的子程序有很多优点，其一便是它们能够提高可读性。</p>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 某种计算</span></span><br><span class="line">points = deviceUnits * (POINT_PER_INCH / DeviceUnitsPerInch);</span><br></pre></td></tr></table></figure>
<p>大多数人可以看懂，但是可以表示的更加清楚</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deviceUnitsToPoints</span><span class="params">(<span class="keyword">int</span> Units)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 详情省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> deviceUnits;</span><br><span class="line">points = deviceUnitsToPoints(deviceUnits);</span><br></pre></td></tr></table></figure>
<p>这行代码更具有可读性。</p>
<h4 id="1-8-2-简单的操作常常会变成复杂操作"><a href="#1-8-2-简单的操作常常会变成复杂操作" class="headerlink" title="1.8.2 简单的操作常常会变成复杂操作"></a>1.8.2 简单的操作常常会变成复杂操作</h4><p>另一个原因就是简单的操作常常会变成复杂操作。</p>
<p>维护代码的时候扩展了函数，添加了几行代码，如果是原来的那样，就需要增加几十行代码，使用一个简单的子程序，就把代码从几十行减到了 3 行。</p>
<h2 id="2-在子程序层上设计"><a href="#2-在子程序层上设计" class="headerlink" title="2 在子程序层上设计"></a>2 在子程序层上设计</h2><p>目标是<strong>让每一个子程序只把一件事情做好，不再做其他任何事情。</strong></p>
<h2 id="3-好的子程序名字"><a href="#3-好的子程序名字" class="headerlink" title="3 好的子程序名字"></a>3 好的子程序名字</h2><h3 id="3-1-描述子程序所做的事情"><a href="#3-1-描述子程序所做的事情" class="headerlink" title="3.1 描述子程序所做的事情"></a>3.1 描述子程序所做的事情</h3><h3 id="3-2-避免使用无意义、模糊或表述不清的动词"><a href="#3-2-避免使用无意义、模糊或表述不清的动词" class="headerlink" title="3.2 避免使用无意义、模糊或表述不清的动词"></a>3.2 避免使用无意义、模糊或表述不清的动词</h3><h3 id="3-3-不要仅通过数字来形成不同的子程序名字"><a href="#3-3-不要仅通过数字来形成不同的子程序名字" class="headerlink" title="3.3 不要仅通过数字来形成不同的子程序名字"></a>3.3 不要仅通过数字来形成不同的子程序名字</h3><h3 id="3-4-根据需要确定子程序名字的长度"><a href="#3-4-根据需要确定子程序名字的长度" class="headerlink" title="3.4 根据需要确定子程序名字的长度"></a>3.4 根据需要确定子程序名字的长度</h3><p>变量名最佳长度是 9 到 15 个字符。</p>
<h3 id="3-5-给函数命名时要对返回值有所描述"><a href="#3-5-给函数命名时要对返回值有所描述" class="headerlink" title="3.5 给函数命名时要对返回值有所描述"></a>3.5 给函数命名时要对返回值有所描述</h3><p>函数有返回值，因此，函数的命名要应该针对其返回值进行。</p>
<p>好的函数名案例</p>
<ul>
<li>cos()</li>
<li>customId.next()</li>
<li>printer.isReady()</li>
<li>pen.currentColor</li>
</ul>
<p>它们精确的表达了该函数将要返回的结果。</p>
<h3 id="3-6-给过程起名时使用强烈的动词加宾语的形式"><a href="#3-6-给过程起名时使用强烈的动词加宾语的形式" class="headerlink" title="3.6 给过程起名时使用强烈的动词加宾语的形式"></a>3.6 给过程起名时使用强烈的动词加宾语的形式</h3><p>在面向对象的语言中，你不用在过程中加入对象的名字（宾语），因为对象本身已经包含在调用语句中了。</p>
<p>你会用</p>
<ul>
<li>document.print()</li>
<li>orderInfo.check()</li>
<li>monthlyRevenues.calc()</li>
</ul>
<p>等语句调用子程序。而诸如 <code>document.printDocument()</code> 这样的语句则显得臃肿，并且当它们在派生类中被调用时也容易产生误解。如果 <code>Check</code> （支票）类是从 <code>Document</code> （文档）类继承而来的，那么 <code>check.print()</code> 就很显然表示打印一张支票，而 <code>check.printDocument()</code> 看上去像是要打印支票簿或是信用卡的对账单，而不像打印支票本身。</p>
<h3 id="3-7-准确使用对仗词"><a href="#3-7-准确使用对仗词" class="headerlink" title="3.7 准确使用对仗词"></a>3.7 准确使用对仗词</h3><p>命名时遵守对仗词的命名规则有助于保持一致性。从而也提高可读性。</p>
<p>常见的对仗词组：</p>
<table>
<thead>
<tr>
<th align="center">对仗词</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">add/remove</td>
<td align="center">添加/移除</td>
</tr>
<tr>
<td align="center">begin/end</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">create/destory</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">first/last</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">get/put</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">get/set</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">increment/decrement</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">insert/delete</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">lock/unlock</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">min/max</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">next/previous</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">old/new</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">open/close</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">show/hide</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">source/target</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">start/stop</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">up/down</td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="3-8-为常用操作确定命名规则"><a href="#3-8-为常用操作确定命名规则" class="headerlink" title="3.8 为常用操作确定命名规则"></a>3.8 为常用操作确定命名规则</h3><h2 id="4-子程序可以有多长"><a href="#4-子程序可以有多长" class="headerlink" title="4 子程序可以有多长"></a>4 子程序可以有多长</h2><p>可以允许子程序的长度有序的增加到 100 行至 200 行。但是，与其对子程序的长度加以限制，还不如让下面的因素—如子程序的内聚性、嵌套的层次、变量的数量、决策点的数量、解释子程序用意所需的注释数量以及其他一些复杂度相关的考虑事项来决定子程序的长度。</p>
<h2 id="5-如何使用子程序参数"><a href="#5-如何使用子程序参数" class="headerlink" title="5 如何使用子程序参数"></a>5 如何使用子程序参数</h2><p>子程序之间的接口是程序中最容易出错的部分之一。</p>
<p>有研究发现，程序之间相互通信时所发生的错误可以占 39%。</p>
<h3 id="5-1-按照输入-修改-输出的顺序排列参数"><a href="#5-1-按照输入-修改-输出的顺序排列参数" class="headerlink" title="5.1 按照输入-修改-输出的顺序排列参数"></a>5.1 按照输入-修改-输出的顺序排列参数</h3><p>不要随机地按照字母的顺序排列参数，而应该先列出仅作为输入用途的参数，然后是既作为输入又作为输出用途的参数，最后才是仅作为输出用途的参数。</p>
<p>案例：Servlet 的 request 和 response</p>
<h3 id="5-2-考虑自己创建-in-和-out-关键字"><a href="#5-2-考虑自己创建-in-和-out-关键字" class="headerlink" title="5.2 考虑自己创建 in 和 out 关键字"></a>5.2 考虑自己创建 in 和 out 关键字</h3><h3 id="5-3-如果几个子程序都用了类似的一些参数，应该让这些参数的排列顺序保持一致"><a href="#5-3-如果几个子程序都用了类似的一些参数，应该让这些参数的排列顺序保持一致" class="headerlink" title="5.3 如果几个子程序都用了类似的一些参数，应该让这些参数的排列顺序保持一致"></a>5.3 如果几个子程序都用了类似的一些参数，应该让这些参数的排列顺序保持一致</h3><h3 id="5-4-使用所有的参数"><a href="#5-4-使用所有的参数" class="headerlink" title="5.4 使用所有的参数"></a>5.4 使用所有的参数</h3><p>既然往子程序中传递一个参数，就一定要用到这个参数。如果你不用它，就把它从子程序的接口中删去。</p>
<h3 id="5-5-不要把子程序的参数用作工作变量"><a href="#5-5-不要把子程序的参数用作工作变量" class="headerlink" title="5.5 不要把子程序的参数用作工作变量"></a>5.5 不要把子程序的参数用作工作变量</h3><p>案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不恰当地使用参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sample</span><span class="params">(<span class="keyword">int</span> inputVal)</span> </span>&#123;</span><br><span class="line">    inputVal = inputVal + <span class="number">1</span>;</span><br><span class="line">    inputVal = inputVal * <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> inputVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更好的方法是明确地引入一些工作变量，从而避免造成当前或日后的麻烦。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确的使用输入参数（伪代码）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sample</span><span class="params">(<span class="keyword">int</span> inputVal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> workingVal = inputVal;</span><br><span class="line">    workingVal = workingVal + <span class="number">1</span>;</span><br><span class="line">    workingVal = workingVal * <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> workingVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-6-在接口中对参数的假定加以说明"><a href="#5-6-在接口中对参数的假定加以说明" class="headerlink" title="5.6 在接口中对参数的假定加以说明"></a>5.6 在接口中对参数的假定加以说明</h3><p>如果你假定了传递给子程序的参数具有某种特征，那就要对这种假定加以说明。</p>
<p>一种比用注释还好的方法，是在代码中使用断言。</p>
<p>应该对哪些接口的假定进行说明呢？</p>
<ul>
<li>参数是仅用于输入的、要被修改的、还是仅用于输出的；</li>
<li>表示数量的参数的单位；</li>
<li>如果没有枚举类型的话，应说明状态代码和错误码的含义；</li>
<li>所能接受的数值的范围；</li>
<li>不该出现的特定数值。</li>
</ul>
<h3 id="5-7-把子程序的参数个数限制在大约-7-个以内"><a href="#5-7-把子程序的参数个数限制在大约-7-个以内" class="headerlink" title="5.7 把子程序的参数个数限制在大约 7 个以内"></a>5.7 把子程序的参数个数限制在大约 7 个以内</h3><h3 id="5-8-考虑对参数采用某种表示输入、修改、输出的命名规则"><a href="#5-8-考虑对参数采用某种表示输入、修改、输出的命名规则" class="headerlink" title="5.8 考虑对参数采用某种表示输入、修改、输出的命名规则"></a>5.8 考虑对参数采用某种表示输入、修改、输出的命名规则</h3><h3 id="5-9-为子程序传递用以维持其接口抽象的变量或对象"><a href="#5-9-为子程序传递用以维持其接口抽象的变量或对象" class="headerlink" title="5.9 为子程序传递用以维持其接口抽象的变量或对象"></a>5.9 为子程序传递用以维持其接口抽象的变量或对象</h3><p>接口参数传递变量还是对象问题的要害：<strong>子程序要表达何种抽象？</strong></p>
<p>如果要表达的抽象的子程序期望 3 项特定数据，但这 3 项数据只是碰巧由同一个对象所提供的，那就应该单独传递这 3 项数据；如果子程序接口想要表达的是一直想要拥有某给特定的对象，且该子程序要对这一对象执行这样那样的操作，如果单独传递 3 项特定的数据，那就是破坏了接口的抽象。</p>
<ul>
<li>如果你采用了传递整个对象的做法，并发现自己是先创建的对象，把被调用子程序所需的 3 项数据填入该对象，在调用子程序后又从对象中取出 3 项数据的值，那就是说明你应该值传递那 3 项数据而不是整个对象。</li>
<li>如果你发现自己经常需要修改子程序的参数表，而每次修改的参数都是来自于同一个对象，那就说明你应该传递整个对象而不是个别数据项了。</li>
</ul>
<h3 id="5-10-使用具名参数"><a href="#5-10-使用具名参数" class="headerlink" title="5.10 使用具名参数"></a>5.10 使用具名参数</h3><h3 id="5-11-确保实际参数与形式参数相匹配"><a href="#5-11-确保实际参数与形式参数相匹配" class="headerlink" title="5.11 确保实际参数与形式参数相匹配"></a>5.11 确保实际参数与形式参数相匹配</h3><h2 id="6-使用函数时需要特别考虑的事情"><a href="#6-使用函数时需要特别考虑的事情" class="headerlink" title="6 使用函数时需要特别考虑的事情"></a>6 使用函数时需要特别考虑的事情</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>软件构建</tag>
        <tag>代码大全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka日志存储</title>
    <url>/2021/04/18/Kafka%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h1 id="Kafka日志存储"><a href="#Kafka日志存储" class="headerlink" title="Kafka日志存储"></a>Kafka日志存储</h1><h2 id="1-文件目录布局"><a href="#1-文件目录布局" class="headerlink" title="1 文件目录布局"></a>1 文件目录布局</h2><p>Log 在物理上以命名形式为＜topic＞-＜partition＞文件夹的形式存储</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20210420224459562.png" alt="image-20210420224459562"></p>
<p>LogSegment 对应于磁盘上的一个日志文件和两个索引文件</p>
<p><img src="https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20210420225029440.png" alt="image-20210420225029440"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>深入理解Kafka：核心设计与实践原理</tag>
      </tags>
  </entry>
</search>
